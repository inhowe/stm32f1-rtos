L 1 "..\BSP\bsp_periph.c"
N/*
N*********************************************************************************************************
N*                                     MICIRUM BOARD SUPPORT PACKAGE
N*
N*                            (c) Copyright 2007-2008; Micrium, Inc.; Weston, FL
N*
N*                   All rights reserved.  Protected by international copyright laws.
N*                   Knowledge of the source code may not be used to write a similar
N*                   product.  This file may only be used in accordance with a license
N*                   and should not be redistributed in any way.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                        BOARD SUPPORT PACKAGE
N*
N*                                     ST Microelectronics STM32
N*                                              with the
N*                                   STM3210B-EVAL Evaluation Board
N*
N* Filename      : bsp_periph.c
N* Version       : V1.00
N* Programmer(s) : BAN
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                             INCLUDE FILES
N*********************************************************************************************************
N*/
N
N#define  BSP_PERIPH_MODULE
N#include <bsp.h>
L 1 "..\BSP\bsp.h" 1
N/*
N*********************************************************************************************************
N*                                     MICIRUM BOARD SUPPORT PACKAGE
N*
N*                             (c) Copyright 2007; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                        BOARD SUPPORT PACKAGE
N*
N*                                     ST Microelectronics STM32
N*                                              with the
N*                                   STM3210B-EVAL Evaluation Board
N*
N* Filename      : bsp.h
N* Version       : V1.10
N* Programmer(s) : BAN
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                                 MODULE
N*
N* Note(s) : (1) This header file is protected from multiple pre-processor inclusion through use of the
N*               BSP present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  BSP_PRESENT
N#define  BSP_PRESENT
N
N/*
N*********************************************************************************************************
N*                                                 EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   BSP_MODULE
S#define  BSP_EXT
N#else
N#define  BSP_EXT  extern
N#endif
N
N/*
N*********************************************************************************************************
N*                                              INCLUDE FILES
N*********************************************************************************************************
N*/
N
N#include    <cpu.h>
L 1 "..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView\cpu.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/CPU in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/CPU.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                            CPU PORT FILE
N*
N*                                            ARM-Cortex-M3
N*                                      RealView Development Suite
N*                            RealView Microcontroller Development Kit (MDK)
N*                                       ARM Developer Suite (ADS)
N*                                            Keil uVision
N*
N* Filename      : cpu.h
N* Version       : V1.19
N* Programmer(s) : JJL
N*                 BAN
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  CPU_CFG_MODULE_PRESENT
N#define  CPU_CFG_MODULE_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                          CPU INCLUDE FILES
N*
N* Note(s) : (1) The following CPU files are located in the following directories :
N*
N*               (a) \<CPU-Compiler Directory>\cpu_def.h
N*
N*               (b) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<CPU-Compiler Directory>\' directory & the
N*               specific CPU-compiler directory as additional include path directories.
N*********************************************************************************************************
N*/
N
N#include  <cpu_def.h>
L 1 "..\..\..\..\..\uC-CPU\cpu_def.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/CPU
N*                                    CPU CONFIGURATION & PORT LAYER
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/CPU is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/CPU in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/CPU.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      CPU CONFIGURATION DEFINES
N*
N* Filename      : cpu_def.h
N* Version       : V1.19
N* Programmer(s) : ITJ
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE in 'cpu.h' with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size            See Note #1a
N*
N*               (a) 64-bit word size NOT currently supported.
N*
N*               (b) Ideally, CPU_WORD_SIZE #define's would be calculated at compile-time through use of
N*                   the sizeof() operator.  However, some compilers do NOT allow pre-processor directives
N*                   to include run-time macro's -- e.g. 'sizeof()'.
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE in 'cpu.h' with CPU's data-word-memory order :
N*
N*                   CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*                   CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                        /* ----------------------- CPU WORD SIZE ---------------------- */
N#define  CPU_WORD_SIZE_08                          1    /*  8-bit word size = sizeof(CPU_INT08x).                       */
N#define  CPU_WORD_SIZE_16                          2    /* 16-bit word size = sizeof(CPU_INT16x).                       */
N#define  CPU_WORD_SIZE_32                          4    /* 32-bit word size = sizeof(CPU_INT32x).                       */
N#define  CPU_WORD_SIZE_64                          8    /* 64-bit word size = sizeof(CPU_INT64x) [see Note #1a].        */
N
N
N                                                        /* ------------------- CPU WORD-ENDIAN ORDER ------------------ */
N#define  CPU_ENDIAN_TYPE_NONE                      0    /*                                                              */
N#define  CPU_ENDIAN_TYPE_BIG                       1    /* Big-   endian word order (CPU words' most  significant ...   */
N                                                        /*                           ... octet @ lowest mem addr).      */
N#define  CPU_ENDIAN_TYPE_LITTLE                    2    /* Little-endian word order (CPU words' least significant ...   */
N                                                        /*                           ... octet @ lowest mem addr).      */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler allows in-line
N*                   assembly AND will correctly modify the local stack pointer when interrupt status is
N*                   pushed/popped onto the stack.
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (a) Save    interrupt status into a local variable
N*                       (b) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (c) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need to
N*               be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).  Configure
N*               'CPU_SR' data type in 'cpu.h' with the appropriate-sized CPU data type large enough to
N*               completely store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
N                                                        /* --------------- CPU CRITICAL SECTION METHODS --------------- */
N#define  CPU_CRITICAL_METHOD_NONE                  0    /*                                                              */
N#define  CPU_CRITICAL_METHOD_INT_DIS_EN            1    /* DIS/EN       ints.                                           */
N#define  CPU_CRITICAL_METHOD_STATUS_STK            2    /* Push/Pop     int status onto stk.                            */
N#define  CPU_CRITICAL_METHOD_STATUS_LOCAL          3    /* Save/Restore int status to local var.                        */
N
L 74 "..\..\..\..\..\uC-CPU\Arm-Cortex-M3\RealView\cpu.h" 2
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    CONFIGURE STANDARD DATA TYPES
N*
N* Note(s) : (1) Configure standard data types according to CPU-/compiler-specifications.
N*
N*           (2) (a) (1) 'CPU_FNCT_VOID' data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has no arguments.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_VOID  FnctName;
N*
N*                           FnctName();
N*
N*               (b) (1) 'CPU_FNCT_PTR'  data type defined to replace the commonly-used function pointer
N*                       data type of a pointer to a function which returns void & has a single void
N*                       pointer argument.
N*
N*                   (2) Example function pointer usage :
N*
N*                           CPU_FNCT_PTR   FnctName;
N*                           void          *pobj
N*
N*                           FnctName(pobj);
N*********************************************************************************************************
N*/
N
Ntypedef            void       CPU_VOID;
Ntypedef  unsigned  char       CPU_CHAR;                         /*  8-bit character                                     */
Ntypedef  unsigned  char       CPU_BOOLEAN;                      /*  8-bit boolean or logical                            */
Ntypedef  unsigned  char       CPU_INT08U;                       /*  8-bit unsigned integer                              */
Ntypedef    signed  char       CPU_INT08S;                       /*  8-bit   signed integer                              */
Ntypedef  unsigned  short      CPU_INT16U;                       /* 16-bit unsigned integer                              */
Ntypedef    signed  short      CPU_INT16S;                       /* 16-bit   signed integer                              */
Ntypedef  unsigned  int        CPU_INT32U;                       /* 32-bit unsigned integer                              */
Ntypedef    signed  int        CPU_INT32S;                       /* 32-bit   signed integer                              */
Ntypedef  unsigned  long long  CPU_INT64U;                       /* 64-bit unsigned integer                              */
Ntypedef    signed  long long  CPU_INT64S;                       /* 64-bit   signed integer                              */
N
Ntypedef            float      CPU_FP32;                         /* 32-bit floating point                                */
Ntypedef            double     CPU_FP64;                         /* 64-bit floating point                                */
N
N
Ntypedef            void     (*CPU_FNCT_VOID)(void);             /* See Note #2a.                                        */
Ntypedef            void     (*CPU_FNCT_PTR )(void *);           /* See Note #2b.                                        */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       CPU WORD CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_ADDR_SIZE & CPU_CFG_DATA_SIZE with CPU's word sizes :
N*
N*                   CPU_WORD_SIZE_08             8-bit word size
N*                   CPU_WORD_SIZE_16            16-bit word size
N*                   CPU_WORD_SIZE_32            32-bit word size
N*                   CPU_WORD_SIZE_64            64-bit word size            See Note #1a
N*
N*               (a) 64-bit word size NOT currently supported.
N*
N*           (2) Configure CPU_CFG_ENDIAN_TYPE with CPU's data-word-memory order :
N*
N*                   CPU_ENDIAN_TYPE_BIG         Big-   endian word order (CPU words' most  significant
N*                                                                         octet @ lowest memory address)
N*                   CPU_ENDIAN_TYPE_LITTLE      Little-endian word order (CPU words' least significant
N*                                                                         octet @ lowest memory address)
N*********************************************************************************************************
N*/
N
N                                                                /* Define  CPU         word sizes (see Note #1) :       */
N#define  CPU_CFG_ADDR_SIZE              CPU_WORD_SIZE_32        /* Defines CPU address word size.                       */
N
N#define  CPU_CFG_DATA_SIZE              CPU_WORD_SIZE_32        /* Defines CPU data    word size.                       */
N#define  CPU_CFG_ENDIAN_TYPE            CPU_ENDIAN_TYPE_LITTLE  /* Defines CPU data    word-memory order.               */
N
N
N/*
N*********************************************************************************************************
N*                                 CONFIGURE CPU ADDRESS & DATA TYPES
N*********************************************************************************************************
N*/
N
N                                                                /* CPU address type based on address bus size.          */
N#if     (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_ADDR;
N#elif   (CPU_CFG_ADDR_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_ADDR;
S#else
Stypedef  CPU_INT08U  CPU_ADDR;
N#endif
N
N                                                                /* CPU data    type based on data    bus size.          */
N#if     (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_32)
X#if     (4 == 4)
Ntypedef  CPU_INT32U  CPU_DATA;
N#elif   (CPU_CFG_DATA_SIZE == CPU_WORD_SIZE_16)
Stypedef  CPU_INT16U  CPU_DATA;
S#else
Stypedef  CPU_INT08U  CPU_DATA;
N#endif
N
N
Ntypedef  CPU_DATA    CPU_ALIGN;                                 /* Defines CPU data-word-alignment size.                */
Ntypedef  CPU_DATA    CPU_SIZE_T;                                /* Defines CPU standard 'size_t'   size.                */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   CRITICAL SECTION CONFIGURATION
N*
N* Note(s) : (1) Configure CPU_CFG_CRITICAL_METHOD with CPU's/compiler's critical section method :
N*
N*                                                       Enter/Exit critical sections by ...
N*
N*                   CPU_CRITICAL_METHOD_INT_DIS_EN      Disable/Enable interrupts
N*                   CPU_CRITICAL_METHOD_STATUS_STK      Push/Pop       interrupt status onto stack
N*                   CPU_CRITICAL_METHOD_STATUS_LOCAL    Save/Restore   interrupt status to local variable
N*
N*               (a) CPU_CRITICAL_METHOD_INT_DIS_EN  is NOT a preferred method since it does NOT support
N*                   multiple levels of interrupts.  However, with some CPUs/compilers, this is the only
N*                   available method.
N*
N*               (b) CPU_CRITICAL_METHOD_STATUS_STK    is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler allows in-line
N*                   assembly AND will correctly modify the local stack pointer when interrupt status is
N*                   pushed/popped onto the stack.
N*
N*               (c) CPU_CRITICAL_METHOD_STATUS_LOCAL  is one preferred method since it DOES support multiple
N*                   levels of interrupts.  However, this method assumes that the compiler provides C-level
N*                   &/or assembly-level functionality for the following :
N*
N*                     ENTER CRITICAL SECTION :
N*                       (a) Save    interrupt status into a local variable
N*                       (b) Disable interrupts
N*
N*                     EXIT  CRITICAL SECTION :
N*                       (c) Restore interrupt status from a local variable
N*
N*           (2) Critical section macro's most likely require inline assembly.  If the compiler does NOT
N*               allow inline assembly in C source files, critical section macro's MUST call an assembly
N*               subroutine defined in a 'cpu_a.asm' file located in the following software directory :
N*
N*                   \<CPU-Compiler Directory>\<cpu>\<compiler>\
N*
X
N*                       where
N*                               <CPU-Compiler Directory>    directory path for common   CPU-compiler software
N*                               <cpu>                       directory name for specific CPU
N*                               <compiler>                  directory name for specific compiler
N*
N*           (3) To save/restore interrupt status, a local variable 'cpu_sr' of type 'CPU_SR' MAY need to
N*               be declared (e.g. if 'CPU_CRITICAL_METHOD_STATUS_LOCAL' method is configured).  Configure
N*               'CPU_SR' data type with the appropriate-sized CPU data type large enough to completely
N*               store the CPU's/compiler's status word.
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  CPU_SR;                                    /* Defines   CPU status register size (see Note #3).    */
N
N                                                                /* Configure CPU critical method      (see Note #1) :   */
N#define  CPU_CFG_CRITICAL_METHOD        CPU_CRITICAL_METHOD_STATUS_LOCAL
N
N#define  CPU_CRITICAL_ENTER()           { cpu_sr = CPU_SR_Save(); }
N#define  CPU_CRITICAL_EXIT()            { CPU_SR_Restore(cpu_sr); }
N
N
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid        CPU_IntDis       (void);
Nvoid        CPU_IntEn        (void);
N
Nvoid        CPU_IntSrcDis    (CPU_INT08U  pos);
Nvoid        CPU_IntSrcEn     (CPU_INT08U  pos);
NCPU_INT16S  CPU_IntSrcPrioGet(CPU_INT08U  pos);
Nvoid        CPU_IntSrcPrioSet(CPU_INT08U  pos,
N                              CPU_INT08U  prio);
N
NCPU_SR      CPU_SR_Save      (void);
Nvoid        CPU_SR_Restore   (CPU_SR      cpu_sr);
N
NCPU_INT32U  CPU_CntLeadZeros (CPU_INT32U  val);
NCPU_INT32U  CPU_RevBits      (CPU_INT32U  val);
N
Nvoid        CPU_WaitForInt   (void);
Nvoid        CPU_WaitForExcept(void);
N
Nvoid        CPU_BitBandClr   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
Nvoid        CPU_BitBandSet   (CPU_ADDR    addr,
N                              CPU_INT08U  bit_nbr);
N
N/*
N*********************************************************************************************************
N*                                           INTERRUPT SOURCES
N*********************************************************************************************************
N*/
N
N#define  CPU_INT_STK_PTR                                   0
N#define  CPU_INT_RESET                                     1
N#define  CPU_INT_NMI                                       2
N#define  CPU_INT_HFAULT                                    3
N#define  CPU_INT_MEM                                       4
N#define  CPU_INT_BUSFAULT                                  5
N#define  CPU_INT_USAGEFAULT                                6
N#define  CPU_INT_RSVD_07                                   7
N#define  CPU_INT_RSVD_08                                   8
N#define  CPU_INT_RSVD_09                                   9
N#define  CPU_INT_RSVD_10                                  10
N#define  CPU_INT_SVCALL                                   11
N#define  CPU_INT_DBGMON                                   12
N#define  CPU_INT_RSVD_13                                  13
N#define  CPU_INT_PENDSV                                   14
N#define  CPU_INT_SYSTICK                                  15
N
N
N/*
N*********************************************************************************************************
N*                                             CPU REGISTERS
N*********************************************************************************************************
N*/
N
N#define  CPU_REG_NVIC_NVIC              (*((volatile CPU_INT32U *)(0xE000E004))) /* Int Ctrl'er Type Reg.               */
N#define  CPU_REG_NVIC_ST_CTRL           (*((volatile CPU_INT32U *)(0xE000E010))) /* SysTick Ctrl & Status Reg.          */
N#define  CPU_REG_NVIC_ST_RELOAD         (*((volatile CPU_INT32U *)(0xE000E014))) /* SysTick Reload      Value Reg.      */
N#define  CPU_REG_NVIC_ST_CURRENT        (*((volatile CPU_INT32U *)(0xE000E018))) /* SysTick Current     Value Reg.      */
N#define  CPU_REG_NVIC_ST_CAL            (*((volatile CPU_INT32U *)(0xE000E01C))) /* SysTick Calibration Value Reg.      */
N                                                                                 /* IRQ Set En Reg.                     */
N#define  CPU_REG_NVIC_SETEN(n)          (*((volatile CPU_INT32U *)(0xE000E100 + (n) * 4)))
N                                                                                 /* IRQ Clr En Reg.                     */
N#define  CPU_REG_NVIC_CLREN(n)          (*((volatile CPU_INT32U *)(0xE000E180 + (n) * 4)))
N                                                                                 /* IRQ Set Pending Reg.                */
N#define  CPU_REG_NVIC_SETPEND(n)        (*((volatile CPU_INT32U *)(0xE000E200 + (n) * 4)))
N                                                                                 /* IRQ Clr Pending Reg.                */
N#define  CPU_REG_NVIC_CLRPEND(n)        (*((volatile CPU_INT32U *)(0xE000E280 + (n) * 4)))
N                                                                                 /* IRQ Active Reg.                     */
N#define  CPU_REG_NVIC_ACTIVE(n)         (*((volatile CPU_INT32U *)(0xE000E300 + (n) * 4)))
N                                                                                 /* IRQ Prio Reg.                       */
N#define  CPU_REG_NVIC_PRIO(n)           (*((volatile CPU_INT32U *)(0xE000E400 + (n) * 4)))
N
N#define  CPU_REG_NVIC_CPUID             (*((volatile CPU_INT32U *)(0xE000ED00))) /* CPUID Base Reg.                     */
N#define  CPU_REG_NVIC_ICSR              (*((volatile CPU_INT32U *)(0xE000ED04))) /* Int Ctrl State  Reg.                */
N#define  CPU_REG_NVIC_VTOR              (*((volatile CPU_INT32U *)(0xE000ED08))) /* Vect Tbl Offset Reg.                */
N#define  CPU_REG_NVIC_AIRCR             (*((volatile CPU_INT32U *)(0xE000ED0C))) /* App Int/Reset Ctrl Reg.             */
N#define  CPU_REG_NVIC_SCR               (*((volatile CPU_INT32U *)(0xE000ED10))) /* System Ctrl Reg.                    */
N#define  CPU_REG_NVIC_CCR               (*((volatile CPU_INT32U *)(0xE000ED14))) /* Cfg    Ctrl Reg.                    */
N#define  CPU_REG_NVIC_SHPRI1            (*((volatile CPU_INT32U *)(0xE000ED18))) /* System Handlers  4 to  7 Prio.      */
N#define  CPU_REG_NVIC_SHPRI2            (*((volatile CPU_INT32U *)(0xE000ED1C))) /* System Handlers  8 to 11 Prio.      */
N#define  CPU_REG_NVIC_SHPRI3            (*((volatile CPU_INT32U *)(0xE000ED20))) /* System Handlers 12 to 15 Prio.      */
N#define  CPU_REG_NVIC_SHCSR             (*((volatile CPU_INT32U *)(0xE000ED24))) /* System Handler Ctrl & State Reg.    */
N#define  CPU_REG_NVIC_CFSR              (*((volatile CPU_INT32U *)(0xE000ED28))) /* Configurable Fault Status Reg.      */
N#define  CPU_REG_NVIC_HFSR              (*((volatile CPU_INT32U *)(0xE000ED2C))) /* Hard  Fault Status Reg.             */
N#define  CPU_REG_NVIC_DFSR              (*((volatile CPU_INT32U *)(0xE000ED30))) /* Debug Fault Status Reg.             */
N#define  CPU_REG_NVIC_MMFAR             (*((volatile CPU_INT32U *)(0xE000ED34))) /* Mem Manage Addr Reg.                */
N#define  CPU_REG_NVIC_BFAR              (*((volatile CPU_INT32U *)(0xE000ED38))) /* Bus Fault  Addr Reg.                */
N#define  CPU_REG_NVIC_AFSR              (*((volatile CPU_INT32U *)(0xE000ED3C))) /* Aux Fault Status Reg.               */
N
N#define  CPU_REG_NVIC_PFR0              (*((volatile CPU_INT32U *)(0xE000ED40))) /* Processor Feature Reg 0.            */
N#define  CPU_REG_NVIC_PFR1              (*((volatile CPU_INT32U *)(0xE000ED44))) /* Processor Feature Reg 1.            */
N#define  CPU_REG_NVIC_DFR0              (*((volatile CPU_INT32U *)(0xE000ED48))) /* Debug     Feature Reg 0.            */
N#define  CPU_REG_NVIC_AFR0              (*((volatile CPU_INT32U *)(0xE000ED4C))) /* Aux       Feature Reg 0.            */
N#define  CPU_REG_NVIC_MMFR0             (*((volatile CPU_INT32U *)(0xE000ED50))) /* Memory Model Feature Reg 0.         */
N#define  CPU_REG_NVIC_MMFR1             (*((volatile CPU_INT32U *)(0xE000ED54))) /* Memory Model Feature Reg 1.         */
N#define  CPU_REG_NVIC_MMFR2             (*((volatile CPU_INT32U *)(0xE000ED58))) /* Memory Model Feature Reg 2.         */
N#define  CPU_REG_NVIC_MMFR3             (*((volatile CPU_INT32U *)(0xE000ED5C))) /* Memory Model Feature Reg 3.         */
N#define  CPU_REG_NVIC_ISAFR0            (*((volatile CPU_INT32U *)(0xE000ED60))) /* ISA Feature Reg 0.                  */
N#define  CPU_REG_NVIC_ISAFR1            (*((volatile CPU_INT32U *)(0xE000ED64))) /* ISA Feature Reg 1.                  */
N#define  CPU_REG_NVIC_ISAFR2            (*((volatile CPU_INT32U *)(0xE000ED68))) /* ISA Feature Reg 2.                  */
N#define  CPU_REG_NVIC_ISAFR3            (*((volatile CPU_INT32U *)(0xE000ED6C))) /* ISA Feature Reg 3.                  */
N#define  CPU_REG_NVIC_ISAFR4            (*((volatile CPU_INT32U *)(0xE000ED70))) /* ISA Feature Reg 4.                  */
N#define  CPU_REG_NVIC_SW_TRIG           (*((volatile CPU_INT32U *)(0xE000EF00))) /* Software Trigger Int Reg.           */
N
N#define  CPU_REG_MPU_TYPE               (*((volatile CPU_INT32U *)(0xE000ED90))) /* MPU Type Reg.                       */
N#define  CPU_REG_MPU_CTRL               (*((volatile CPU_INT32U *)(0xE000ED94))) /* MPU Ctrl Reg.                       */
N#define  CPU_REG_MPU_REG_NBR            (*((volatile CPU_INT32U *)(0xE000ED98))) /* MPU Region Nbr Reg.                 */
N#define  CPU_REG_MPU_REG_BASE           (*((volatile CPU_INT32U *)(0xE000ED9C))) /* MPU Region Base Addr Reg.           */
N#define  CPU_REG_MPU_REG_ATTR           (*((volatile CPU_INT32U *)(0xE000EDA0))) /* MPU Region Attrib & Size Reg.       */
N
N#define  CPU_REG_DBG_CTRL               (*((volatile CPU_INT32U *)(0xE000EDF0))) /* Debug Halting Ctrl & Status Reg.    */
N#define  CPU_REG_DBG_SELECT             (*((volatile CPU_INT32U *)(0xE000EDF4))) /* Debug Core Reg Selector Reg.        */
N#define  CPU_REG_DBG_DATA               (*((volatile CPU_INT32U *)(0xE000EDF8))) /* Debug Core Reg Data     Reg.        */
N#define  CPU_REG_DBG_INT                (*((volatile CPU_INT32U *)(0xE000EDFC))) /* Debug Except & Monitor Ctrl Reg.    */
N
N/*
N*********************************************************************************************************
N*                                          CPU REGISTER BITS
N*********************************************************************************************************
N*/
N
N                                                                /* ---------- SYSTICK CTRL & STATUS REG BITS ---------- */
N#define  CPU_REG_NVIC_ST_CTRL_COUNTFLAG         DEF_BIT_16
N#define  CPU_REG_NVIC_ST_CTRL_CLKSOURCE         DEF_BIT_02
N#define  CPU_REG_NVIC_ST_CTRL_TICKINT           DEF_BIT_01
N#define  CPU_REG_NVIC_ST_CTRL_ENABLE            DEF_BIT_00
N
N
N                                                                /* -------- SYSTICK CALIBRATION VALUE REG BITS -------- */
N#define  CPU_REG_NVIC_ST_CAL_NOREF              DEF_BIT_31
N#define  CPU_REG_NVIC_ST_CAL_SKEW               DEF_BIT_30
N
N                                                                /* -------------- INT CTRL STATE REG BITS ------------- */
N#define  CPU_REG_NVIC_ICSR_NMIPENDSET           DEF_BIT_31
N#define  CPU_REG_NVIC_ICSR_PENDSVSET            DEF_BIT_28
N#define  CPU_REG_NVIC_ICSR_PENDSVCLR            DEF_BIT_27
N#define  CPU_REG_NVIC_ICSR_PENDSTSET            DEF_BIT_26
N#define  CPU_REG_NVIC_ICSR_PENDSTCLR            DEF_BIT_25
N#define  CPU_REG_NVIC_ICSR_ISRPREEMPT           DEF_BIT_23
N#define  CPU_REG_NVIC_ICSR_ISRPENDING           DEF_BIT_22
N#define  CPU_REG_NVIC_ICSR_RETTOBASE            DEF_BIT_11
N
N                                                                /* ------------- VECT TBL OFFSET REG BITS ------------- */
N#define  CPU_REG_NVIC_VTOR_TBLBASE              DEF_BIT_29
N
N                                                                /* ------------ APP INT/RESET CTRL REG BITS ----------- */
N#define  CPU_REG_NVIC_AIRCR_ENDIANNESS          DEF_BIT_15
N#define  CPU_REG_NVIC_AIRCR_SYSRESETREQ         DEF_BIT_02
N#define  CPU_REG_NVIC_AIRCR_VECTCLRACTIVE       DEF_BIT_01
N#define  CPU_REG_NVIC_AIRCR_VECTRESET           DEF_BIT_00
N
N                                                                /* --------------- SYSTEM CTRL REG BITS --------------- */
N#define  CPU_REG_NVIC_SCR_SEVONPEND             DEF_BIT_04
N#define  CPU_REG_NVIC_SCR_SLEEPDEEP             DEF_BIT_02
N#define  CPU_REG_NVIC_SCR_SLEEPONEXIT           DEF_BIT_01
N
N                                                                /* ----------------- CFG CTRL REG BITS ---------------- */
N#define  CPU_REG_NVIC_CCR_STKALIGN              DEF_BIT_09
N#define  CPU_REG_NVIC_CCR_BFHFNMIGN             DEF_BIT_08
N#define  CPU_REG_NVIC_CCR_DIV_0_TRP             DEF_BIT_04
N#define  CPU_REG_NVIC_CCR_UNALIGN_TRP           DEF_BIT_03
N#define  CPU_REG_NVIC_CCR_USERSETMPEND          DEF_BIT_01
N#define  CPU_REG_NVIC_CCR_NONBASETHRDENA        DEF_BIT_00
N
N                                                                /* ------- SYSTEM HANDLER CTRL & STATE REG BITS ------- */
N#define  CPU_REG_NVIC_SHCSR_USGFAULTENA         DEF_BIT_18
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTENA         DEF_BIT_17
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTENA         DEF_BIT_16
N#define  CPU_REG_NVIC_SHCSR_SVCALLPENDED        DEF_BIT_15
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTPENDED      DEF_BIT_14
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTPENDED      DEF_BIT_13
N#define  CPU_REG_NVIC_SHCSR_USGFAULTPENDED      DEF_BIT_12
N#define  CPU_REG_NVIC_SHCSR_SYSTICKACT          DEF_BIT_11
N#define  CPU_REG_NVIC_SHCSR_PENDSVACT           DEF_BIT_10
N#define  CPU_REG_NVIC_SHCSR_MONITORACT          DEF_BIT_08
N#define  CPU_REG_NVIC_SHCSR_SVCALLACT           DEF_BIT_07
N#define  CPU_REG_NVIC_SHCSR_USGFAULTACT         DEF_BIT_03
N#define  CPU_REG_NVIC_SHCSR_BUSFAULTACT         DEF_BIT_01
N#define  CPU_REG_NVIC_SHCSR_MEMFAULTACT         DEF_BIT_00
N
N                                                                /* -------- CONFIGURABLE FAULT STATUS REG BITS -------- */
N#define  CPU_REG_NVIC_CFSR_DIVBYZERO            DEF_BIT_25
N#define  CPU_REG_NVIC_CFSR_UNALIGNED            DEF_BIT_24
N#define  CPU_REG_NVIC_CFSR_NOCP                 DEF_BIT_19
N#define  CPU_REG_NVIC_CFSR_INVPC                DEF_BIT_18
N#define  CPU_REG_NVIC_CFSR_INVSTATE             DEF_BIT_17
N#define  CPU_REG_NVIC_CFSR_UNDEFINSTR           DEF_BIT_16
N#define  CPU_REG_NVIC_CFSR_BFARVALID            DEF_BIT_15
N#define  CPU_REG_NVIC_CFSR_STKERR               DEF_BIT_12
N#define  CPU_REG_NVIC_CFSR_UNSTKERR             DEF_BIT_11
N#define  CPU_REG_NVIC_CFSR_IMPRECISERR          DEF_BIT_10
N#define  CPU_REG_NVIC_CFSR_PRECISERR            DEF_BIT_09
N#define  CPU_REG_NVIC_CFSR_IBUSERR              DEF_BIT_08
N#define  CPU_REG_NVIC_CFSR_MMARVALID            DEF_BIT_07
N#define  CPU_REG_NVIC_CFSR_MSTKERR              DEF_BIT_04
N#define  CPU_REG_NVIC_CFSR_MUNSTKERR            DEF_BIT_03
N#define  CPU_REG_NVIC_CFSR_DACCVIOL             DEF_BIT_01
N#define  CPU_REG_NVIC_CFSR_IACCVIOL             DEF_BIT_00
N
N                                                                /* ------------ HARD FAULT STATUS REG BITS ------------ */
N#define  CPU_REG_NVIC_HFSR_DEBUGEVT             DEF_BIT_31
N#define  CPU_REG_NVIC_HFSR_FORCED               DEF_BIT_30
N#define  CPU_REG_NVIC_HFSR_VECTTBL              DEF_BIT_01
N
N                                                                /* ------------ DEBUG FAULT STATUS REG BITS ----------- */
N#define  CPU_REG_NVIC_DFSR_EXTERNAL             DEF_BIT_04
N#define  CPU_REG_NVIC_DFSR_VCATCH               DEF_BIT_03
N#define  CPU_REG_NVIC_DFSR_DWTTRAP              DEF_BIT_02
N#define  CPU_REG_NVIC_DFSR_BKPT                 DEF_BIT_01
N#define  CPU_REG_NVIC_DFSR_HALTED               DEF_BIT_00
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef   CPU_CFG_ADDR_SIZE
S#error   "CPU_CFG_ADDR_SIZE              not #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S
S#elif   ((CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_08) && \
S         (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_16) && \
S         (CPU_CFG_ADDR_SIZE != CPU_WORD_SIZE_32))
X#elif   ((4 != 1) &&          (4 != 2) &&          (4 != 4))
S#error   "CPU_CFG_ADDR_SIZE        illegally #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
N#endif
N
N
N#ifndef   CPU_CFG_DATA_SIZE
S#error   "CPU_CFG_DATA_SIZE              not #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
S
S#elif   ((CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_08) && \
S         (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_16) && \
S         (CPU_CFG_DATA_SIZE != CPU_WORD_SIZE_32))
X#elif   ((4 != 1) &&          (4 != 2) &&          (4 != 4))
S#error   "CPU_CFG_DATA_SIZE        illegally #define'd in 'cpu.h'               "
S#error   "                         [MUST be  CPU_WORD_SIZE_08   8-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_16  16-bit alignment]"
S#error   "                         [     ||  CPU_WORD_SIZE_32  32-bit alignment]"
N#endif
N
N
N
N#ifndef   CPU_CFG_ENDIAN_TYPE
S#error   "CPU_CFG_ENDIAN_TYPE            not #define'd in 'cpu.h'   "
S#error   "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error   "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
S
S#elif   ((CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_BIG   ) && \
S         (CPU_CFG_ENDIAN_TYPE != CPU_ENDIAN_TYPE_LITTLE))
X#elif   ((2 != 1   ) &&          (2 != 2))
S#error   "CPU_CFG_ENDIAN_TYPE      illegally #define'd in 'cpu.h'   "
S#error   "                         [MUST be  CPU_ENDIAN_TYPE_BIG   ]"
S#error   "                         [     ||  CPU_ENDIAN_TYPE_LITTLE]"
N#endif
N
N
N
N
N#ifndef   CPU_CFG_CRITICAL_METHOD
S#error   "CPU_CFG_CRITICAL_METHOD        not #define'd in 'cpu.h'             "
S#error   "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
S
S#elif   ((CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_INT_DIS_EN  ) && \
S         (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_STK  ) && \
S         (CPU_CFG_CRITICAL_METHOD != CPU_CRITICAL_METHOD_STATUS_LOCAL))
X#elif   ((3 != 1  ) &&          (3 != 2  ) &&          (3 != 3))
S#error   "CPU_CFG_CRITICAL_METHOD  illegally #define'd in 'cpu.h'             "
S#error   "                         [MUST be  CPU_CRITICAL_METHOD_INT_DIS_EN  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_STK  ]"
S#error   "                         [     ||  CPU_CRITICAL_METHOD_STATUS_LOCAL]"
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of CPU cfg module inclusion.                     */
L 60 "..\BSP\bsp.h" 2
N#include    <lib_def.h>
L 1 "..\..\..\..\..\uC-LIB\lib_def.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/LIB
N*                                       CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/LIB in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/LIB.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     CORE CUSTOM LIBRARY MODULE
N*
N* Filename      : lib_def.h
N* Version       : V1.25
N* Programmer(s) : ITJ
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_DEF_MODULE_PRESENT
N#define  LIB_DEF_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                CUSTOM LIBRARY MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The custom library module software version is denoted as follows :
N*
N*                       Vx.yy
N*
N*                           where
N*                                   V               denotes 'Version' label
N*                                   x               denotes major software version revision number
N*                                   yy              denotes minor software version revision number
N*
N*               (b) The software version label #define is formatted as follows :
N*
N*                       ver = x.yy * 100
N*
N*                           where
N*                                   ver             denotes software version number scaled as an integer value
N*                                   x.yy            denotes software version number
N*********************************************************************************************************
N*/
N
N#define  LIB_VERSION                                     124u   /* See Note #1.                                         */
N
N
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The following common software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib*.*
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                           where
N*                                   <Custom Library Directory>      directory path for custom   library      software
N*                                   <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                                   <cpu>                           directory name for specific processor (CPU)
N*                                   <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<Custom Library Directory>\uC-LIB\',
N*               '\<CPU-Compiler Directory>\' directory, & the specific CPU-compiler directory as 
N*               additional include path directories.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          STANDARD DEFINES
N*********************************************************************************************************
N*/
N
N
N#define  DEF_DISABLED                                      0
N#define  DEF_ENABLED                                       1
N
N#define  DEF_FALSE                                         0
N#define  DEF_TRUE                                          1
N
N#define  DEF_NO                                            0
N#define  DEF_YES                                           1
N
N#define  DEF_OFF                                           0
N#define  DEF_ON                                            1
N
N#define  DEF_CLR                                           0
N#define  DEF_SET                                           1
N
N#define  DEF_ACTIVE                                        0
N#define  DEF_INACTIVE                                      1
N
N#define  DEF_FAIL                                          0
N#define  DEF_OK                                            1
N
N
N                                                                /* -------------------- BIT DEFINES ------------------- */
N#define  DEF_BIT_NONE                                   0x00
N
N#define  DEF_BIT_00                                     0x01
N#define  DEF_BIT_01                                     0x02
N#define  DEF_BIT_02                                     0x04
N#define  DEF_BIT_03                                     0x08
N#define  DEF_BIT_04                                     0x10
N#define  DEF_BIT_05                                     0x20
N#define  DEF_BIT_06                                     0x40
N#define  DEF_BIT_07                                     0x80
N
N#define  DEF_BIT_08                                   0x0100
N#define  DEF_BIT_09                                   0x0200
N#define  DEF_BIT_10                                   0x0400
N#define  DEF_BIT_11                                   0x0800
N#define  DEF_BIT_12                                   0x1000
N#define  DEF_BIT_13                                   0x2000
N#define  DEF_BIT_14                                   0x4000
N#define  DEF_BIT_15                                   0x8000
N
N#define  DEF_BIT_16                               0x00010000
N#define  DEF_BIT_17                               0x00020000
N#define  DEF_BIT_18                               0x00040000
N#define  DEF_BIT_19                               0x00080000
N#define  DEF_BIT_20                               0x00100000
N#define  DEF_BIT_21                               0x00200000
N#define  DEF_BIT_22                               0x00400000
N#define  DEF_BIT_23                               0x00800000
N
N#define  DEF_BIT_24                               0x01000000
N#define  DEF_BIT_25                               0x02000000
N#define  DEF_BIT_26                               0x04000000
N#define  DEF_BIT_27                               0x08000000
N#define  DEF_BIT_28                               0x10000000
N#define  DEF_BIT_29                               0x20000000
N#define  DEF_BIT_30                               0x40000000
N#define  DEF_BIT_31                               0x80000000
N
N                                                                /* ------------------- OCTET DEFINES ------------------ */
N#define  DEF_OCTET_NBR_BITS                                8
N#define  DEF_OCTET_MASK                                 0xFF
N
N#define  DEF_NIBBLE_NBR_BITS                               4
N#define  DEF_NIBBLE_MASK                                0x0F
N
N
N/*$PAGE*/
N                                                                /* ------------------ INTEGER DEFINES ----------------- */
N#define  DEF_INT_08_NBR_BITS                               8
N#define  DEF_INT_08_MASK                                0xFF
N                                                            
N#define  DEF_INT_08U_MIN_VAL                               0u
N#define  DEF_INT_08U_MAX_VAL                             255u
N
N#define  DEF_INT_08S_MIN_VAL                            -128
N#define  DEF_INT_08S_MAX_VAL                             127
N
N#define  DEF_INT_08S_MIN_VAL_ONES_CPL                   -127
N#define  DEF_INT_08S_MAX_VAL_ONES_CPL                    127
N
N
N#define  DEF_INT_16_NBR_BITS                              16
N#define  DEF_INT_16_MASK                              0xFFFF
N                                                            
N#define  DEF_INT_16U_MIN_VAL                               0u
N#define  DEF_INT_16U_MAX_VAL                           65535u
N
N#define  DEF_INT_16S_MIN_VAL                          -32768
N#define  DEF_INT_16S_MAX_VAL                           32767
N
N#define  DEF_INT_16S_MIN_VAL_ONES_CPL                 -32767
N#define  DEF_INT_16S_MAX_VAL_ONES_CPL                  32767
N
N
N#define  DEF_INT_32_NBR_BITS                              32
N#define  DEF_INT_32_MASK                          0xFFFFFFFF
N                                                            
N#define  DEF_INT_32U_MIN_VAL                               0u
N#define  DEF_INT_32U_MAX_VAL                      4294967295u
N
N#define  DEF_INT_32S_MIN_VAL                     -2147483648
N#define  DEF_INT_32S_MAX_VAL                      2147483647
N
N#define  DEF_INT_32S_MIN_VAL_ONES_CPL            -2147483647
N#define  DEF_INT_32S_MAX_VAL_ONES_CPL             2147483647
N
N
N#define  DEF_INT_64_NBR_BITS                              64
N#define  DEF_INT_64_MASK                  0xFFFFFFFFFFFFFFFF
N                                                            
N#define  DEF_INT_64U_MIN_VAL                               0u
N#define  DEF_INT_64U_MAX_VAL            18446744073709551615u
N
N#define  DEF_INT_64S_MIN_VAL            -9223372036854775808
N#define  DEF_INT_64S_MAX_VAL             9223372036854775807
N
N#define  DEF_INT_64S_MIN_VAL_ONES_CPL   -9223372036854775807
N#define  DEF_INT_64S_MAX_VAL_ONES_CPL    9223372036854775807
N
N
N/*$PAGE*/
N                                                                /* ---------------- CPU INTEGER DEFINES --------------- */
N#define  DEF_INT_CPU_NBR_BITS                           (CPU_CFG_DATA_SIZE * DEF_OCTET_NBR_BITS)
N
N
N#if     (DEF_INT_CPU_NBR_BITS == DEF_INT_08_NBR_BITS)
X#if     ((4 * 8) == 8)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_08_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_08U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_08U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_08S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_08S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_08S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_08S_MAX_VAL_ONES_CPL
S
S
S#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_16_NBR_BITS)
X#elif   ((4 * 8) == 16)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_16_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_16U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_16U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_16S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_16S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_16S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_16S_MAX_VAL_ONES_CPL
S
S
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_32_NBR_BITS)
X#elif   ((4 * 8) == 32)
N
N#define  DEF_INT_CPU_MASK                                DEF_INT_32_MASK
N                                                    
N#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_32U_MIN_VAL
N#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_32U_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_32S_MIN_VAL
N#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_32S_MAX_VAL
N
N#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_32S_MIN_VAL_ONES_CPL
N#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_32S_MAX_VAL_ONES_CPL
N
N
N#elif   (DEF_INT_CPU_NBR_BITS == DEF_INT_64_NBR_BITS)
S
S#define  DEF_INT_CPU_MASK                                DEF_INT_64_MASK
S                                                                   
S#define  DEF_INT_CPU_U_MIN_VAL                           DEF_INT_64U_MIN_VAL
S#define  DEF_INT_CPU_U_MAX_VAL                           DEF_INT_64U_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL                           DEF_INT_64S_MIN_VAL
S#define  DEF_INT_CPU_S_MAX_VAL                           DEF_INT_64S_MAX_VAL
S
S#define  DEF_INT_CPU_S_MIN_VAL_ONES_CPL                  DEF_INT_64S_MIN_VAL_ONES_CPL
S#define  DEF_INT_CPU_S_MAX_VAL_ONES_CPL                  DEF_INT_64S_MAX_VAL_ONES_CPL
S                                                      
S
S#else
S
S#error  "CPU_CFG_DATA_SIZE  illegally #defined in 'cpu.h'      "
S#error  "                   [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N                                                                /* ------------------- TIME DEFINES ------------------- */
N#define  DEF_TIME_NBR_HR_PER_DAY                          24uL
N
N#define  DEF_TIME_NBR_MIN_PER_HR                          60uL
N#define  DEF_TIME_NBR_MIN_PER_DAY                       (DEF_TIME_NBR_MIN_PER_HR  * DEF_TIME_NBR_HR_PER_DAY)
N
N#define  DEF_TIME_NBR_SEC_PER_MIN                         60uL
N#define  DEF_TIME_NBR_SEC_PER_HR                        (DEF_TIME_NBR_SEC_PER_MIN * DEF_TIME_NBR_MIN_PER_HR)
N#define  DEF_TIME_NBR_SEC_PER_DAY                       (DEF_TIME_NBR_SEC_PER_HR  * DEF_TIME_NBR_HR_PER_DAY)
N
N#define  DEF_TIME_NBR_mS_PER_SEC                        1000uL
N#define  DEF_TIME_NBR_uS_PER_SEC                     1000000uL
N#define  DEF_TIME_NBR_nS_PER_SEC                  1000000000uL
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*
N* Note(s) : (1) All generic library error codes are #define'd in 'lib_def.h';
N*               Any module-specific error codes are #define'd in library module header files.
N*********************************************************************************************************
N*/
N
N#define  LIB_ERR_NONE                                      0
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT16U  LIB_ERR;
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             BIT MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_BIT()
N*
N* Description : Create bit mask with single, specified bit set.
N*
N* Argument(s) : bit         Bit number of bit to set.
N*
N* Return(s)   : Bit mask with single, specified bit set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT(bit)                            (1u << (bit))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_MASK()
N*
N* Description : Shift a bit mask.
N*
N* Argument(s) : bit_mask    Bit mask to shift.
N*
N*               bit_shift   Number of bit positions to left-shift bit mask.
N*
N* Return(s)   : Shifted bit mask.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_shift' values that overflow the target CPU &/or compiler environment (e.g. negative
N*                   or greater-than-CPU-data-size values) MAY generate compiler warnings &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_MASK(bit_mask, bit_shift)             ((bit_mask)       << (bit_shift))
N
N
N/*
N*********************************************************************************************************
N*                                           DEF_BIT_FIELD()
N*
N* Description : Create & shift a contiguous bit field.
N*
N* Argument(s) : bit_field   Number of contiguous bits to set in the bit field.
N*
N*               bit_shift   Number of bit positions   to left-shift bit field.
N*
N* Return(s)   : Shifted bit field.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) 'bit_field'/'bit_shift' values that overflow the target CPU &/or compiler environment 
N*                   (e.g. negative or greater-than-CPU-data-size values) MAY generate compiler warnings
N*                   &/or errors.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_FIELD(bit_field, bit_shift)         ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)   \
N                                                                                             : (DEF_BIT(bit_field) - 1)) \
N                                                                                                    << (bit_shift))
X#define  DEF_BIT_FIELD(bit_field, bit_shift)         ((((bit_field) >= DEF_INT_CPU_NBR_BITS) ? (DEF_INT_CPU_U_MAX_VAL)                                                                                                : (DEF_BIT(bit_field) - 1))                                                                                                     << (bit_shift))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_SET()
N*
N* Description : Set specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by setting specified bit(s).
N*
N*               mask        Mask of bits to set.
N*
N* Return(s)   : Modified value with specified bit(s) set.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_SET(val, mask)                       { (val) |=  (mask); }
N
N
N/*
N*********************************************************************************************************
N*                                            DEF_BIT_CLR()
N*
N* Description : Clear specified bit(s) in a value.
N*
N* Argument(s) : val         Value to modify by clearing specified bit(s).
N*
N*               mask        Mask of bits to clear.
N*
N* Return(s)   : Modified value with specified bit(s) clear.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_CLR(val, mask)                       { (val) &= ~(mask); }
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_SET()
N*
N* Description : Determine if specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set.
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     set in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET(val, mask)                   ((((val) & (mask)) == (mask)) ? (DEF_YES) : (DEF_NO ))
N
N
N/*
N*********************************************************************************************************
N*                                          DEF_BIT_IS_CLR()
N*
N* Description : Determine if specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear.
N*
N* Return(s)   : DEF_YES, if ALL specified bit(s) are     clear in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT clear in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR(val, mask)                    (((val) & (mask))            ? (DEF_NO ) : (DEF_YES))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_SET_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are set.
N*
N* Argument(s) : val         Value to check for specified bit(s) set.
N*
N*               mask        Mask of bits to check if set.
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     set in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT set in value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_SET_ANY(val, mask)                (((val) & (mask))            ? (DEF_YES) : (DEF_NO ))
N
N
N/*
N*********************************************************************************************************
N*                                        DEF_BIT_IS_CLR_ANY()
N*
N* Description : Determine if any specified bit(s) in a value are clear.
N*
N* Argument(s) : val         Value to check for specified bit(s) clear.
N*
N*               mask        Mask of bits to check if clear.
N*
N* Return(s)   : DEF_YES, if ANY specified bit(s) are     clear in value.
N*     
N*               DEF_NO,	 if ALL specified bit(s) are NOT clear in value.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_BIT_IS_CLR_ANY(val, mask)               ((((val) & (mask)) != (mask)) ? (DEF_YES) : (DEF_NO ))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            MATH MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                              DEF_MIN()
N*
N* Description : Determine the minimum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Minimum of the two values.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MIN(a, b)                                  (((a) < (b)) ? (a) : (b))
N
N
N/*
N*********************************************************************************************************
N*                                              DEF_MAX()
N*
N* Description : Determine the maximum of two values.
N*
N* Argument(s) : a           First  value.
N*
N*               b           Second value.
N*
N* Return(s)   : Maximum of the two values.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_MAX(a, b)                                  (((a) > (b)) ? (a) : (b))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              DEF_ABS()
N*
N* Description : Determine the absolute value of a value.
N*
N* Argument(s) : a           Value to calculate absolute value.
N*
N* Return(s)   : Absolute value of the value.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
N#define  DEF_ABS(a)                                     (((a) < 0) ? (-(a)) : (a))
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib def module include.                       */
N
L 61 "..\BSP\bsp.h" 2
N#include    <lib_mem.h>
L 1 "..\..\..\..\..\uC-LIB\lib_mem.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/LIB
N*                                       CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/LIB in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/LIB.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                     STANDARD MEMORY OPERATIONS
N*
N* Filename      : lib_mem.h
N* Version       : V1.25
N* Programmer(s) : ITJ
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_MEM_MODULE_PRESENT
N#define  LIB_MEM_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The following common software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib*.*
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                           where
N*                                   <Custom Library Directory>      directory path for custom   library      software
N*                                   <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                                   <cpu>                           directory name for specific processor (CPU)
N*                                   <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<Custom Library Directory>\uC-LIB\',
N*               '\<CPU-Compiler Directory>\' directory, & the specific CPU-compiler directory as
N*               additional include path directories.
N*
N*           (3) NO compiler-supplied standard library functions SHOULD be used.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N#include  <lib_def.h>
N#include  <app_cfg.h>
L 1 ".\app_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                              EXAMPLE CODE
N*
N*                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                      APPLICATION CONFIGURATION
N*
N*                                     ST Microelectronics STM32
N*                                              with the
N*                                   STM3210B-EVAL Evaluation Board
N*
N* Filename      : app_cfg.h
N* Version       : V1.10
N* Programmer(s) : BAN
N*********************************************************************************************************
N*/
N
N#ifndef  __APP_CFG_H__
N#define  __APP_CFG_H__
N
N/*
N*********************************************************************************************************
N*                                       MODULE ENABLE / DISABLE
N*********************************************************************************************************
N*/
N
N#define  APP_OS_PROBE_EN                         DEF_ENABLED
N#define  APP_PROBE_COM_EN                        DEF_ENABLED
N
N/*
N*********************************************************************************************************
N*                                              TASKS NAMES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            TASK PRIORITIES
N*********************************************************************************************************
N*/
N
N#define  APP_TASK_START_PRIO                               3
N#define  APP_TASK_KBD_PRIO                                 12
N
N#define  APP_TASK_USER_IF_PRIO                            13
N
N#define  OS_PROBE_TASK_PRIO              (OS_LOWEST_PRIO - 3)
N#define  OS_TASK_TMR_PRIO                (OS_LOWEST_PRIO - 2)
N
N/*
N*********************************************************************************************************
N*                                            TASK STACK SIZES
N*                             Size of the task stacks (# of OS_STK entries)
N*********************************************************************************************************
N*/
N
N#define  APP_TASK_START_STK_SIZE                         128
N#define  APP_TASK_KBD_STK_SIZE                           128
N
N#define  APP_TASK_USER_IF_STK_SIZE                       256
N
N#define  OS_PROBE_TASK_STK_SIZE                          128
N
N/*
N*********************************************************************************************************
N*                                                  LIB
N*********************************************************************************************************
N*/
N
N#define  uC_CFG_OPTIMIZE_ASM_EN                 DEF_ENABLED
N#define  LIB_STR_CFG_FP_EN                      DEF_DISABLED
N
N/*
N*********************************************************************************************************
N*                                                 PROBE
N*********************************************************************************************************
N*/
N
N#define  OS_PROBE_TASK                                     1    /* Task will be created for uC/Probe OS Plug-In.        */
N#define  OS_PROBE_TMR_32_BITS                              0    /* uC/Probe OS Plugin timer is a 16-bit timer.          */
N#define  OS_PROBE_TIMER_SEL                                2    /* Select timer 2.                                      */
N#define  OS_PROBE_HOOKS_EN                                 1    /* Hooks to update OS_TCB profiling members included.   */
N#define  OS_PROBE_USE_FP                                   1
N
N
N
N
N#endif
L 91 "..\..\..\..\..\uC-LIB\lib_mem.h" 2
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_MEM_MODULE
S#define  LIB_MEM_EXT
N#else
N#define  LIB_MEM_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEFAULT CONFIGURATION
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                             MEMORY LIBRARY ARGUMENT CHECK CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_ARG_CHK_EXT_EN to enable/disable the memory libray suite external
N*               argument check feature :
N*
N*               (a) When ENABLED,      arguments received from any port interface provided by the developer
N*                   or application are checked/validated.
N*
N*               (b) When DISABLED, NO  arguments received from any port interface provided by the developer
N*                   or application are checked/validated.
N*********************************************************************************************************
N*/
N                                                        /* Configure external argument check feature (see Note #1) :    */
N#ifndef  LIB_MEM_CFG_ARG_CHK_EXT_EN
N#define  LIB_MEM_CFG_ARG_CHK_EXT_EN     DEF_DISABLED
N                                                        /*   DEF_DISABLED     Argument check DISABLED                   */
N                                                        /*   DEF_ENABLED      Argument check ENABLED                    */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                      MEMORY POOL CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_MEM_CFG_POOL_EN to enable/disable memory pool functions.
N*********************************************************************************************************
N*/
N                                                        /* Configure memory pool feature (see Note #1) :                */
N#ifndef  LIB_MEM_CFG_POOL_EN
N#define  LIB_MEM_CFG_POOL_EN            DEF_DISABLED
N                                                        /*   DEF_DISABLED     Memory pool(s) DISABLED                   */
N                                                        /*   DEF_ENABLED      Memory pool(s) ENABLED                    */
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      LIBRARY MEMORY ERROR CODES
N*********************************************************************************************************
N*/
N
N#define  LIB_MEM_ERR_NONE                              10000
N#define  LIB_MEM_ERR_NULL_PTR                          10001    /* Ptr arg(s) passed NULL ptr(s).                       */
N#define  LIB_MEM_ERR_NONE_AVAIL                        10010    /* NO avail mem rsrc's.                                 */
N
N#define  LIB_MEM_ERR_INVALID_SEG_SIZE                  10100    /* Invalid mem seg size.                                */
N#define  LIB_MEM_ERR_INVALID_SEG_OVERLAP               10101    /* Invalid mem seg overlaps other mem seg(s).           */
N#define  LIB_MEM_ERR_INVALID_POOL                      10102    /* Invalid mem pool.                                    */
N#define  LIB_MEM_ERR_INVALID_ADDR                      10103    /* Invalid mem pool addr.                               */
N#define  LIB_MEM_ERR_INVALID_BLK_NBR                   10104    /* Invalid mem pool blk nbr.                            */
N#define  LIB_MEM_ERR_INVALID_BLK_SIZE                  10105    /* Invalid mem pool blk size.                           */
N#define  LIB_MEM_ERR_INVALID_BLK_IX                    10106    /* Invalid mem pool ix.                                 */
N
N#define  LIB_MEM_ERR_SEG_EMPTY                         10110    /* Mem seg  empty; i.e. NO avail mem for mem pools.     */
N#define  LIB_MEM_ERR_POOL_FULL                         10111    /* Mem pool full;  i.e. All mem blks avail in mem pool. */
N
N#define  LIB_MEM_ERR_HEAP_NOT_FOUND                    10115    /* Heap seg NOT found.                                  */
N#define  LIB_MEM_ERR_HEAP_EMPTY                        10116    /* Heap seg empty; i.e. NO avail mem in heap.           */
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                     MEMORY LIBRARY TYPE DEFINES
N*
N* Note(s) : (1) LIB_MEM_TYPE_??? #define values specifically chosen as ASCII representations of the memory
N*               library types.  Memory displays of memory library objects will display the library TYPEs
N*               with their chosen ASCII names.
N**********************************************************************************************************/
N
N                                                                /* ------------------- LIB_MEM TYPES ------------------ */
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2 == 1)
S#define  LIB_MEM_TYPE_NONE                        0x4E4F4E45    /* "NONE" in ASCII.                                     */
S#define  LIB_MEM_TYPE_HEAP                        0x48454150    /* "HEAP" in ASCII.                                     */
S#define  LIB_MEM_TYPE_POOL                        0x504F4F4C    /* "POOL" in ASCII.                                     */
S
N#else
N
N#if     (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_32)
X#if     (4   == 4)
N#define  LIB_MEM_TYPE_NONE                        0x454E4F4E    /* "NONE" in ASCII.                                     */
N#define  LIB_MEM_TYPE_HEAP                        0x50414548    /* "HEAP" in ASCII.                                     */
N#define  LIB_MEM_TYPE_POOL                        0x4C4F4F50    /* "POOL" in ASCII.                                     */
N
N#elif   (CPU_CFG_DATA_SIZE   == CPU_WORD_SIZE_16)
S#define  LIB_MEM_TYPE_NONE                        0x4F4E454E    /* "NONE" in ASCII.                                     */
S#define  LIB_MEM_TYPE_HEAP                        0x45485041    /* "HEAP" in ASCII.                                     */
S#define  LIB_MEM_TYPE_POOL                        0x4F504C4F    /* "POOL" in ASCII.                                     */
S
S#else                                                           /* Dflt CPU_WORD_SIZE_08.                               */
S#define  LIB_MEM_TYPE_NONE                        0x4E4F4E45    /* "NONE" in ASCII.                                     */
S#define  LIB_MEM_TYPE_HEAP                        0x48454150    /* "HEAP" in ASCII.                                     */
S#define  LIB_MEM_TYPE_POOL                        0x504F4F4C    /* "POOL" in ASCII.                                     */
S
N#endif
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                            LIB MEM TYPE
N*
N* Note(s) : (1) 'LIB_MEM_TYPE' declared as 'CPU_INT32U' & all 'LIB_MEM_TYPE's #define'd with large, non-trivial
N*               values to trap & discard invalid/corrupted library memory objects based on 'LIB_MEM_TYPE'.
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT32U  LIB_MEM_TYPE;
N
N
N/*
N*********************************************************************************************************
N*                                      MEMORY POOL TABLE IX TYPE
N*
N* Note(s) : (1) MEM_POOL_IX_NONE  SHOULD be #define'd based on 'MEM_POOL_IX' data type declared.
N*********************************************************************************************************
N*/
N
Ntypedef  CPU_INT16U   MEM_POOL_IX;
N
N#define  MEM_POOL_IX_NONE                DEF_INT_16U_MAX_VAL    /* Define as max unsigned val (see Note #1).            */
N#define  MEM_POOL_IX_MIN                                   1
N#define  MEM_POOL_IX_MAX               (MEM_POOL_IX_NONE - 1)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        MEMORY POOL DATA TYPES
N*
N*                                                                      MEMORY SEGMENT
N*                                                                     ----------------
N*                                            MEMORY POOL'S            |              | <----
N*                                             POINTERS TO             |    MEMORY    |     |
N*                    MEM_POOL                MEMORY BLOCKS            |    BLOCKS    |     |
N*               |----------------|            |---------|             |   --------   |     |
N*               |        O------------------> |    O--------------------> |      |   |     |
N*               |----------------|            |---------|             |   |      |   |     |
N*               | Pool Addr Ptrs |            |    O-------------     |   --------   |     |
N*               | Pool Size      |            |---------|       |     |              |     |
N*               |----------------|            |         |       |     |   --------   |     |
N*               |    Blk Size    |            |         |       --------> |      |   |     |
N*               |    Blk Nbr     |            |         |             |   |      |   |     |
N*               |    Blk Ix      |            |    .    |             |   --------   |     |
N*               |----------------|            |    .    |             |              |     |
N*               |----------------|            |    .    |             |      .       |     |
N*               |        O-----------------   |         |             |      .       |     |
N*               |----------------|        |   |         |             |      .       |     |
N*               |        O------------    |   |         |             |              |     |
N*               |----------------|   |    |   |---------|             |   --------   |     |
N*               |  Seg Size Tot  |   |    |   |    O--------------------> |      |   |     |
N*               |  Seg Size Rem  |   |    |   |---------|             |   |      |   |     |
N*               |----------------|   |    |   |         |             |   --------   |     |
N*               | Seg List Ptrs  |   |    |   |---------|             |              |     |
N*               |----------------|   |    |                           | ------------ |     |
N*                                    |    |                           |              | <--------
N*                                    |    |                           |              |     |   |
N*                                    |    |                           |              |     |   |
N*                                    |    |                           |              |     |   |
N*                                    |    |                           |              |     |   |
N*                                    |    |                           |              |     |   |
N*                                    |    |                           ----------------     |   |
N*                                    |    |                                                |   |
N*                                    |    --------------------------------------------------   |
N*                                    |                                                         |
N*                                    -----------------------------------------------------------
N*
N*********************************************************************************************************
N*/
N
Ntypedef  struct  mem_pool  MEM_POOL;
N
N                                                                /* --------------------- MEM POOL --------------------- */
Nstruct  mem_pool {
N    LIB_MEM_TYPE    Type;                                       /* Pool type : LIB_TYPE_POOL or LIB_TYPE_HEAP.          */
N
N    MEM_POOL       *SegPrevPtr;                                 /* Ptr to PREV mem seg.                                 */
N    MEM_POOL       *SegNextPtr;                                 /* Ptr to NEXT mem seg.                                 */
N    MEM_POOL       *PoolPrevPtr;                                /* Ptr to PREV mem pool.                                */
N    MEM_POOL       *PoolNextPtr;                                /* Ptr to NEXT mem pool.                                */
N
N    void           *PoolAddrStart;                              /* Ptr   to start of mem seg for mem pool blks.         */
N    void           *PoolAddrEnd;                                /* Ptr   to end   of mem seg for mem pool blks.         */
N    void          **PoolPtrs;                                   /* Ptr   to mem pool's array of blk ptrs.               */
N    MEM_POOL_IX     BlkIx;                                      /* Ix  into mem pool's array of blk ptrs.               */
N    CPU_SIZE_T      PoolSize;                                   /* Size  of mem pool        (in octets).                */
N    CPU_SIZE_T      BlkNbr;                                     /* Nbr   of mem pool   blks.                            */
N    CPU_SIZE_T      BlkSize;                                    /* Size  of mem pool   blks (in octets).                */
N    CPU_SIZE_T      BlkAlign;                                   /* Align of mem pool   blks (in octets).                */
N
N                                                                /* --------------------- MEM SEG ---------------------- */
N    void           *SegAddr;                                    /* Ptr      to mem seg's base/start addr.               */
N    void           *SegAddrNextAvail;                           /* Ptr      to mem seg's next avail addr.               */
N    CPU_SIZE_T      SegSizeTot;                                 /* Tot size of mem seg (in octets).                     */
N    CPU_SIZE_T      SegSizeRem;                                 /* Rem size of mem seg (in octets).                     */
N};
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      MEMORY DATA VALUE MACRO'S
N*
N* Note(s) : (1) (a) Some variables & variable buffers to pass & receive data values MUST start on appropriate
N*                   CPU word-aligned addresses.  This is required because most word-aligned processors are more
N*                   efficient & may even REQUIRE that multi-octet words start on CPU word-aligned addresses.
N*
N*                   (1) For 16-bit word-aligned processors, this means that
N*
N*                           all 16- & 32-bit words MUST start on addresses that are multiples of 2 octets
N*
N*                   (2) For 32-bit word-aligned processors, this means that
N*
N*                           all 16-bit       words MUST start on addresses that are multiples of 2 octets
N*                           all 32-bit       words MUST start on addresses that are multiples of 4 octets
N*
N*               (b) However, some data values macro's appropriately access data values from any CPU addresses,
N*                   word-aligned or not.  Thus for processors that require data word alignment, data words can
N*                   be accessed to/from any CPU address, word-aligned or not, without generating data-word-
N*                   alignment exceptions/faults.
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          MEM_VAL_GET_xxx()
N*
N* Description : Decode data values from any CPU memory address.
N*
N* Argument(s) : addr        Lowest CPU memory address of data value to decode (see Notes #2 & #3a).
N*
N* Return(s)   : Decoded data value from CPU memory address (see Notes #1 & #3b).
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Decode data values based on the values' data-word order in CPU memory :
N*
N*                       MEM_VAL_GET_xxx_BIG()           Decode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_GET_xxx_LITTLE()        Decode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_GET_xxx()               Decode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) (a) MEM_VAL_GET_xxx() macro's decode data values without regard to CPU word-aligned addresses.
N*                       Thus for processors that require data word alignment, data words can be decoded from any
N*                       CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*
N*                   (b) However, any variable to receive the returned data value MUST start on an appropriate CPU
N*                       word-aligned address.
N*
N*                   See also 'MEMORY DATA VALUE MACRO'S  Note #1'.
N*
N*               (4) MEM_VAL_COPY_GET_xxx() macro's are more efficient than MEM_VAL_GET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #4'.
N*
N*               (5) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N
N#define  MEM_VAL_GET_INT08U_BIG(addr)             (((CPU_INT08U)(*(((CPU_INT08U *)(addr)) + 0))) << (0 * DEF_OCTET_NBR_BITS))
N
N#define  MEM_VAL_GET_INT16U_BIG(addr)            ((((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (1 * DEF_OCTET_NBR_BITS)) + \
N                                                  (((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (0 * DEF_OCTET_NBR_BITS)))
X#define  MEM_VAL_GET_INT16U_BIG(addr)            ((((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (1 * DEF_OCTET_NBR_BITS)) +                                                   (((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (0 * DEF_OCTET_NBR_BITS)))
N
N#define  MEM_VAL_GET_INT32U_BIG(addr)            ((((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (3 * DEF_OCTET_NBR_BITS)) + \
N                                                  (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (2 * DEF_OCTET_NBR_BITS)) + \
N                                                  (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (1 * DEF_OCTET_NBR_BITS)) + \
N                                                  (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (0 * DEF_OCTET_NBR_BITS)))
X#define  MEM_VAL_GET_INT32U_BIG(addr)            ((((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (3 * DEF_OCTET_NBR_BITS)) +                                                   (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (2 * DEF_OCTET_NBR_BITS)) +                                                   (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (1 * DEF_OCTET_NBR_BITS)) +                                                   (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (0 * DEF_OCTET_NBR_BITS)))
N
N
N
N#define  MEM_VAL_GET_INT08U_LITTLE(addr)          (((CPU_INT08U)(*(((CPU_INT08U *)(addr)) + 0))) << (0 * DEF_OCTET_NBR_BITS))
N
N#define  MEM_VAL_GET_INT16U_LITTLE(addr)         ((((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (0 * DEF_OCTET_NBR_BITS)) + \
N                                                  (((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (1 * DEF_OCTET_NBR_BITS)))
X#define  MEM_VAL_GET_INT16U_LITTLE(addr)         ((((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 0))) << (0 * DEF_OCTET_NBR_BITS)) +                                                   (((CPU_INT16U)(*(((CPU_INT08U *)(addr)) + 1))) << (1 * DEF_OCTET_NBR_BITS)))
N
N#define  MEM_VAL_GET_INT32U_LITTLE(addr)         ((((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (0 * DEF_OCTET_NBR_BITS)) + \
N                                                  (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (1 * DEF_OCTET_NBR_BITS)) + \
N                                                  (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (2 * DEF_OCTET_NBR_BITS)) + \
N                                                  (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (3 * DEF_OCTET_NBR_BITS)))
X#define  MEM_VAL_GET_INT32U_LITTLE(addr)         ((((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 0))) << (0 * DEF_OCTET_NBR_BITS)) +                                                   (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 1))) << (1 * DEF_OCTET_NBR_BITS)) +                                                   (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 2))) << (2 * DEF_OCTET_NBR_BITS)) +                                                   (((CPU_INT32U)(*(((CPU_INT08U *)(addr)) + 3))) << (3 * DEF_OCTET_NBR_BITS)))
N
N
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2 == 1)
S
S#define  MEM_VAL_GET_INT08U(addr)                               MEM_VAL_GET_INT08U_BIG(addr)
S#define  MEM_VAL_GET_INT16U(addr)                               MEM_VAL_GET_INT16U_BIG(addr)
S#define  MEM_VAL_GET_INT32U(addr)                               MEM_VAL_GET_INT32U_BIG(addr)
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2 == 2)
N
N#define  MEM_VAL_GET_INT08U(addr)                               MEM_VAL_GET_INT08U_LITTLE(addr)
N#define  MEM_VAL_GET_INT16U(addr)                               MEM_VAL_GET_INT16U_LITTLE(addr)
N#define  MEM_VAL_GET_INT32U(addr)                               MEM_VAL_GET_INT32U_LITTLE(addr)
N
N#else                                                                           /* See Note #5.                         */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          MEM_VAL_SET_xxx()
N*
N* Description : Encode data values to any CPU memory address.
N*
N* Argument(s) : addr        Lowest CPU memory address to encode data value (see Notes #2 & #3a).
N*
N*               val         Data value to encode (see Notes #1 & #3b).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Encode data values into CPU memory based on the values' data-word order :
N*
N*                       MEM_VAL_SET_xxx_BIG()           Encode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_SET_xxx_LITTLE()        Encode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_SET_xxx()               Encode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) (a) MEM_VAL_SET_xxx() macro's encode data values without regard to CPU word-aligned addresses.
N*                       Thus for processors that require data word alignment, data words can be encoded to any
N*                       CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*
N*                   (b) However, 'val' data value to encode MUST start on an appropriate CPU word-aligned address.
N*
N*                   See also 'MEMORY DATA VALUE MACRO'S  Note #1'.
N*
N*               (4) MEM_VAL_COPY_SET_xxx() macro's are more efficient than MEM_VAL_SET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_COPY_SET_xxx()  Note #4'.
N*
N*               (5) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N
N#define  MEM_VAL_SET_INT08U_BIG(addr, val)                    { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT08U)(val)) &       0xFF) >> (0 * DEF_OCTET_NBR_BITS))); }
N
N#define  MEM_VAL_SET_INT16U_BIG(addr, val)                    { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) &     0xFF00) >> (1 * DEF_OCTET_NBR_BITS))); \
N                                                                (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) &     0x00FF) >> (0 * DEF_OCTET_NBR_BITS))); }
X#define  MEM_VAL_SET_INT16U_BIG(addr, val)                    { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) &     0xFF00) >> (1 * DEF_OCTET_NBR_BITS)));                                                                 (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) &     0x00FF) >> (0 * DEF_OCTET_NBR_BITS))); }
N
N#define  MEM_VAL_SET_INT32U_BIG(addr, val)                    { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0xFF000000) >> (3 * DEF_OCTET_NBR_BITS))); \
N                                                                (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x00FF0000) >> (2 * DEF_OCTET_NBR_BITS))); \
N                                                                (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x0000FF00) >> (1 * DEF_OCTET_NBR_BITS))); \
N                                                                (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x000000FF) >> (0 * DEF_OCTET_NBR_BITS))); }
X#define  MEM_VAL_SET_INT32U_BIG(addr, val)                    { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0xFF000000) >> (3 * DEF_OCTET_NBR_BITS)));                                                                 (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x00FF0000) >> (2 * DEF_OCTET_NBR_BITS)));                                                                 (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x0000FF00) >> (1 * DEF_OCTET_NBR_BITS)));                                                                 (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x000000FF) >> (0 * DEF_OCTET_NBR_BITS))); }
N
N
N
N#define  MEM_VAL_SET_INT08U_LITTLE(addr, val)                 { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT08U)(val)) &       0xFF) >> (0 * DEF_OCTET_NBR_BITS))); }
N
N#define  MEM_VAL_SET_INT16U_LITTLE(addr, val)                 { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) &     0x00FF) >> (0 * DEF_OCTET_NBR_BITS))); \
N                                                                (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) &     0xFF00) >> (1 * DEF_OCTET_NBR_BITS))); }
X#define  MEM_VAL_SET_INT16U_LITTLE(addr, val)                 { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT16U)(val)) &     0x00FF) >> (0 * DEF_OCTET_NBR_BITS)));                                                                 (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT16U)(val)) &     0xFF00) >> (1 * DEF_OCTET_NBR_BITS))); }
N
N#define  MEM_VAL_SET_INT32U_LITTLE(addr, val)                 { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x000000FF) >> (0 * DEF_OCTET_NBR_BITS))); \
N                                                                (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x0000FF00) >> (1 * DEF_OCTET_NBR_BITS))); \
N                                                                (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x00FF0000) >> (2 * DEF_OCTET_NBR_BITS))); \
N                                                                (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0xFF000000) >> (3 * DEF_OCTET_NBR_BITS))); }
X#define  MEM_VAL_SET_INT32U_LITTLE(addr, val)                 { (*(((CPU_INT08U *)(addr)) + 0)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x000000FF) >> (0 * DEF_OCTET_NBR_BITS)));                                                                 (*(((CPU_INT08U *)(addr)) + 1)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x0000FF00) >> (1 * DEF_OCTET_NBR_BITS)));                                                                 (*(((CPU_INT08U *)(addr)) + 2)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0x00FF0000) >> (2 * DEF_OCTET_NBR_BITS)));                                                                 (*(((CPU_INT08U *)(addr)) + 3)) = ((CPU_INT08U)((((CPU_INT32U)(val)) & 0xFF000000) >> (3 * DEF_OCTET_NBR_BITS))); }
N
N
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2 == 1)
S
S#define  MEM_VAL_SET_INT08U(addr, val)                          MEM_VAL_SET_INT08U_BIG(addr, val)
S#define  MEM_VAL_SET_INT16U(addr, val)                          MEM_VAL_SET_INT16U_BIG(addr, val)
S#define  MEM_VAL_SET_INT32U(addr, val)                          MEM_VAL_SET_INT32U_BIG(addr, val)
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2 == 2)
N
N#define  MEM_VAL_SET_INT08U(addr, val)                          MEM_VAL_SET_INT08U_LITTLE(addr, val)
N#define  MEM_VAL_SET_INT16U(addr, val)                          MEM_VAL_SET_INT16U_LITTLE(addr, val)
N#define  MEM_VAL_SET_INT32U(addr, val)                          MEM_VAL_SET_INT32U_LITTLE(addr, val)
N
N#else                                                                           /* See Note #5.                         */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       MEM_VAL_COPY_GET_xxx()
N*
N* Description : Copy & decode data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/decode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/decode
N*                                   (see Notes #2 & #3).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/decode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_GET_xxx_BIG()      Decode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_xxx_LITTLE()   Decode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_GET_xxx()          Decode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) MEM_VAL_COPY_GET_xxx() macro's copy/decode data values without regard to CPU word-aligned
N*                   addresses.  Thus for processors that require data word alignment, data words can be copied/
N*                   decoded to/from any CPU address, word-aligned or not, without generating data-word-alignment
N*                   exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_GET_xxx() macro's are more efficient than MEM_VAL_GET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_GET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, memory data value gets/sets are
N*                   inverse operations.
N*
N*                   See also 'MEM_VAL_COPY_SET_xxx()  Note #5'.
N*
N*               (6) The 'CPU_CFG_ENDIAN_TYPE' pre-processor 'else'-conditional code SHOULD never be compiled/
N*                   linked since each 'cpu.h' SHOULD ensure that the CPU data-word-memory order configuration
N*                   constant (CPU_CFG_ENDIAN_TYPE) is configured with an appropriate data-word-memory order
N*                   value (see 'cpu.h  CPU WORD CONFIGURATION  Note #2').  The 'else'-conditional code is
N*                   included as an extra precaution in case 'cpu.h' is incorrectly configured.
N*********************************************************************************************************
N*/
N/*$PAGE*/
N
N#if     (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_BIG)
X#if     (2 == 1)
S
S
S#define  MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
S
S#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
S                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); }
X#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); }
S
S#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
S                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
S                                                                (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); }
X#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); }
S
S
S
S#define  MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
S
S#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
X#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
S
S#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3)); \
S                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
S                                                                (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
S                                                                (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
X#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
S
S
S
S#define  MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)
S#define  MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)
S#define  MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)
S
S
S
S
N#elif   (CPU_CFG_ENDIAN_TYPE == CPU_ENDIAN_TYPE_LITTLE)
X#elif   (2 == 2)
N
N
N#define  MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
N
N#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
X#define  MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
N
N#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
X#define  MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)     { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 3));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
N
N
N
N#define  MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
N
N#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); }
X#define  MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); }
N
N#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); }
X#define  MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)  { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); }
N
N
N
N#define  MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)
N
N
N
N
N#else                                                                           /* See Note #6.                         */
S
S#error  "CPU_CFG_ENDIAN_TYPE  illegally #defined in 'cpu.h'      "
S#error  "                     [See 'cpu.h  CONFIGURATION ERRORS']"
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                       MEM_VAL_COPY_SET_xxx()
N*
N* Description : Copy & encode data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy/encode source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy/encode
N*                                   (see Notes #2 & #3).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) Copy/encode data values based on the values' data-word order :
N*
N*                       MEM_VAL_COPY_SET_xxx_BIG()      Encode big-   endian data values -- data words' most
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_xxx_LITTLE()   Encode little-endian data values -- data words' least
N*                                                           significant octet @ lowest memory address
N*                       MEM_VAL_COPY_SET_xxx()          Encode data values using CPU's native or configured
N*                                                           data-word order
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) MEM_VAL_COPY_SET_xxx() macro's copy/encode data values without regard to CPU word-aligned
N*                   addresses.  Thus for processors that require data word alignment, data words can be copied/
N*                   encoded to/from any CPU address, word-aligned or not, without generating data-word-alignment
N*                   exceptions/faults.
N*
N*               (4) MEM_VAL_COPY_SET_xxx() macro's are more efficient than MEM_VAL_SET_xxx() macro's & are
N*                   also independent of CPU data-word-alignment & SHOULD be used whenever possible.
N*
N*                   See also 'MEM_VAL_SET_xxx()  Note #4'.
N*
N*               (5) Since octet-order copy/conversion are inverse operations, memory data value gets/sets
N*                   are inverse operations.
N*
N*                   See also 'MEM_VAL_COPY_GET_xxx()  Note #5'.
N*********************************************************************************************************
N*/
N
N                                                                                /* See Note #5.                         */
N#define  MEM_VAL_COPY_SET_INT08U_BIG(addr_dest, addr_src)       MEM_VAL_COPY_GET_INT08U_BIG(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U_BIG(addr_dest, addr_src)       MEM_VAL_COPY_GET_INT16U_BIG(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U_BIG(addr_dest, addr_src)       MEM_VAL_COPY_GET_INT32U_BIG(addr_dest, addr_src)
N
N#define  MEM_VAL_COPY_SET_INT08U_LITTLE(addr_dest, addr_src)    MEM_VAL_COPY_GET_INT08U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U_LITTLE(addr_dest, addr_src)    MEM_VAL_COPY_GET_INT16U_LITTLE(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U_LITTLE(addr_dest, addr_src)    MEM_VAL_COPY_GET_INT32U_LITTLE(addr_dest, addr_src)
N
N
N#define  MEM_VAL_COPY_SET_INT08U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT08U(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT16U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT16U(addr_dest, addr_src)
N#define  MEM_VAL_COPY_SET_INT32U(addr_dest, addr_src)           MEM_VAL_COPY_GET_INT32U(addr_dest, addr_src)
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         MEM_VAL_COPY_xxx()
N*
N* Description : Copy data values from any CPU memory address to any CPU memory address.
N*
N* Argument(s) : addr_dest       Lowest CPU memory address to copy source address's data value
N*                                   (see Notes #2 & #3).
N*
N*               addr_src        Lowest CPU memory address of data value to copy
N*                                   (see Notes #2 & #3).
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : (1) MEM_VAL_COPY_xxx() macro's copy data values based on CPU's native data-word order.
N*
N*                   See also 'cpu.h  CPU WORD CONFIGURATION  Note #2'.
N*
N*               (2) CPU memory addresses/pointers NOT checked for NULL.
N*
N*               (3) MEM_VAL_COPY_xxx() macro's copy data values without regard to CPU word-aligned addresses.
N*                   Thus for processors that require data word alignment, data words can be copied to/from any
N*                   CPU address, word-aligned or not, without generating data-word-alignment exceptions/faults.
N*********************************************************************************************************
N*/
N
N#define  MEM_VAL_COPY_08(addr_dest, addr_src)                 { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); }
N
N#define  MEM_VAL_COPY_16(addr_dest, addr_src)                 { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); }
X#define  MEM_VAL_COPY_16(addr_dest, addr_src)                 { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); }
N
N#define  MEM_VAL_COPY_32(addr_dest, addr_src)                 { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2)); \
N                                                                (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); }
X#define  MEM_VAL_COPY_32(addr_dest, addr_src)                 { (*(((CPU_INT08U *)(addr_dest)) + 0)) = (*(((CPU_INT08U *)(addr_src)) + 0));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 1)) = (*(((CPU_INT08U *)(addr_src)) + 1));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 2)) = (*(((CPU_INT08U *)(addr_src)) + 2));                                                                 (*(((CPU_INT08U *)(addr_dest)) + 3)) = (*(((CPU_INT08U *)(addr_src)) + 3)); }
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid          Mem_Init       (void);
N
N                                                                        /* -------------- MEM API  FNCTS -------------- */
Nvoid          Mem_Clr        (void        *pmem,
N                              CPU_SIZE_T   size);
N
Nvoid          Mem_Set        (void        *pmem,
N                              CPU_INT08U   data_val,
N                              CPU_SIZE_T   size);
N
Nvoid          Mem_Copy       (void        *pdest,
N                              void        *psrc,
N                              CPU_SIZE_T   size);
N
NCPU_BOOLEAN   Mem_Cmp        (void        *p1_mem,
N                              void        *p2_mem,
N                              CPU_SIZE_T   size);
N
N
N
N#if (LIB_MEM_CFG_POOL_EN == DEF_ENABLED)                                /* -------------- MEM POOL FNCTS -------------- */
X#if (0 == 1)                                 
S
Svoid          Mem_PoolCreate (MEM_POOL    *pmem_pool,
S                              void        *pmem_base_addr,
S                              CPU_SIZE_T   mem_size,
S                              CPU_SIZE_T   blk_nbr,
S                              CPU_SIZE_T   blk_size,
S                              CPU_SIZE_T   blk_align,
S                              CPU_SIZE_T  *poctets_reqd,
S                              LIB_ERR     *perr);
S
Svoid         *Mem_PoolBlkGet (MEM_POOL    *pmem_pool,
S                              CPU_SIZE_T   size,
S                              LIB_ERR     *perr);
S
Svoid          Mem_PoolBlkFree(MEM_POOL    *pmem_pool,
S                              void        *pmem_blk,
S                              LIB_ERR     *perr);
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_MEM_CFG_ARG_CHK_EXT_EN
S#error  "LIB_MEM_CFG_ARG_CHK_EXT_EN        not #define'd in 'app_cfg.h'"
S#error  "                            [MUST be  DEF_DISABLED]           "
S#error  "                            [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_MEM_CFG_ARG_CHK_EXT_EN != DEF_DISABLED) && \
S        (LIB_MEM_CFG_ARG_CHK_EXT_EN != DEF_ENABLED ))
X#elif  ((0 != 0) &&         (0 != 1 ))
S#error  "LIB_MEM_CFG_ARG_CHK_EXT_EN  illegally #define'd in 'app_cfg.h'"
S#error  "                            [MUST be  DEF_DISABLED]           "
S#error  "                            [     ||  DEF_ENABLED ]           "
N#endif
N
N
N
N#ifndef  LIB_MEM_CFG_POOL_EN
S#error  "LIB_MEM_CFG_POOL_EN               not #define'd in 'app_cfg.h'"
S#error  "                            [MUST be  DEF_DISABLED]           "
S#error  "                            [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_MEM_CFG_POOL_EN != DEF_DISABLED) && \
S        (LIB_MEM_CFG_POOL_EN != DEF_ENABLED ))
X#elif  ((0 != 0) &&         (0 != 1 ))
S#error  "LIB_MEM_CFG_POOL_EN         illegally #define'd in 'app_cfg.h'"
S#error  "                            [MUST be  DEF_DISABLED]           "
S#error  "                            [     ||  DEF_ENABLED ]           "
S
S
S#elif   (LIB_MEM_CFG_POOL_EN == DEF_ENABLED)
X#elif   (0 == 1)
S
S#ifndef  LIB_MEM_CFG_HEAP_SIZE
S#error  "LIB_MEM_CFG_HEAP_SIZE             not #define'd in 'app_cfg.h'"
S#error  "                            [MUST be  > 0]                    "
S
S#elif   (LIB_MEM_CFG_HEAP_SIZE < 1)
S
S#error  "LIB_MEM_CFG_HEAP_SIZE       illegally #define'd in 'app_cfg.h'"
S#error  "                            [MUST be  > 0]                    "
S#endif
S
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib mem module include.                       */
N
L 62 "..\BSP\bsp.h" 2
N#include    <lib_str.h>
L 1 "..\..\..\..\..\uC-LIB\lib_str.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/LIB
N*                                       CUSTOM LIBRARY MODULES
N*
N*                          (c) Copyright 2004-2008; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*
N*               uC/LIB is provided in source form for FREE evaluation, for educational
N*               use or peaceful research.  If you plan on using uC/LIB in a commercial
N*               product you need to contact Micrium to properly license its use in your
N*               product.  We provide ALL the source code for your convenience and to
N*               help you experience uC/LIB.  The fact that the source code is provided
N*               does NOT mean that you can use it without paying a licensing fee.
N*
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                       ASCII STRING MANAGEMENT
N*
N* Filename      : lib_str.h
N* Version       : V1.25
N* Programmer(s) : ITJ
N*                 JDH
N*********************************************************************************************************
N* Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
N*
N*                     (a) ALL standard library functions are implemented in the custom library modules :
N*
N*                         (1) \<Custom Library Directory>\lib*.*
N*
N*                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
N*
N*                               where
N*                                       <Custom Library Directory>      directory path for custom library software
N*                                       <cpu>                           directory name for specific processor (CPU)
N*                                       <compiler>                      directory name for specific compiler
N*
N*                     (b) Product-specific library functions are implemented in individual products.
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                               MODULE
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_MODULE_PRESENT
N#define  LIB_STR_MODULE_PRESENT
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            INCLUDE FILES
N*
N* Note(s) : (1) The following common software files are located in the following directories :
N*
N*               (a) \<Custom Library Directory>\lib*.*
N*
N*               (b) (1) \<CPU-Compiler Directory>\cpu_def.h
N*
N*                   (2) \<CPU-Compiler Directory>\<cpu>\<compiler>\cpu*.*
N*
N*                           where
N*                                   <Custom Library Directory>      directory path for custom   library      software
N*                                   <CPU-Compiler Directory>        directory path for common   CPU-compiler software
N*                                   <cpu>                           directory name for specific processor (CPU)
N*                                   <compiler>                      directory name for specific compiler
N*
N*           (2) Compiler MUST be configured to include the '\<Custom Library Directory>\uC-LIB\',
N*               '\<CPU-Compiler Directory>\' directory, & the specific CPU-compiler directory as
N*               additional include path directories.
N*
N*           (3) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard library header files SHOULD be removed once all custom 
N*               library functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'STANDARD LIBRARY MACRO'S  Note #1'.
N*********************************************************************************************************
N*/
N
N#include  <cpu.h>
N#include  <lib_def.h>
N#include  <app_cfg.h>
N
N                                                                /* See Note #3.                                         */
N#include  <stdlib.h>
L 1 "C:\Program Files\0Software\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 100 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <ctype.h>
L 1 "C:\Program Files\0Software\Keil_v5\ARM\ARMCC\Bin\..\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
S#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE_DEF static inline
S#elif defined(_USE_STATIC_INLINE)
X#elif 0L
S#define _ARMABI_INLINE_DEF static __inline
N#else
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __attribute__((const)) unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
X__inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 101 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <errno.h>
L 1 "C:\Program Files\0Software\Keil_v5\ARM\ARMCC\Bin\..\include\errno.h" 1
N/* errno.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.3 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 1 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __errno_h
N#define __errno_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N  #ifndef __ERRNO_DECLS
N  #define __ERRNO_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
Nextern _ARMABI_PURE volatile int *__aeabi_errno_addr(void);
Xextern __declspec(__nothrow) __attribute__((const)) volatile int *__aeabi_errno_addr(void);
N
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __ERRNO_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __ERRNO_NO_EXPORTS
S      using ::std::__aeabi_errno_addr;
S    #endif /* __ERRNO_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#define errno (*__CLIBNS __aeabi_errno_addr())
N/*
N * expands to a modifiable lvalue that has type volatile int, the value of
N * which is set to a positive error code by several library functions. It is
N * initialised to zero at program startup, but is never set to zero by any
N * library function. The value of errno may be set to nonzero by a library
N * function call whether or not there is an error, provided the use of errno
N * is not documented in the description of the function in the Standard.
N */
N
N
N/*
N * Error numbers defined in the C standard need the ABI portability
N * mechanism.
N */
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N/* The ABI-defined signal numbers (EDOM, ERANGE and EILSEQ) are
N * defined differently depending on ABI conformance level. */
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_EDOM;
Sextern const int __aeabi_ERANGE;
Sextern const int __aeabi_EILSEQ;
S#define EDOM (__aeabi_EDOM)
S#define ERANGE (__aeabi_ERANGE)
S#define EILSEQ (__aeabi_EILSEQ)
N#else
N
N#define EDOM    1
N/*
N * If a mathematical function suffers a domain error (an input
N * argument is outside the domain over which the mathematical
N * function is defined, e.g. log of a negative number) the integer
N * expression errno acquires the value of the macro EDOM.
N *
N * EDOM is also returned by ftell, fgetpos and fsetpos when they
N * fail.
N */
N
N#define ERANGE 2
N/*
N * If a mathematical function suffers a range error (the result of
N * the function is too large or too small to be accurately
N * represented in the output floating-point format), the integer
N * expression errno acquires the value of the macro ERANGE.
N *
N * ERANGE is used by functions in math.h and complex.h, and also by
N * the strto* and wcsto* family of decimal-to-binary conversion
N * functions (both floating and integer) and by floating-point
N * conversions in scanf.
N */
N
N#define EILSEQ  4
N/*
N * EILSEQ is generated by the restartable multi-byte character
N * processing routines to indicate an encoding error: that is, it is
N * generated by mbrtowc, wcrtomb, mbsrtowcs and wcsrtombs, but not
N * by mbtowc, wctomb, mbstowcs or wcsrtombs.
N *
N * It is also generated by the wide-character stdio functions:
N * fputwc, putwc, putwchar, fputws, fgetwc, getwc, getwchar, fgetws.
N */
N
N#endif /* end of conditional definition of ABI-defined signals */
N
N#define ESIGNUM 3
N/*
N * ESIGNUM is generated by signal() if the user attempts to change
N * the handling of a nonexistent signal. ESIGNUM is not part of the
N * ANSI C standard.
N */
N
N#define EINVAL  5
N#define ENOMEM  6
N/*
N * EINVAL and ENOMEM can be generated by posix_memalign().
N */
N
N#endif
N
N/* end of errno.h */
N
L 102 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <limits.h>
L 1 "C:\Program Files\0Software\Keil_v5\ARM\ARMCC\Bin\..\include\limits.h" 1
N/* limits.h: ANSI 'C' (X3J11 Oct 88) library header, section 2.2.4.2 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991-1997 ARM Limited. All rights reserved         */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __limits_h
N#define __limits_h
N#define __ARMCLIB_VERSION 5060037
N
N#define CHAR_BIT 8
N    /* max number of bits for smallest object that is not a bit-field (byte) */
N#define SCHAR_MIN (-128)
N    /* mimimum value for an object of type signed char */
N#define SCHAR_MAX 127
N    /* maximum value for an object of type signed char */
N#define UCHAR_MAX 255
N    /* maximum value for an object of type unsigned char */
N#ifdef __FEATURE_SIGNED_CHAR
S  #define CHAR_MIN (-128)
S      /* minimum value for an object of type char */
S  #define CHAR_MAX 127
S      /* maximum value for an object of type char */
N#else
N  #define CHAR_MIN 0
N      /* minimum value for an object of type char */
N  #define CHAR_MAX 255
N      /* maximum value for an object of type char */
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
Sextern const int __aeabi_MB_LEN_MAX;
S#define MB_LEN_MAX (__aeabi_MB_LEN_MAX)
N#else
N#define MB_LEN_MAX 6
N#endif
N    /* maximum number of bytes in a multibyte character, */
N    /* for any supported locale */
N
N#define SHRT_MIN  (-0x8000)
N    /* minimum value for an object of type short int */
N#define SHRT_MAX  0x7fff
N    /* maximum value for an object of type short int */
N#define USHRT_MAX 65535
N    /* maximum value for an object of type unsigned short int */
N#define INT_MIN   (~0x7fffffff)  /* -2147483648 and 0x80000000 are unsigned */
N    /* minimum value for an object of type int */
N#define INT_MAX   0x7fffffff
N    /* maximum value for an object of type int */
N#define UINT_MAX  0xffffffffU
N    /* maximum value for an object of type unsigned int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MIN  (~0x7fffffffffffffffL)
N#else
N  #define LONG_MIN  (~0x7fffffffL)
N#endif
N    /* minimum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define LONG_MAX  0x7fffffffffffffffL
N#else
N  #define LONG_MAX  0x7fffffffL
N#endif
N    /* maximum value for an object of type long int */
N#if __sizeof_long == 8
X#if 4 == 8
S  #define ULONG_MAX 0xffffffffffffffffUL
N#else
N  #define ULONG_MAX 0xffffffffUL
N#endif
N    /* maximum value for an object of type unsigned long int */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N  #define LLONG_MIN  (~0x7fffffffffffffffLL)
N      /* minimum value for an object of type long long int */
N  #define LLONG_MAX    0x7fffffffffffffffLL
N      /* maximum value for an object of type long long int */
N  #define ULLONG_MAX   0xffffffffffffffffULL
N      /* maximum value for an object of type unsigned long int */
N#endif
N
N#endif
N
N/* end of limits.h */
N
L 103 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N#include  <stdio.h>
L 1 "C:\Program Files\0Software\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060037
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 104 "..\..\..\..\..\uC-LIB\lib_str.h" 2
N
N
N/*
N*********************************************************************************************************
N*                                               EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   LIB_STR_MODULE
S#define  LIB_STR_EXT
N#else
N#define  LIB_STR_EXT  extern
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        DEFAULT CONFIGURATION
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      MEMORY POOL CONFIGURATION
N*
N* Note(s) : (1) Configure LIB_STR_CFG_FP_EN to enable/disable floating point string function(s).
N*********************************************************************************************************
N*/
N                                                                /* Configure floating point feature(s) [see Note #1] :  */
N#ifndef  LIB_STR_CFG_FP_EN
S#define  LIB_STR_CFG_FP_EN                      DEF_DISABLED
S                                                                /*   DEF_DISABLED     Floating point functions DISABLED */
S                                                                /*   DEF_ENABLED      Floating point functions ENABLED  */
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                               DEFINES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                             DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                              MACRO'S
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                      STANDARD LIBRARY MACRO'S
N*
N* Note(s) : (1) NO compiler-supplied standard library functions SHOULD be used.
N*
N*               #### The reference to standard memory functions SHOULD be removed once all custom library 
N*               functions are implemented WITHOUT reference to ANY standard library function(s).
N*
N*               See also 'INCLUDE FILES  Note #3'.
N*********************************************************************************************************
N*/
N
N                                                                /* See Note #1.                                         */
N#define  Str_IsPrint(a)                 isprint(a)
N
N#define  Str_ToLong(a, b, c)            strtol((char *)a, (char **)b, c)
N#define  Str_FmtPrint                   snprintf
N#define  Str_FmtScan                    sscanf
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
NCPU_SIZE_T   Str_Len      (CPU_CHAR     *pstr);
N
N
N
NCPU_CHAR    *Str_Copy     (CPU_CHAR     *pdest,
N                           CPU_CHAR     *psrc);
N
NCPU_CHAR    *Str_Copy_N   (CPU_CHAR     *pdest,
N                           CPU_CHAR     *psrc,
N                           CPU_SIZE_T    len_max);
N
N
NCPU_CHAR    *Str_Cat      (CPU_CHAR     *pdest,
N                           CPU_CHAR     *pstr_cat);
N
NCPU_CHAR    *Str_Cat_N    (CPU_CHAR     *pdest,
N                           CPU_CHAR     *pstr_cat,
N                           CPU_SIZE_T    len_max);
N
N
N
NCPU_INT16S   Str_Cmp      (CPU_CHAR     *p1_str,
N                           CPU_CHAR     *p2_str);
N
NCPU_INT16S   Str_Cmp_N    (CPU_CHAR     *p1_str,
N                           CPU_CHAR     *p2_str,
N                           CPU_SIZE_T    len_max);
N
N
NCPU_CHAR    *Str_Char     (CPU_CHAR     *pstr,
N                           CPU_CHAR      srch_char);
N
NCPU_CHAR    *Str_Char_N   (CPU_CHAR     *pstr,
N                           CPU_SIZE_T    len_max,
N                           CPU_CHAR      srch_char);
N
NCPU_CHAR    *Str_Char_Last(CPU_CHAR     *pstr,
N                           CPU_CHAR      srch_char);
N
N
NCPU_CHAR    *Str_Str      (CPU_CHAR     *pstr,
N                           CPU_CHAR     *srch_str);
N
N
N
N#if (LIB_STR_CFG_FP_EN  == DEF_ENABLED)
X#if (0  == 1)
SCPU_CHAR    *Str_FmtNbr_32(CPU_FP32      nbr,
S                           CPU_INT08U    nbr_dig,
S                           CPU_INT08U    nbr_dp,
S                           CPU_BOOLEAN   lead_zeros,
S                           CPU_BOOLEAN   nul,
S                           CPU_CHAR     *pstr_fmt);
N#endif
N
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                        CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#ifndef  LIB_STR_CFG_FP_EN
S#error  "LIB_STR_CFG_FP_EN        not #define'd in 'app_cfg.h'"
S#error  "                   [MUST be  DEF_DISABLED]           "
S#error  "                   [     ||  DEF_ENABLED ]           "
S
S#elif  ((LIB_STR_CFG_FP_EN != DEF_DISABLED) && \
S        (LIB_STR_CFG_FP_EN != DEF_ENABLED ))
X#elif  ((0 != 0) &&         (0 != 1 ))
S#error  "LIB_STR_CFG_FP_EN  illegally #define'd in 'app_cfg.h'"
S#error  "                   [MUST be  DEF_DISABLED]           "
S#error  "                   [     ||  DEF_ENABLED ]           "
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                             MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of lib str module include.                       */
N
L 63 "..\BSP\bsp.h" 2
N
N#include    <stm32f10x_conf.h>
L 1 ".\stm32f10x_conf.h" 1
N/******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
N* File Name          : stm32f10x_conf.h
N* Author             : MCD Application Team
N* Date First Issued  : 05/21/2007
N* Description        : Library configuration file.
N********************************************************************************
N* History:
N* 05/21/2007: V0.1
N********************************************************************************
N* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CONF_H
N#define __STM32F10x_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_type.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_type.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the common data types used for the
N*                      STM32F10x firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TYPE_H
N#define __STM32F10x_TYPE_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
Ntypedef signed long  s32;
Ntypedef signed short s16;
Ntypedef signed char  s8;
N
Ntypedef signed long  const sc32;  /* Read Only */
Ntypedef signed short const sc16;  /* Read Only */
Ntypedef signed char  const sc8;   /* Read Only */
N
Ntypedef volatile signed long  vs32;
Ntypedef volatile signed short vs16;
Ntypedef volatile signed char  vs8;
N
Ntypedef volatile signed long  const vsc32;  /* Read Only */
Ntypedef volatile signed short const vsc16;  /* Read Only */
Ntypedef volatile signed char  const vsc8;   /* Read Only */
N
Ntypedef unsigned long  u32;
Ntypedef unsigned short u16;
Ntypedef unsigned char  u8;
N
Ntypedef unsigned long  const uc32;  /* Read Only */
Ntypedef unsigned short const uc16;  /* Read Only */
Ntypedef unsigned char  const uc8;   /* Read Only */
N
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
Ntypedef volatile unsigned char  vu8;
N
Ntypedef volatile unsigned long  const vuc32;  /* Read Only */
Ntypedef volatile unsigned short const vuc16;  /* Read Only */
Ntypedef volatile unsigned char  const vuc8;   /* Read Only */
N
Ntypedef enum {FALSE = 0, TRUE = !FALSE} bool;
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N#define U8_MAX     ((u8)255)
N#define S8_MAX     ((s8)127)
N#define S8_MIN     ((s8)-128)
N#define U16_MAX    ((u16)65535u)
N#define S16_MAX    ((s16)32767)
N#define S16_MIN    ((s16)-32768)
N#define U32_MAX    ((u32)4294967295uL)
N#define S32_MAX    ((s32)2147483647)
N#define S32_MIN    ((s32)-2147483648)
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_TYPE_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 24 ".\stm32f10x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
N   the "assert" macro in the firmware library code (see "Exported macro" section below) */
N//#define DEBUG
N
N/* Comment the line below to disable the specific peripheral inclusion */
N/************************************* ADC ************************************/
N#define _ADC
N#define _ADC1
N#define _ADC2
N
N/************************************* BKP ************************************/
N#define _BKP
N
N/************************************* CAN ************************************/
N//#define _CAN
N
N/************************************* DMA ************************************/
N//#define _DMA
N//#define _DMA_Channel1
N//#define _DMA_Channel2
N//#define _DMA_Channel3
N//#define _DMA_Channel4
N//#define _DMA_Channel5
N//#define _DMA_Channel6
N//#define _DMA_Channel7
N
N/************************************* EXTI ***********************************/
N#define _EXTI
N
N/************************************* FLASH and Option Bytes *****************/
N#define _FLASH
N/* Uncomment the line below to enable FLASH program/erase/protections functions,
N   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
N   are enabled */
N//#define _FLASH_PROG
N
N/************************************* GPIO ***********************************/
N#define _GPIO
N#define _GPIOA
N#define _GPIOB
N#define _GPIOC
N#define _GPIOD
N#define _GPIOE
N#define _AFIO
N
N/************************************* I2C ************************************/
N#define _I2C
N#define _I2C1
N//#define _I2C2
N
N/************************************* IWDG ***********************************/
N//#define _IWDG
N
N/************************************* NVIC ***********************************/
N#define _NVIC
N
N/************************************* PWR ************************************/
N#define _PWR
N
N/************************************* RCC ************************************/
N#define _RCC
N
N/************************************* RTC ************************************/
N#define _RTC
N
N/************************************* SPI ************************************/
N#define _SPI
N#define _SPI1
N#define _SPI2
N
N/************************************* SysTick ********************************/
N#define _SysTick
N
N/************************************* TIM1 ***********************************/
N#define _TIM1
N
N/************************************* TIM ************************************/
N#define _TIM
N#define _TIM2
N//#define _TIM3
N#define _TIM4
N
N/************************************* USART **********************************/
N#define _USART
N#define _USART1
N#define _USART2
N#define _USART3
N
N/************************************* WWDG ***********************************/
N//#define _WWDG
N
N/* In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application */
N#define HSE_Value    ((u32)8000000) /* Value of the External oscillator in Hz*/
N
N/* Exported macro ------------------------------------------------------------*/
N#undef assert
N#ifdef  DEBUG
S/*******************************************************************************
S* Macro Name     : assert
S* Description    : The assert macro is used for function's parameters check.
S*                  It is used only if the library is compiled in DEBUG mode.
S* Input          : - expr: If expr is false, it calls assert_failed function
S*                    which reports the name of the source file and the source
S*                    line number of the call that failed.
S*                    If expr is true, it returns no value.
S* Return         : None
S*******************************************************************************/
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(u8* file, u32 line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* DEBUG */
N
N#endif /* __STM32F10x_CONF_H */
N
N/******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
L 65 "..\BSP\bsp.h" 2
N#include    <stm32f10x_lib.h>
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_lib.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file includes the peripherals header files in the
N*                      user application.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_LIB_H
N#define __STM32F10x_LIB_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_map.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_map.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the peripheral register's definitions
N*                      and memory mapping.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_MAP_H
N#define __STM32F10x_MAP_H
N
N#ifndef EXT
N  #define EXT extern
N#endif /* EXT */
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_conf.h"
N#include "stm32f10x_type.h"
N#include "cortexm3_macro.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\cortexm3_macro.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : cortexm3_macro.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : Header file for cortexm3_macro.s.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CORTEXM3_MACRO_H
N#define __CORTEXM3_MACRO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid __WFI(void);
Nvoid __WFE(void);
Nvoid __SEV(void);
Nvoid __ISB(void);
Nvoid __DSB(void);
Nvoid __DMB(void);
Nvoid __SVC(void);
Nu32 __MRS_CONTROL(void);
Nvoid __MSR_CONTROL(u32 Control);
Nu32 __MRS_PSP(void);
Nvoid __MSR_PSP(u32 TopOfProcessStack);
Nu32 __MRS_MSP(void);
Nvoid __MSR_MSP(u32 TopOfMainStack);
Nvoid __RESETPRIMASK(void);
Nvoid __SETPRIMASK(void);
Nu32 __READ_PRIMASK(void);
Nvoid __RESETFAULTMASK(void);
Nvoid __SETFAULTMASK(void);
Nu32 __READ_FAULTMASK(void);
Nvoid __BASEPRICONFIG(u32 NewPriority);
Nu32 __GetBASEPRI(void);
Nu16 __REV_HalfWord(u16 Data);
Nu32 __REV_Word(u32 Data);
N
N#endif /* __CORTEXM3_MACRO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 31 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_map.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/******************************************************************************/
N/*                         Peripheral registers structures                    */
N/******************************************************************************/
N
N/*------------------------ Analog to Digital Converter -----------------------*/
Ntypedef struct
N{
N  vu32 SR;
N  vu32 CR1;
N  vu32 CR2;
N  vu32 SMPR1;
N  vu32 SMPR2;
N  vu32 JOFR1;
N  vu32 JOFR2;
N  vu32 JOFR3;
N  vu32 JOFR4;
N  vu32 HTR;
N  vu32 LTR;
N  vu32 SQR1;
N  vu32 SQR2;
N  vu32 SQR3;
N  vu32 JSQR;
N  vu32 JDR1;
N  vu32 JDR2;
N  vu32 JDR3;
N  vu32 JDR4;
N  vu32 DR;
N} ADC_TypeDef;
N
N/*------------------------ Backup Registers ----------------------------------*/
Ntypedef struct
N{
N  u32  RESERVED0;
N  vu16 DR1;
N  u16  RESERVED1;
N  vu16 DR2;
N  u16  RESERVED2;
N  vu16 DR3;
N  u16  RESERVED3;
N  vu16 DR4;
N  u16  RESERVED4;
N  vu16 DR5;
N  u16  RESERVED5;
N  vu16 DR6;
N  u16  RESERVED6;
N  vu16 DR7;
N  u16  RESERVED7;
N  vu16 DR8;
N  u16  RESERVED8;
N  vu16 DR9;
N  u16  RESERVED9;
N  vu16 DR10;
N  u16  RESERVED10; 
N  vu16 RTCCR;
N  u16  RESERVED11;
N  vu16 CR;
N  u16  RESERVED12;
N  vu16 CSR;
N  u16  RESERVED13[5];
N  vu16 DR11;
N  u16  RESERVED14;
N  vu16 DR12;
N  u16  RESERVED15;
N  vu16 DR13;
N  u16  RESERVED16;
N  vu16 DR14;
N  u16  RESERVED17;
N  vu16 DR15;
N  u16  RESERVED18;
N  vu16 DR16;
N  u16  RESERVED19;
N  vu16 DR17;
N  u16  RESERVED20;
N  vu16 DR18;
N  u16  RESERVED21;
N  vu16 DR19;
N  u16  RESERVED22;
N  vu16 DR20;
N  u16  RESERVED23;
N  vu16 DR21;
N  u16  RESERVED24;
N  vu16 DR22;
N  u16  RESERVED25;
N  vu16 DR23;
N  u16  RESERVED26;
N  vu16 DR24;
N  u16  RESERVED27;
N  vu16 DR25;
N  u16  RESERVED28;
N  vu16 DR26;
N  u16  RESERVED29;
N  vu16 DR27;
N  u16  RESERVED30;
N  vu16 DR28;
N  u16  RESERVED31;
N  vu16 DR29;
N  u16  RESERVED32;
N  vu16 DR30;
N  u16  RESERVED33; 
N  vu16 DR31;
N  u16  RESERVED34;
N  vu16 DR32;
N  u16  RESERVED35;
N  vu16 DR33;
N  u16  RESERVED36;
N  vu16 DR34;
N  u16  RESERVED37;
N  vu16 DR35;
N  u16  RESERVED38;
N  vu16 DR36;
N  u16  RESERVED39;
N  vu16 DR37;
N  u16  RESERVED40;
N  vu16 DR38;
N  u16  RESERVED41;
N  vu16 DR39;
N  u16  RESERVED42;
N  vu16 DR40;
N  u16  RESERVED43;
N  vu16 DR41;
N  u16  RESERVED44;
N  vu16 DR42;
N  u16  RESERVED45;    
N} BKP_TypeDef;
N
N/*------------------------ Controller Area Network ---------------------------*/
Ntypedef struct
N{
N  vu32 TIR;
N  vu32 TDTR;
N  vu32 TDLR;
N  vu32 TDHR;
N} CAN_TxMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 RIR;
N  vu32 RDTR;
N  vu32 RDLR;
N  vu32 RDHR;
N} CAN_FIFOMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 FR1;
N  vu32 FR2;
N} CAN_FilterRegister_TypeDef;
N
Ntypedef struct
N{
N  vu32 MCR;
N  vu32 MSR;
N  vu32 TSR;
N  vu32 RF0R;
N  vu32 RF1R;
N  vu32 IER;
N  vu32 ESR;
N  vu32 BTR;
N  u32  RESERVED0[88];
N  CAN_TxMailBox_TypeDef sTxMailBox[3];
N  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
N  u32  RESERVED1[12];
N  vu32 FMR;
N  vu32 FM1R;
N  u32  RESERVED2;
N  vu32 FS1R;
N  u32  RESERVED3;
N  vu32 FFA1R;
N  u32  RESERVED4;
N  vu32 FA1R;
N  u32  RESERVED5[8];
N  CAN_FilterRegister_TypeDef sFilterRegister[14];
N} CAN_TypeDef;
N
N/*------------------------ CRC calculation unit ------------------------------*/
Ntypedef struct
N{
N  vu32 DR;
N  vu8  IDR;
N  u8   RESERVED0;
N  u16  RESERVED1;
N  vu32 CR;
N} CRC_TypeDef;
N
N
N/*------------------------ Digital to Analog Converter -----------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 SWTRIGR;
N  vu32 DHR12R1;
N  vu32 DHR12L1;
N  vu32 DHR8R1;
N  vu32 DHR12R2;
N  vu32 DHR12L2;
N  vu32 DHR8R2;
N  vu32 DHR12RD;
N  vu32 DHR12LD;
N  vu32 DHR8RD;
N  vu32 DOR1;
N  vu32 DOR2;
N} DAC_TypeDef;
N
N/*------------------------ Debug MCU -----------------------------------------*/
Ntypedef struct
N{
N  vu32 IDCODE;
N  vu32 CR;	
N}DBGMCU_TypeDef;
N
N/*------------------------ DMA Controller ------------------------------------*/
Ntypedef struct
N{
N  vu32 CCR;
N  vu32 CNDTR;
N  vu32 CPAR;
N  vu32 CMAR;
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  vu32 ISR;
N  vu32 IFCR;
N} DMA_TypeDef;
N
N/*------------------------ External Interrupt/Event Controller ---------------*/
Ntypedef struct
N{
N  vu32 IMR;
N  vu32 EMR;
N  vu32 RTSR;
N  vu32 FTSR;
N  vu32 SWIER;
N  vu32 PR;
N} EXTI_TypeDef;
N
N/*------------------------ FLASH and Option Bytes Registers ------------------*/
Ntypedef struct
N{
N  vu32 ACR;
N  vu32 KEYR;
N  vu32 OPTKEYR;
N  vu32 SR;
N  vu32 CR;
N  vu32 AR;
N  vu32 RESERVED;
N  vu32 OBR;
N  vu32 WRPR;
N} FLASH_TypeDef;
N
Ntypedef struct
N{
N  vu16 RDP;
N  vu16 USER;
N  vu16 Data0;
N  vu16 Data1;
N  vu16 WRP0;
N  vu16 WRP1;
N  vu16 WRP2;
N  vu16 WRP3;
N} OB_TypeDef;
N
N/*------------------------ Flexible Static Memory Controller -----------------*/
Ntypedef struct
N{
N  vu32 BTCR[8];   
N} FSMC_Bank1_TypeDef; 
N
Ntypedef struct
N{
N  vu32 BWTR[7];
N} FSMC_Bank1E_TypeDef;
N
Ntypedef struct
N{
N  vu32 PCR2;
N  vu32 SR2;
N  vu32 PMEM2;
N  vu32 PATT2;
N  u32  RESERVED0;   
N  vu32 ECCR2; 
N} FSMC_Bank2_TypeDef;  
N
Ntypedef struct
N{
N  vu32 PCR3;
N  vu32 SR3;
N  vu32 PMEM3;
N  vu32 PATT3;
N  u32  RESERVED0;   
N  vu32 ECCR3; 
N} FSMC_Bank3_TypeDef; 
N
Ntypedef struct
N{
N  vu32 PCR4;
N  vu32 SR4;
N  vu32 PMEM4;
N  vu32 PATT4;
N  vu32 PIO4; 
N} FSMC_Bank4_TypeDef; 
N
N/*------------------------ General Purpose and Alternate Function IO ---------*/
Ntypedef struct
N{
N  vu32 CRL;
N  vu32 CRH;
N  vu32 IDR;
N  vu32 ODR;
N  vu32 BSRR;
N  vu32 BRR;
N  vu32 LCKR;
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  vu32 EVCR;
N  vu32 MAPR;
N  vu32 EXTICR[4];
N} AFIO_TypeDef;
N
N/*------------------------ Inter-integrated Circuit Interface ----------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 OAR1;
N  u16  RESERVED2;
N  vu16 OAR2;
N  u16  RESERVED3;
N  vu16 DR;
N  u16  RESERVED4;
N  vu16 SR1;
N  u16  RESERVED5;
N  vu16 SR2;
N  u16  RESERVED6;
N  vu16 CCR;
N  u16  RESERVED7;
N  vu16 TRISE;
N  u16  RESERVED8;
N} I2C_TypeDef;
N
N/*------------------------ Independent WATCHDOG ------------------------------*/
Ntypedef struct
N{
N  vu32 KR;
N  vu32 PR;
N  vu32 RLR;
N  vu32 SR;
N} IWDG_TypeDef;
N
N/*------------------------ Nested Vectored Interrupt Controller --------------*/
Ntypedef struct
N{
N  vu32 ISER[2];
N  u32  RESERVED0[30];
N  vu32 ICER[2];
N  u32  RSERVED1[30];
N  vu32 ISPR[2];
N  u32  RESERVED2[30];
N  vu32 ICPR[2];
N  u32  RESERVED3[30];
N  vu32 IABR[2];
N  u32  RESERVED4[62];
N  vu32 IPR[15];
N} NVIC_TypeDef;
N
Ntypedef struct
N{
N  vuc32 CPUID;
N  vu32 ICSR;
N  vu32 VTOR;
N  vu32 AIRCR;
N  vu32 SCR;
N  vu32 CCR;
N  vu32 SHPR[3];
N  vu32 SHCSR;
N  vu32 CFSR;
N  vu32 HFSR;
N  vu32 DFSR;
N  vu32 MMFAR;
N  vu32 BFAR;
N  vu32 AFSR;
N} SCB_TypeDef;
N
N/*------------------------ Power Control -------------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CSR;
N} PWR_TypeDef;
N
N/*------------------------ Reset and Clock Control ---------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFGR;
N  vu32 CIR;
N  vu32 APB2RSTR;
N  vu32 APB1RSTR;
N  vu32 AHBENR;
N  vu32 APB2ENR;
N  vu32 APB1ENR;
N  vu32 BDCR;
N  vu32 CSR;
N} RCC_TypeDef;
N
N/*------------------------ Real-Time Clock -----------------------------------*/
Ntypedef struct
N{
N  vu16 CRH;
N  u16  RESERVED0;
N  vu16 CRL;
N  u16  RESERVED1;
N  vu16 PRLH;
N  u16  RESERVED2;
N  vu16 PRLL;
N  u16  RESERVED3;
N  vu16 DIVH;
N  u16  RESERVED4;
N  vu16 DIVL;
N  u16  RESERVED5;
N  vu16 CNTH;
N  u16  RESERVED6;
N  vu16 CNTL;
N  u16  RESERVED7;
N  vu16 ALRH;
N  u16  RESERVED8;
N  vu16 ALRL;
N  u16  RESERVED9;
N} RTC_TypeDef;
N
N/*------------------------ SD host Interface ---------------------------------*/
Ntypedef struct
N{
N  vu32 POWER;
N  vu32 CLKCR;
N  vu32 ARG;
N  vu32 CMD;
N  vuc32 RESPCMD;
N  vuc32 RESP1;
N  vuc32 RESP2;
N  vuc32 RESP3;
N  vuc32 RESP4;
N  vu32 DTIMER;
N  vu32 DLEN;
N  vu32 DCTRL;
N  vuc32 DCOUNT;
N  vuc32 STA;
N  vu32 ICR;
N  vu32 MASK;
N  u32  RESERVED0[2];
N  vuc32 FIFOCNT;
N  u32  RESERVED1[13];
N  vu32 FIFO;
N} SDIO_TypeDef;
N
N/*------------------------ Serial Peripheral Interface -----------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SR;
N  u16  RESERVED2;
N  vu16 DR;
N  u16  RESERVED3;
N  vu16 CRCPR;
N  u16  RESERVED4;
N  vu16 RXCRCR;
N  u16  RESERVED5;
N  vu16 TXCRCR;
N  u16  RESERVED6;
N  vu16 I2SCFGR;
N  u16  RESERVED7;
N  vu16 I2SPR;
N  u16  RESERVED8;  
N} SPI_TypeDef;
N
N/*------------------------ SystemTick ----------------------------------------*/
Ntypedef struct
N{
N  vu32 CTRL;
N  vu32 LOAD;
N  vu32 VAL;
N  vuc32 CALIB;
N} SysTick_TypeDef;
N
N/*------------------------ TIM -----------------------------------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SMCR;
N  u16  RESERVED2;
N  vu16 DIER;
N  u16  RESERVED3;
N  vu16 SR;
N  u16  RESERVED4;
N  vu16 EGR;
N  u16  RESERVED5;
N  vu16 CCMR1;
N  u16  RESERVED6;
N  vu16 CCMR2;
N  u16  RESERVED7;
N  vu16 CCER;
N  u16  RESERVED8;
N  vu16 CNT;
N  u16  RESERVED9;
N  vu16 PSC;
N  u16  RESERVED10;
N  vu16 ARR;
N  u16  RESERVED11;
N  vu16 RCR;
N  u16  RESERVED12;
N  vu16 CCR1;
N  u16  RESERVED13;
N  vu16 CCR2;
N  u16  RESERVED14;
N  vu16 CCR3;
N  u16  RESERVED15;
N  vu16 CCR4;
N  u16  RESERVED16;
N  vu16 BDTR;
N  u16  RESERVED17;
N  vu16 DCR;
N  u16  RESERVED18;
N  vu16 DMAR;
N  u16  RESERVED19;
N} TIM_TypeDef;
N
N/*----------------- Universal Synchronous Asynchronous Receiver Transmitter --*/
Ntypedef struct
N{
N  vu16 SR;
N  u16  RESERVED0;
N  vu16 DR;
N  u16  RESERVED1;
N  vu16 BRR;
N  u16  RESERVED2;
N  vu16 CR1;
N  u16  RESERVED3;
N  vu16 CR2;
N  u16  RESERVED4;
N  vu16 CR3;
N  u16  RESERVED5;
N  vu16 GTPR;
N  u16  RESERVED6;
N} USART_TypeDef;
N
N/*------------------------ Window WATCHDOG -----------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFR;
N  vu32 SR;
N} WWDG_TypeDef;
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Peripheral and SRAM base address in the alias region */
N#define PERIPH_BB_BASE        ((u32)0x42000000)
N#define SRAM_BB_BASE          ((u32)0x22000000)
N
N/* Peripheral and SRAM base address in the bit-band region */
N#define SRAM_BASE             ((u32)0x20000000)
N#define PERIPH_BASE           ((u32)0x40000000)
N
N/* FSMC registers base address */
N#define FSMC_R_BASE           ((u32)0xA0000000)
N
N/* Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN_BASE              (APB1PERIPH_BASE + 0x6400)
N#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N
N#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
N#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
N#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
N#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
N#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
N#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
N
N#define SDIO_BASE             (PERIPH_BASE + 0x18000)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N
N/* Flash registers base address */
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000)
N/* Flash Option Bytes base address */
N#define OB_BASE               ((u32)0x1FFFF800)
N
N/* FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE          ((u32)0xE0042000)
N
N/* System Control Space memory map */
N#define SCS_BASE              ((u32)0xE000E000)
N
N#define SysTick_BASE          (SCS_BASE + 0x0010)
N#define NVIC_BASE             (SCS_BASE + 0x0100)
N#define SCB_BASE              (SCS_BASE + 0x0D00)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/*------------------------ Non Debug Mode ------------------------------------*/
N#ifndef DEBUG
N#ifdef _TIM2
N  #define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#endif /*_TIM2 */
N
N#ifdef _TIM3
S  #define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#endif /*_TIM3 */
N
N#ifdef _TIM4
N  #define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#endif /*_TIM4 */
N
N#ifdef _TIM5
S  #define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#endif /*_TIM5 */
N
N#ifdef _TIM6
S  #define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#endif /*_TIM6 */
N
N#ifdef _TIM7
S  #define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#endif /*_TIM7 */
N
N#ifdef _RTC
N  #define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#endif /*_RTC */
N
N#ifdef _WWDG
S  #define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#endif /*_WWDG */
N
N#ifdef _IWDG
S  #define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#endif /*_IWDG */
N
N#ifdef _SPI2
N  #define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#endif /*_SPI2 */
N
N#ifdef _SPI3
S  #define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#endif /*_SPI3 */
N
N#ifdef _USART2
N  #define USART2              ((USART_TypeDef *) USART2_BASE)
N#endif /*_USART2 */
N
N#ifdef _USART3
N  #define USART3              ((USART_TypeDef *) USART3_BASE)
N#endif /*_USART3 */
N
N#ifdef _UART4
S  #define UART4              ((USART_TypeDef *) UART4_BASE)
N#endif /*_UART4 */
N
N#ifdef _UART5
S  #define UART5              ((USART_TypeDef *) UART5_BASE)
N#endif /*_USART5 */
N
N#ifdef _I2C1
N  #define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#endif /*_I2C1 */
N
N#ifdef _I2C2
S  #define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#endif /*_I2C2 */
N
N#ifdef _CAN
S  #define CAN                 ((CAN_TypeDef *) CAN_BASE)
N#endif /*_CAN */
N
N#ifdef _BKP
N  #define BKP                 ((BKP_TypeDef *) BKP_BASE)
N#endif /*_BKP */
N
N#ifdef _PWR
N  #define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#endif /*_PWR */
N
N#ifdef _DAC
S  #define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#endif /*_DAC */
N
N#ifdef _AFIO
N  #define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
N#endif /*_AFIO */
N
N#ifdef _EXTI
N  #define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#endif /*_EXTI */
N
N#ifdef _GPIOA
N  #define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#endif /*_GPIOA */
N
N#ifdef _GPIOB
N  #define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#endif /*_GPIOB */
N
N#ifdef _GPIOC
N  #define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#endif /*_GPIOC */
N
N#ifdef _GPIOD
N  #define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#endif /*_GPIOD */
N
N#ifdef _GPIOE
N  #define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#endif /*_GPIOE */
N
N#ifdef _GPIOF
S  #define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#endif /*_GPIOF */
N
N#ifdef _GPIOG
S  #define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#endif /*_GPIOG */
N
N#ifdef _ADC1
N  #define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#endif /*_ADC1 */
N
N#ifdef _ADC2
N  #define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#endif /*_ADC2 */
N
N#ifdef _TIM1
N  #define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#endif /*_TIM1 */
N
N#ifdef _SPI1
N  #define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#endif /*_SPI1 */
N
N#ifdef _TIM8
S  #define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#endif /*_TIM8 */
N
N#ifdef _USART1
N  #define USART1              ((USART_TypeDef *) USART1_BASE)
N#endif /*_USART1 */
N
N#ifdef _ADC3
S  #define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#endif /*_ADC3 */
N
N#ifdef _SDIO
S  #define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#endif /*_SDIO */
N
N#ifdef _DMA
S  #define DMA1                ((DMA_TypeDef *) DMA1_BASE)
S  #define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#endif /*_DMA */
N
N#ifdef _DMA1_Channel1
S  #define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#endif /*_DMA1_Channel1 */
N
N#ifdef _DMA1_Channel2
S  #define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#endif /*_DMA1_Channel2 */
N
N#ifdef _DMA1_Channel3
S  #define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#endif /*_DMA1_Channel3 */
N
N#ifdef _DMA1_Channel4
S  #define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#endif /*_DMA1_Channel4 */
N
N#ifdef _DMA1_Channel5
S  #define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#endif /*_DMA1_Channel5 */
N
N#ifdef _DMA1_Channel6
S  #define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#endif /*_DMA1_Channel6 */
N
N#ifdef _DMA1_Channel7
S  #define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#endif /*_DMA1_Channel7 */
N
N#ifdef _DMA2_Channel1
S  #define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#endif /*_DMA2_Channel1 */
N
N#ifdef _DMA2_Channel2
S  #define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#endif /*_DMA2_Channel2 */
N
N#ifdef _DMA2_Channel3
S  #define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#endif /*_DMA2_Channel3 */
N
N#ifdef _DMA2_Channel4
S  #define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#endif /*_DMA2_Channel4 */
N
N#ifdef _DMA2_Channel5
S  #define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#endif /*_DMA2_Channel5 */
N
N#ifdef _RCC
N  #define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#endif /*_RCC */
N
N#ifdef _CRC
S  #define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#endif /*_CRC */
N
N#ifdef _FLASH
N  #define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N  #define OB                  ((OB_TypeDef *) OB_BASE) 
N#endif /*_FLASH */
N
N#ifdef _FSMC
S  #define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
S  #define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
S  #define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
S  #define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
S  #define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#endif /*_FSMC */
N
N#ifdef _DBGMCU
S  #define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#endif /*_DBGMCU */
N
N#ifdef _SysTick
N  #define SysTick             ((SysTick_TypeDef *) SysTick_BASE)
N#endif /*_SysTick */
N
N#ifdef _NVIC
N  #define NVIC                ((NVIC_TypeDef *) NVIC_BASE)
N  #define SCB                 ((SCB_TypeDef *) SCB_BASE)  
N#endif /*_NVIC */
N
N/*------------------------ Debug Mode ----------------------------------------*/
N#else   /* DEBUG */
S#ifdef _TIM2
S  EXT TIM_TypeDef             *TIM2;
S#endif /*_TIM2 */
S
S#ifdef _TIM3
S  EXT TIM_TypeDef             *TIM3;
S#endif /*_TIM3 */
S
S#ifdef _TIM4
S  EXT TIM_TypeDef             *TIM4;
S#endif /*_TIM4 */
S
S#ifdef _TIM5
S  EXT TIM_TypeDef             *TIM5;
S#endif /*_TIM5 */
S
S#ifdef _TIM6
S  EXT TIM_TypeDef             *TIM6;
S#endif /*_TIM6 */
S
S#ifdef _TIM7
S  EXT TIM_TypeDef             *TIM7;
S#endif /*_TIM7 */
S
S#ifdef _RTC
S  EXT RTC_TypeDef             *RTC;
S#endif /*_RTC */
S
S#ifdef _WWDG
S  EXT WWDG_TypeDef            *WWDG;
S#endif /*_WWDG */
S
S#ifdef _IWDG
S  EXT IWDG_TypeDef            *IWDG;
S#endif /*_IWDG */
S
S#ifdef _SPI2
S  EXT SPI_TypeDef             *SPI2;
S#endif /*_SPI2 */
S
S#ifdef _SPI3
S  EXT SPI_TypeDef             *SPI3;
S#endif /*_SPI3 */
S
S#ifdef _USART2
S  EXT USART_TypeDef           *USART2;
S#endif /*_USART2 */
S
S#ifdef _USART3
S  EXT USART_TypeDef           *USART3;
S#endif /*_USART3 */
S
S#ifdef _UART4
S  EXT USART_TypeDef           *UART4;
S#endif /*_UART4 */
S
S#ifdef _UART5
S  EXT USART_TypeDef           *UART5;
S#endif /*_UART5 */
S
S#ifdef _I2C1
S  EXT I2C_TypeDef             *I2C1;
S#endif /*_I2C1 */
S
S#ifdef _I2C2
S  EXT I2C_TypeDef             *I2C2;
S#endif /*_I2C2 */
S
S#ifdef _CAN
S  EXT CAN_TypeDef             *CAN;
S#endif /*_CAN */
S
S#ifdef _BKP
S  EXT BKP_TypeDef             *BKP;
S#endif /*_BKP */
S
S#ifdef _PWR
S  EXT PWR_TypeDef             *PWR;
S#endif /*_PWR */
S
S#ifdef _DAC
S  EXT DAC_TypeDef             *DAC;
S#endif /*_DAC */
S
S#ifdef _AFIO
S  EXT AFIO_TypeDef            *AFIO;
S#endif /*_AFIO */
S
S#ifdef _EXTI
S  EXT EXTI_TypeDef            *EXTI;
S#endif /*_EXTI */
S
S#ifdef _GPIOA
S  EXT GPIO_TypeDef            *GPIOA;
S#endif /*_GPIOA */
S
S#ifdef _GPIOB
S  EXT GPIO_TypeDef            *GPIOB;
S#endif /*_GPIOB */
S
S#ifdef _GPIOC
S  EXT GPIO_TypeDef            *GPIOC;
S#endif /*_GPIOC */
S
S#ifdef _GPIOD
S  EXT GPIO_TypeDef            *GPIOD;
S#endif /*_GPIOD */
S
S#ifdef _GPIOE
S  EXT GPIO_TypeDef            *GPIOE;
S#endif /*_GPIOE */
S
S#ifdef _GPIOF
S  EXT GPIO_TypeDef            *GPIOF;
S#endif /*_GPIOF */
S
S#ifdef _GPIOG
S  EXT GPIO_TypeDef            *GPIOG;
S#endif /*_GPIOG */
S
S#ifdef _ADC1
S  EXT ADC_TypeDef             *ADC1;
S#endif /*_ADC1 */
S
S#ifdef _ADC2
S  EXT ADC_TypeDef             *ADC2;
S#endif /*_ADC2 */
S
S#ifdef _TIM1
S  EXT TIM_TypeDef             *TIM1;
S#endif /*_TIM1 */
S
S#ifdef _SPI1
S  EXT SPI_TypeDef             *SPI1;
S#endif /*_SPI1 */
S
S#ifdef _TIM8
S  EXT TIM_TypeDef             *TIM8;
S#endif /*_TIM8 */
S
S#ifdef _USART1
S  EXT USART_TypeDef           *USART1;
S#endif /*_USART1 */
S
S#ifdef _ADC3
S  EXT ADC_TypeDef             *ADC3;
S#endif /*_ADC3 */
S
S#ifdef _SDIO
S  EXT SDIO_TypeDef            *SDIO;
S#endif /*_SDIO */
S
S#ifdef _DMA
S  EXT DMA_TypeDef             *DMA1;
S  EXT DMA_TypeDef             *DMA2;
S#endif /*_DMA */
S
S#ifdef _DMA1_Channel1
S  EXT DMA_Channel_TypeDef     *DMA1_Channel1;
S#endif /*_DMA1_Channel1 */
S
S#ifdef _DMA1_Channel2
S  EXT DMA_Channel_TypeDef     *DMA1_Channel2;
S#endif /*_DMA1_Channel2 */
S
S#ifdef _DMA1_Channel3
S  EXT DMA_Channel_TypeDef     *DMA1_Channel3;
S#endif /*_DMA1_Channel3 */
S
S#ifdef _DMA1_Channel4
S  EXT DMA_Channel_TypeDef     *DMA1_Channel4;
S#endif /*_DMA1_Channel4 */
S
S#ifdef _DMA1_Channel5
S  EXT DMA_Channel_TypeDef     *DMA1_Channel5;
S#endif /*_DMA1_Channel5 */
S
S#ifdef _DMA1_Channel6
S  EXT DMA_Channel_TypeDef     *DMA1_Channel6;
S#endif /*_DMA1_Channel6 */
S
S#ifdef _DMA1_Channel7
S  EXT DMA_Channel_TypeDef     *DMA1_Channel7;
S#endif /*_DMA1_Channel7 */
S
S#ifdef _DMA2_Channel1
S  EXT DMA_Channel_TypeDef     *DMA2_Channel1;
S#endif /*_DMA2_Channel1 */
S
S#ifdef _DMA2_Channel2
S  EXT DMA_Channel_TypeDef     *DMA2_Channel2;
S#endif /*_DMA2_Channel2 */
S
S#ifdef _DMA2_Channel3
S  EXT DMA_Channel_TypeDef     *DMA2_Channel3;
S#endif /*_DMA2_Channel3 */
S
S#ifdef _DMA2_Channel4
S  EXT DMA_Channel_TypeDef     *DMA2_Channel4;
S#endif /*_DMA2_Channel4 */
S
S#ifdef _DMA2_Channel5
S  EXT DMA_Channel_TypeDef     *DMA2_Channel5;
S#endif /*_DMA2_Channel5 */
S
S#ifdef _RCC
S  EXT RCC_TypeDef             *RCC;
S#endif /*_RCC */
S
S#ifdef _CRC
S  EXT CRC_TypeDef             *CRC;
S#endif /*_CRC */
S
S#ifdef _FLASH
S  EXT FLASH_TypeDef            *FLASH;
S  EXT OB_TypeDef               *OB;  
S#endif /*_FLASH */
S
S#ifdef _FSMC
S  EXT FSMC_Bank1_TypeDef      *FSMC_Bank1;
S  EXT FSMC_Bank1E_TypeDef     *FSMC_Bank1E;
S  EXT FSMC_Bank2_TypeDef      *FSMC_Bank2;
S  EXT FSMC_Bank3_TypeDef      *FSMC_Bank3;
S  EXT FSMC_Bank4_TypeDef      *FSMC_Bank4;
S#endif /*_FSMC */
S
S#ifdef _DBGMCU
S  EXT DBGMCU_TypeDef          *DBGMCU;
S#endif /*_DBGMCU */
S
S#ifdef _SysTick
S  EXT SysTick_TypeDef         *SysTick;
S#endif /*_SysTick */
S
S#ifdef _NVIC
S  EXT NVIC_TypeDef            *NVIC;
S  EXT SCB_TypeDef             *SCB;
S#endif /*_NVIC */
S
N#endif  /* DEBUG */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_MAP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 25 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N
N#ifdef _ADC
N  #include "stm32f10x_adc.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_adc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_adc.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      ADC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_ADC_H
N#define __STM32F10x_ADC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* ADC Init structure definition */
Ntypedef struct
N{
N  u32 ADC_Mode;
N  FunctionalState ADC_ScanConvMode; 
N  FunctionalState ADC_ContinuousConvMode;
N  u32 ADC_ExternalTrigConv;
N  u32 ADC_DataAlign;
N  u8 ADC_NbrOfChannel;
N}ADC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N#define IS_ADC_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC2_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC3_BASE))
X#define IS_ADC_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC2_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC3_BASE))
N                                 
N#define IS_ADC_DMA_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC3_BASE))
X#define IS_ADC_DMA_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC3_BASE))
N
N/* ADC dual mode -------------------------------------------------------------*/
N#define ADC_Mode_Independent                       ((u32)0x00000000)
N#define ADC_Mode_RegInjecSimult                    ((u32)0x00010000)
N#define ADC_Mode_RegSimult_AlterTrig               ((u32)0x00020000)
N#define ADC_Mode_InjecSimult_FastInterl            ((u32)0x00030000)
N#define ADC_Mode_InjecSimult_SlowInterl            ((u32)0x00040000)
N#define ADC_Mode_InjecSimult                       ((u32)0x00050000)
N#define ADC_Mode_RegSimult                         ((u32)0x00060000)
N#define ADC_Mode_FastInterl                        ((u32)0x00070000)
N#define ADC_Mode_SlowInterl                        ((u32)0x00080000)
N#define ADC_Mode_AlterTrig                         ((u32)0x00090000)
N
N#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
N                           ((MODE) == ADC_Mode_RegInjecSimult) || \
N                           ((MODE) == ADC_Mode_RegSimult_AlterTrig) || \
N                           ((MODE) == ADC_Mode_InjecSimult_FastInterl) || \
N                           ((MODE) == ADC_Mode_InjecSimult_SlowInterl) || \
N                           ((MODE) == ADC_Mode_InjecSimult) || \
N                           ((MODE) == ADC_Mode_RegSimult) || \
N                           ((MODE) == ADC_Mode_FastInterl) || \
N                           ((MODE) == ADC_Mode_SlowInterl) || \
N                           ((MODE) == ADC_Mode_AlterTrig))
X#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) ||                            ((MODE) == ADC_Mode_RegInjecSimult) ||                            ((MODE) == ADC_Mode_RegSimult_AlterTrig) ||                            ((MODE) == ADC_Mode_InjecSimult_FastInterl) ||                            ((MODE) == ADC_Mode_InjecSimult_SlowInterl) ||                            ((MODE) == ADC_Mode_InjecSimult) ||                            ((MODE) == ADC_Mode_RegSimult) ||                            ((MODE) == ADC_Mode_FastInterl) ||                            ((MODE) == ADC_Mode_SlowInterl) ||                            ((MODE) == ADC_Mode_AlterTrig))
N
N/* ADC extrenal trigger sources for regular channels conversion --------------*/
N/* for ADC1 and ADC2 */
N#define ADC_ExternalTrigConv_T1_CC1                ((u32)0x00000000)
N#define ADC_ExternalTrigConv_T1_CC2                ((u32)0x00020000)
N#define ADC_ExternalTrigConv_T2_CC2                ((u32)0x00060000)
N#define ADC_ExternalTrigConv_T3_TRGO               ((u32)0x00080000)
N#define ADC_ExternalTrigConv_T4_CC4                ((u32)0x000A0000)
N#define ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO    ((u32)0x000C0000)
N/* for ADC1, ADC2 and ADC3 */
N#define ADC_ExternalTrigConv_T1_CC3                ((u32)0x00040000)
N#define ADC_ExternalTrigConv_None                  ((u32)0x000E0000)
N/* for ADC3 */
N#define ADC_ExternalTrigConv_T3_CC1                ((u32)0x00000000)
N#define ADC_ExternalTrigConv_T2_CC3                ((u32)0x00020000)
N#define ADC_ExternalTrigConv_T8_CC1                ((u32)0x00060000)
N#define ADC_ExternalTrigConv_T8_TRGO               ((u32)0x00080000)
N#define ADC_ExternalTrigConv_T5_CC1                ((u32)0x000A0000)
N#define ADC_ExternalTrigConv_T5_CC3                ((u32)0x000C0000)
N
N#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_None) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
X#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_None) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
N
N/* ADC data align ------------------------------------------------------------*/
N#define ADC_DataAlign_Right                        ((u32)0x00000000)
N#define ADC_DataAlign_Left                         ((u32)0x00000800)
N
N#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
N                                  ((ALIGN) == ADC_DataAlign_Left))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) ||                                   ((ALIGN) == ADC_DataAlign_Left))
N
N/* ADC channels --------------------------------------------------------------*/
N#define ADC_Channel_0                               ((u8)0x00)
N#define ADC_Channel_1                               ((u8)0x01)
N#define ADC_Channel_2                               ((u8)0x02)
N#define ADC_Channel_3                               ((u8)0x03)
N#define ADC_Channel_4                               ((u8)0x04)
N#define ADC_Channel_5                               ((u8)0x05)
N#define ADC_Channel_6                               ((u8)0x06)
N#define ADC_Channel_7                               ((u8)0x07)
N#define ADC_Channel_8                               ((u8)0x08)
N#define ADC_Channel_9                               ((u8)0x09)
N#define ADC_Channel_10                              ((u8)0x0A)
N#define ADC_Channel_11                              ((u8)0x0B)
N#define ADC_Channel_12                              ((u8)0x0C)
N#define ADC_Channel_13                              ((u8)0x0D)
N#define ADC_Channel_14                              ((u8)0x0E)
N#define ADC_Channel_15                              ((u8)0x0F)
N#define ADC_Channel_16                              ((u8)0x10)
N#define ADC_Channel_17                              ((u8)0x11)
N
N#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) || \
N                                 ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) || \
N                                 ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) || \
N                                 ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) || \
N                                 ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) || \
N                                 ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) || \
N                                 ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \
N                                 ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \
N                                 ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) ||                                  ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) ||                                  ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) ||                                  ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) ||                                  ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) ||                                  ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) ||                                  ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) ||                                  ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) ||                                  ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
N
N/* ADC sampling times --------------------------------------------------------*/
N#define ADC_SampleTime_1Cycles5                    ((u8)0x00)
N#define ADC_SampleTime_7Cycles5                    ((u8)0x01)
N#define ADC_SampleTime_13Cycles5                   ((u8)0x02)
N#define ADC_SampleTime_28Cycles5                   ((u8)0x03)
N#define ADC_SampleTime_41Cycles5                   ((u8)0x04)
N#define ADC_SampleTime_55Cycles5                   ((u8)0x05)
N#define ADC_SampleTime_71Cycles5                   ((u8)0x06)
N#define ADC_SampleTime_239Cycles5                  ((u8)0x07)
N
N#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_7Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_13Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_28Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_41Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_55Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_71Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_239Cycles5))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) ||                                   ((TIME) == ADC_SampleTime_7Cycles5) ||                                   ((TIME) == ADC_SampleTime_13Cycles5) ||                                   ((TIME) == ADC_SampleTime_28Cycles5) ||                                   ((TIME) == ADC_SampleTime_41Cycles5) ||                                   ((TIME) == ADC_SampleTime_55Cycles5) ||                                   ((TIME) == ADC_SampleTime_71Cycles5) ||                                   ((TIME) == ADC_SampleTime_239Cycles5))
N
N/* ADC extrenal trigger sources for injected channels conversion -------------*/
N/* For ADC1 and ADC2 */
N#define ADC_ExternalTrigInjecConv_T2_TRGO           ((u32)0x00002000)
N#define ADC_ExternalTrigInjecConv_T2_CC1            ((u32)0x00003000)
N#define ADC_ExternalTrigInjecConv_T3_CC4            ((u32)0x00004000)
N#define ADC_ExternalTrigInjecConv_T4_TRGO           ((u32)0x00005000)
N#define ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4 ((u32)0x00006000)
N/* For ADC1, ADC2 and ADC3 */
N#define ADC_ExternalTrigInjecConv_T1_TRGO           ((u32)0x00000000)
N#define ADC_ExternalTrigInjecConv_T1_CC4            ((u32)0x00001000)
N#define ADC_ExternalTrigInjecConv_None              ((u32)0x00007000)
N/* For ADC3 */
N#define ADC_ExternalTrigInjecConv_T4_CC3            ((u32)0x00002000)
N#define ADC_ExternalTrigInjecConv_T8_CC2            ((u32)0x00003000)
N#define ADC_ExternalTrigInjecConv_T8_CC4            ((u32)0x00004000)
N#define ADC_ExternalTrigInjecConv_T5_TRGO           ((u32)0x00005000)
N#define ADC_ExternalTrigInjecConv_T5_CC4            ((u32)0x00006000)
N
N#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_None) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
X#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_None) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
N
N/* ADC injected channel selection --------------------------------------------*/
N#define ADC_InjectedChannel_1                       ((u8)0x14)
N#define ADC_InjectedChannel_2                       ((u8)0x18)
N#define ADC_InjectedChannel_3                       ((u8)0x1C)
N#define ADC_InjectedChannel_4                       ((u8)0x20)
N
N#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_4))
X#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) ||                                           ((CHANNEL) == ADC_InjectedChannel_2) ||                                           ((CHANNEL) == ADC_InjectedChannel_3) ||                                           ((CHANNEL) == ADC_InjectedChannel_4))
N
N/* ADC analog watchdog selection ---------------------------------------------*/
N#define ADC_AnalogWatchdog_SingleRegEnable         ((u32)0x00800200)
N#define ADC_AnalogWatchdog_SingleInjecEnable       ((u32)0x00400200)
N#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((u32)0x00C00200)
N#define ADC_AnalogWatchdog_AllRegEnable            ((u32)0x00800000)
N#define ADC_AnalogWatchdog_AllInjecEnable          ((u32)0x00400000)
N#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((u32)0x00C00000)
N#define ADC_AnalogWatchdog_None                    ((u32)0x00000000)
N
N#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
X#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_None))
N
N/* ADC interrupts definition -------------------------------------------------*/
N#define ADC_IT_EOC                                 ((u16)0x0220)
N#define ADC_IT_AWD                                 ((u16)0x0140)
N#define ADC_IT_JEOC                                ((u16)0x0480)
N
N#define IS_ADC_IT(IT) ((((IT) & (u16)0xF81F) == 0x00) && ((IT) != 0x00))
N#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
N                           ((IT) == ADC_IT_JEOC))
X#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) ||                            ((IT) == ADC_IT_JEOC))
N
N/* ADC flags definition ------------------------------------------------------*/
N#define ADC_FLAG_AWD                               ((u8)0x01)
N#define ADC_FLAG_EOC                               ((u8)0x02)
N#define ADC_FLAG_JEOC                              ((u8)0x04)
N#define ADC_FLAG_JSTRT                             ((u8)0x08)
N#define ADC_FLAG_STRT                              ((u8)0x10)
N
N#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (u8)0xE0) == 0x00) && ((FLAG) != 0x00))
N#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) || \
N                               ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) || \
N                               ((FLAG) == ADC_FLAG_STRT))
X#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) ||                                ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) ||                                ((FLAG) == ADC_FLAG_STRT))
N
N/* ADC thresholds ------------------------------------------------------------*/
N#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
N
N/* ADC injected offset -------------------------------------------------------*/
N#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
N
N/* ADC injected length -------------------------------------------------------*/
N#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
N
N/* ADC injected rank ---------------------------------------------------------*/
N#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
N
N/* ADC regular length --------------------------------------------------------*/
N#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
N
N/* ADC regular rank ----------------------------------------------------------*/
N#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
N
N/* ADC regular discontinuous mode number -------------------------------------*/
N#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid ADC_DeInit(ADC_TypeDef* ADCx);
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState);
Nvoid ADC_ResetCalibration(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);
Nvoid ADC_StartCalibration(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);
Nvoid ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
NFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
Nvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number);
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime);
Nvoid ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nu16 ADC_GetConversionValue(ADC_TypeDef* ADCx);
Nu32 ADC_GetDualModeConversionValue(void);
Nvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv);
Nvoid ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
NFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
Nvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime);
Nvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length);
Nvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset);
Nu16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel);
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog);
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold, u16 LowThreshold);
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel);
Nvoid ADC_TempSensorVrefintCmd(FunctionalState NewState);
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG);
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG);
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT);
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT);
N
N#endif /*__STM32F10x_ADC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 28 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_ADC */
N
N#ifdef _BKP
N  #include "stm32f10x_bkp.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_bkp.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_bkp.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      BKP firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_BKP_H
N#define __STM32F10x_BKP_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Tamper Pin active level */
N#define BKP_TamperPinLevel_High           ((u16)0x0000)
N#define BKP_TamperPinLevel_Low            ((u16)0x0001)
N
N#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) || \
N                                        ((LEVEL) == BKP_TamperPinLevel_Low))
X#define IS_BKP_TAMPER_PIN_LEVEL(LEVEL) (((LEVEL) == BKP_TamperPinLevel_High) ||                                         ((LEVEL) == BKP_TamperPinLevel_Low))
N
N/* RTC output source to output on the Tamper pin */
N#define BKP_RTCOutputSource_None          ((u16)0x0000)
N#define BKP_RTCOutputSource_CalibClock    ((u16)0x0080)
N#define BKP_RTCOutputSource_Alarm         ((u16)0x0100)
N#define BKP_RTCOutputSource_Second        ((u16)0x0300)
N
N#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_CalibClock) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_Alarm) || \
N                                          ((SOURCE) == BKP_RTCOutputSource_Second))
X#define IS_BKP_RTC_OUTPUT_SOURCE(SOURCE) (((SOURCE) == BKP_RTCOutputSource_None) ||                                           ((SOURCE) == BKP_RTCOutputSource_CalibClock) ||                                           ((SOURCE) == BKP_RTCOutputSource_Alarm) ||                                           ((SOURCE) == BKP_RTCOutputSource_Second))
N
N/* Data Backup Register */
N#define BKP_DR1                           ((u16)0x0004)
N#define BKP_DR2                           ((u16)0x0008)
N#define BKP_DR3                           ((u16)0x000C)
N#define BKP_DR4                           ((u16)0x0010)
N#define BKP_DR5                           ((u16)0x0014)
N#define BKP_DR6                           ((u16)0x0018)
N#define BKP_DR7                           ((u16)0x001C)
N#define BKP_DR8                           ((u16)0x0020)
N#define BKP_DR9                           ((u16)0x0024)
N#define BKP_DR10                          ((u16)0x0028)
N#define BKP_DR11                          ((u16)0x0040)
N#define BKP_DR12                          ((u16)0x0044)
N#define BKP_DR13                          ((u16)0x0048)
N#define BKP_DR14                          ((u16)0x004C)
N#define BKP_DR15                          ((u16)0x0050)
N#define BKP_DR16                          ((u16)0x0054)
N#define BKP_DR17                          ((u16)0x0058)
N#define BKP_DR18                          ((u16)0x005C)
N#define BKP_DR19                          ((u16)0x0060)
N#define BKP_DR20                          ((u16)0x0064)
N#define BKP_DR21                          ((u16)0x0068)
N#define BKP_DR22                          ((u16)0x006C)
N#define BKP_DR23                          ((u16)0x0070)
N#define BKP_DR24                          ((u16)0x0074)
N#define BKP_DR25                          ((u16)0x0078)
N#define BKP_DR26                          ((u16)0x007C)
N#define BKP_DR27                          ((u16)0x0080)
N#define BKP_DR28                          ((u16)0x0084)
N#define BKP_DR29                          ((u16)0x0088)
N#define BKP_DR30                          ((u16)0x008C)
N#define BKP_DR31                          ((u16)0x0090)
N#define BKP_DR32                          ((u16)0x0094)
N#define BKP_DR33                          ((u16)0x0098)
N#define BKP_DR34                          ((u16)0x009C)
N#define BKP_DR35                          ((u16)0x00A0)
N#define BKP_DR36                          ((u16)0x00A4)
N#define BKP_DR37                          ((u16)0x00A8)
N#define BKP_DR38                          ((u16)0x00AC)
N#define BKP_DR39                          ((u16)0x00B0)
N#define BKP_DR40                          ((u16)0x00B4)
N#define BKP_DR41                          ((u16)0x00B8)
N#define BKP_DR42                          ((u16)0x00BC)
N
N#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  || \
N                       ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  || \
N                       ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  || \
N                       ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) || \
N                       ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) || \
N                       ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) || \
N                       ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) || \
N                       ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) || \
N                       ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) || \
N                       ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) || \
N                       ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) || \
N                       ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) || \
N                       ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) || \
N                       ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
X#define IS_BKP_DR(DR) (((DR) == BKP_DR1)  || ((DR) == BKP_DR2)  || ((DR) == BKP_DR3)  ||                        ((DR) == BKP_DR4)  || ((DR) == BKP_DR5)  || ((DR) == BKP_DR6)  ||                        ((DR) == BKP_DR7)  || ((DR) == BKP_DR8)  || ((DR) == BKP_DR9)  ||                        ((DR) == BKP_DR10) || ((DR) == BKP_DR11) || ((DR) == BKP_DR12) ||                        ((DR) == BKP_DR13) || ((DR) == BKP_DR14) || ((DR) == BKP_DR15) ||                        ((DR) == BKP_DR16) || ((DR) == BKP_DR17) || ((DR) == BKP_DR18) ||                        ((DR) == BKP_DR19) || ((DR) == BKP_DR20) || ((DR) == BKP_DR21) ||                        ((DR) == BKP_DR22) || ((DR) == BKP_DR23) || ((DR) == BKP_DR24) ||                        ((DR) == BKP_DR25) || ((DR) == BKP_DR26) || ((DR) == BKP_DR27) ||                        ((DR) == BKP_DR28) || ((DR) == BKP_DR29) || ((DR) == BKP_DR30) ||                        ((DR) == BKP_DR31) || ((DR) == BKP_DR32) || ((DR) == BKP_DR33) ||                        ((DR) == BKP_DR34) || ((DR) == BKP_DR35) || ((DR) == BKP_DR36) ||                        ((DR) == BKP_DR37) || ((DR) == BKP_DR38) || ((DR) == BKP_DR39) ||                        ((DR) == BKP_DR40) || ((DR) == BKP_DR41) || ((DR) == BKP_DR42))
N
N#define IS_BKP_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x7F)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid BKP_DeInit(void);
Nvoid BKP_TamperPinLevelConfig(u16 BKP_TamperPinLevel);
Nvoid BKP_TamperPinCmd(FunctionalState NewState);
Nvoid BKP_ITConfig(FunctionalState NewState);
Nvoid BKP_RTCOutputConfig(u16 BKP_RTCOutputSource);
Nvoid BKP_SetRTCCalibrationValue(u8 CalibrationValue);
Nvoid BKP_WriteBackupRegister(u16 BKP_DR, u16 Data);
Nu16 BKP_ReadBackupRegister(u16 BKP_DR);
NFlagStatus BKP_GetFlagStatus(void);
Nvoid BKP_ClearFlag(void);
NITStatus BKP_GetITStatus(void);
Nvoid BKP_ClearITPendingBit(void);
N
N#endif /* __STM32F10x_BKP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 32 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_BKP */
N
N#ifdef _CAN
S  #include "stm32f10x_can.h"
N#endif /*_CAN */
N
N#ifdef _CRC
S  #include "stm32f10x_crc.h"
N#endif /*_CRC */
N
N#ifdef _DAC
S  #include "stm32f10x_dac.h"
N#endif /*_DAC */
N
N#ifdef _DBGMCU
S  #include "stm32f10x_dbgmcu.h"
N#endif /*_DBGMCU */
N
N#ifdef _DMA
S  #include "stm32f10x_dma.h"
N#endif /*_DMA */
N
N#ifdef _EXTI
N  #include "stm32f10x_exti.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_exti.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_exti.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      EXTI firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_EXTI_H
N#define __STM32F10x_EXTI_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* EXTI mode enumeration -----------------------------------------------------*/
Ntypedef enum
N{
N  EXTI_Mode_Interrupt = 0x00,
N  EXTI_Mode_Event = 0x04
N}EXTIMode_TypeDef;
N
N#define IS_EXTI_MODE(MODE) (((MODE) == EXTI_Mode_Interrupt) || ((MODE) == EXTI_Mode_Event))
N                            
N/* EXTI Trigger enumeration --------------------------------------------------*/
Ntypedef enum
N{
N  EXTI_Trigger_Rising = 0x08,
N  EXTI_Trigger_Falling = 0x0C,  
N  EXTI_Trigger_Rising_Falling = 0x10
N}EXTITrigger_TypeDef;
N
N#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) || \
N                                  ((TRIGGER) == EXTI_Trigger_Falling) || \
N                                  ((TRIGGER) == EXTI_Trigger_Rising_Falling))
X#define IS_EXTI_TRIGGER(TRIGGER) (((TRIGGER) == EXTI_Trigger_Rising) ||                                   ((TRIGGER) == EXTI_Trigger_Falling) ||                                   ((TRIGGER) == EXTI_Trigger_Rising_Falling))
N
N/* EXTI Init Structure definition --------------------------------------------*/
Ntypedef struct
N{
N  u32 EXTI_Line;
N  EXTIMode_TypeDef EXTI_Mode;
N  EXTITrigger_TypeDef EXTI_Trigger;
N  FunctionalState EXTI_LineCmd;
N}EXTI_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* EXTI Lines ----------------------------------------------------------------*/
N#define EXTI_Line0       ((u32)0x00001)  /* External interrupt line 0 */
N#define EXTI_Line1       ((u32)0x00002)  /* External interrupt line 1 */
N#define EXTI_Line2       ((u32)0x00004)  /* External interrupt line 2 */
N#define EXTI_Line3       ((u32)0x00008)  /* External interrupt line 3 */
N#define EXTI_Line4       ((u32)0x00010)  /* External interrupt line 4 */
N#define EXTI_Line5       ((u32)0x00020)  /* External interrupt line 5 */
N#define EXTI_Line6       ((u32)0x00040)  /* External interrupt line 6 */
N#define EXTI_Line7       ((u32)0x00080)  /* External interrupt line 7 */
N#define EXTI_Line8       ((u32)0x00100)  /* External interrupt line 8 */
N#define EXTI_Line9       ((u32)0x00200)  /* External interrupt line 9 */
N#define EXTI_Line10      ((u32)0x00400)  /* External interrupt line 10 */
N#define EXTI_Line11      ((u32)0x00800)  /* External interrupt line 11 */
N#define EXTI_Line12      ((u32)0x01000)  /* External interrupt line 12 */
N#define EXTI_Line13      ((u32)0x02000)  /* External interrupt line 13 */
N#define EXTI_Line14      ((u32)0x04000)  /* External interrupt line 14 */
N#define EXTI_Line15      ((u32)0x08000)  /* External interrupt line 15 */
N#define EXTI_Line16      ((u32)0x10000)  /* External interrupt line 16
N                                            Connected to the PVD Output */
N#define EXTI_Line17      ((u32)0x20000)  /* External interrupt line 17 
N                                            Connected to the RTC Alarm event */
N#define EXTI_Line18      ((u32)0x40000)  /* External interrupt line 18 
N                                            Connected to the USB Wakeup from 
N                                            suspend event */
N
N#define IS_EXTI_LINE(LINE) ((((LINE) & (u32)0xFFF80000) == 0x00) && ((LINE) != (u16)0x00))
N
N#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) || \
N                            ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) || \
N                            ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) || \
N                            ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) || \
N                            ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) || \
N                            ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) || \
N                            ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) || \
N                            ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) || \
N                            ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) || \
N                            ((LINE) == EXTI_Line18))
X#define IS_GET_EXTI_LINE(LINE) (((LINE) == EXTI_Line0) || ((LINE) == EXTI_Line1) ||                             ((LINE) == EXTI_Line2) || ((LINE) == EXTI_Line3) ||                             ((LINE) == EXTI_Line4) || ((LINE) == EXTI_Line5) ||                             ((LINE) == EXTI_Line6) || ((LINE) == EXTI_Line7) ||                             ((LINE) == EXTI_Line8) || ((LINE) == EXTI_Line9) ||                             ((LINE) == EXTI_Line10) || ((LINE) == EXTI_Line11) ||                             ((LINE) == EXTI_Line12) || ((LINE) == EXTI_Line13) ||                             ((LINE) == EXTI_Line14) || ((LINE) == EXTI_Line15) ||                             ((LINE) == EXTI_Line16) || ((LINE) == EXTI_Line17) ||                             ((LINE) == EXTI_Line18))
N                                 
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid EXTI_DeInit(void);
Nvoid EXTI_Init(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_StructInit(EXTI_InitTypeDef* EXTI_InitStruct);
Nvoid EXTI_GenerateSWInterrupt(u32 EXTI_Line);
NFlagStatus EXTI_GetFlagStatus(u32 EXTI_Line);
Nvoid EXTI_ClearFlag(u32 EXTI_Line);
NITStatus EXTI_GetITStatus(u32 EXTI_Line);
Nvoid EXTI_ClearITPendingBit(u32 EXTI_Line);
N
N#endif /* __STM32F10x_EXTI_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 56 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_EXTI */
N
N#ifdef _FLASH
N  #include "stm32f10x_flash.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_flash.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_flash.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      FLASH firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_FLASH_H
N#define __STM32F10x_FLASH_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N#ifdef _FLASH_PROG
S/* FLASH Status */
Stypedef enum
S{ 
S  FLASH_BUSY = 1,
S  FLASH_ERROR_PG,
S  FLASH_ERROR_WRP,
S  FLASH_COMPLETE,
S  FLASH_TIMEOUT
S}FLASH_Status;
N#endif
N
N/* Flash Latency -------------------------------------------------------------*/
N#define FLASH_Latency_0                ((u32)0x00000000)  /* FLASH Zero Latency cycle */
N#define FLASH_Latency_1                ((u32)0x00000001)  /* FLASH One Latency cycle */
N#define FLASH_Latency_2                ((u32)0x00000002)  /* FLASH Two Latency cycles */
N
N#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) || \
N                                   ((LATENCY) == FLASH_Latency_1) || \
N                                   ((LATENCY) == FLASH_Latency_2))
X#define IS_FLASH_LATENCY(LATENCY) (((LATENCY) == FLASH_Latency_0) ||                                    ((LATENCY) == FLASH_Latency_1) ||                                    ((LATENCY) == FLASH_Latency_2))
N
N/* Half Cycle Enable/Disable -------------------------------------------------*/
N#define FLASH_HalfCycleAccess_Enable   ((u32)0x00000008)  /* FLASH Half Cycle Enable */
N#define FLASH_HalfCycleAccess_Disable  ((u32)0x00000000)  /* FLASH Half Cycle Disable */
N
N#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) || \
N                                               ((STATE) == FLASH_HalfCycleAccess_Disable)) 
X#define IS_FLASH_HALFCYCLEACCESS_STATE(STATE) (((STATE) == FLASH_HalfCycleAccess_Enable) ||                                                ((STATE) == FLASH_HalfCycleAccess_Disable)) 
N
N
N/* Prefetch Buffer Enable/Disable --------------------------------------------*/
N#define FLASH_PrefetchBuffer_Enable    ((u32)0x00000010)  /* FLASH Prefetch Buffer Enable */
N#define FLASH_PrefetchBuffer_Disable   ((u32)0x00000000)  /* FLASH Prefetch Buffer Disable */
N
N#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) || \
N                                              ((STATE) == FLASH_PrefetchBuffer_Disable)) 
X#define IS_FLASH_PREFETCHBUFFER_STATE(STATE) (((STATE) == FLASH_PrefetchBuffer_Enable) ||                                               ((STATE) == FLASH_PrefetchBuffer_Disable)) 
N
N#ifdef _FLASH_PROG
S/* Option Bytes Write Protection ---------------------------------------------*/
S/* Values to be used with STM32F10Xxx Medium-density devices: FLASH memory density
S   ranges between 32 and 128 Kbytes with page size equal to 1 Kbytes */
S#define FLASH_WRProt_Pages0to3         ((u32)0x00000001) /* Write protection of page 0 to 3 */
S#define FLASH_WRProt_Pages4to7         ((u32)0x00000002) /* Write protection of page 4 to 7 */
S#define FLASH_WRProt_Pages8to11        ((u32)0x00000004) /* Write protection of page 8 to 11 */
S#define FLASH_WRProt_Pages12to15       ((u32)0x00000008) /* Write protection of page 12 to 15 */
S#define FLASH_WRProt_Pages16to19       ((u32)0x00000010) /* Write protection of page 16 to 19 */
S#define FLASH_WRProt_Pages20to23       ((u32)0x00000020) /* Write protection of page 20 to 23 */
S#define FLASH_WRProt_Pages24to27       ((u32)0x00000040) /* Write protection of page 24 to 27 */
S#define FLASH_WRProt_Pages28to31       ((u32)0x00000080) /* Write protection of page 28 to 31 */
S#define FLASH_WRProt_Pages32to35       ((u32)0x00000100) /* Write protection of page 32 to 35 */
S#define FLASH_WRProt_Pages36to39       ((u32)0x00000200) /* Write protection of page 36 to 39 */
S#define FLASH_WRProt_Pages40to43       ((u32)0x00000400) /* Write protection of page 40 to 43 */
S#define FLASH_WRProt_Pages44to47       ((u32)0x00000800) /* Write protection of page 44 to 47 */
S#define FLASH_WRProt_Pages48to51       ((u32)0x00001000) /* Write protection of page 48 to 51 */
S#define FLASH_WRProt_Pages52to55       ((u32)0x00002000) /* Write protection of page 52 to 55 */
S#define FLASH_WRProt_Pages56to59       ((u32)0x00004000) /* Write protection of page 56 to 59 */
S#define FLASH_WRProt_Pages60to63       ((u32)0x00008000) /* Write protection of page 60 to 63 */
S#define FLASH_WRProt_Pages64to67       ((u32)0x00010000) /* Write protection of page 64 to 67 */
S#define FLASH_WRProt_Pages68to71       ((u32)0x00020000) /* Write protection of page 68 to 71 */
S#define FLASH_WRProt_Pages72to75       ((u32)0x00040000) /* Write protection of page 72 to 75 */
S#define FLASH_WRProt_Pages76to79       ((u32)0x00080000) /* Write protection of page 76 to 79 */
S#define FLASH_WRProt_Pages80to83       ((u32)0x00100000) /* Write protection of page 80 to 83 */
S#define FLASH_WRProt_Pages84to87       ((u32)0x00200000) /* Write protection of page 84 to 87 */
S#define FLASH_WRProt_Pages88to91       ((u32)0x00400000) /* Write protection of page 88 to 91 */
S#define FLASH_WRProt_Pages92to95       ((u32)0x00800000) /* Write protection of page 92 to 95 */
S#define FLASH_WRProt_Pages96to99       ((u32)0x01000000) /* Write protection of page 96 to 99 */
S#define FLASH_WRProt_Pages100to103     ((u32)0x02000000) /* Write protection of page 100 to 103 */
S#define FLASH_WRProt_Pages104to107     ((u32)0x04000000) /* Write protection of page 104 to 107 */
S#define FLASH_WRProt_Pages108to111     ((u32)0x08000000) /* Write protection of page 108 to 111 */
S#define FLASH_WRProt_Pages112to115     ((u32)0x10000000) /* Write protection of page 112 to 115 */
S#define FLASH_WRProt_Pages116to119     ((u32)0x20000000) /* Write protection of page 115 to 119 */
S#define FLASH_WRProt_Pages120to123     ((u32)0x40000000) /* Write protection of page 120 to 123 */
S#define FLASH_WRProt_Pages124to127     ((u32)0x80000000) /* Write protection of page 124 to 127 */
S/* Values to be used with STM32F10Xxx High-density devices: FLASH memory density
S   ranges between 256 and 512 Kbytes with page size equal to 2 Kbytes */
S#define FLASH_WRProt_Pages0to1         ((u32)0x00000001) /* Write protection of page 0 to 1 */
S#define FLASH_WRProt_Pages2to3         ((u32)0x00000002) /* Write protection of page 2 to 3 */
S#define FLASH_WRProt_Pages4to5         ((u32)0x00000004) /* Write protection of page 4 to 5 */
S#define FLASH_WRProt_Pages6to7         ((u32)0x00000008) /* Write protection of page 6 to 7 */
S#define FLASH_WRProt_Pages8to9         ((u32)0x00000010) /* Write protection of page 8 to 9 */
S#define FLASH_WRProt_Pages10to11       ((u32)0x00000020) /* Write protection of page 10 to 11 */
S#define FLASH_WRProt_Pages12to13       ((u32)0x00000040) /* Write protection of page 12 to 13 */
S#define FLASH_WRProt_Pages14to15       ((u32)0x00000080) /* Write protection of page 14 to 15 */
S#define FLASH_WRProt_Pages16to17       ((u32)0x00000100) /* Write protection of page 16 to 17 */
S#define FLASH_WRProt_Pages18to19       ((u32)0x00000200) /* Write protection of page 18 to 19 */
S#define FLASH_WRProt_Pages20to21       ((u32)0x00000400) /* Write protection of page 20 to 21 */
S#define FLASH_WRProt_Pages22to23       ((u32)0x00000800) /* Write protection of page 22 to 23 */
S#define FLASH_WRProt_Pages24to25       ((u32)0x00001000) /* Write protection of page 24 to 25 */
S#define FLASH_WRProt_Pages26to27       ((u32)0x00002000) /* Write protection of page 26 to 27 */
S#define FLASH_WRProt_Pages28to29       ((u32)0x00004000) /* Write protection of page 28 to 29 */
S#define FLASH_WRProt_Pages30to31       ((u32)0x00008000) /* Write protection of page 30 to 31 */
S#define FLASH_WRProt_Pages32to33       ((u32)0x00010000) /* Write protection of page 32 to 33 */
S#define FLASH_WRProt_Pages34to35       ((u32)0x00020000) /* Write protection of page 34 to 35 */
S#define FLASH_WRProt_Pages36to37       ((u32)0x00040000) /* Write protection of page 36 to 37 */
S#define FLASH_WRProt_Pages38to39       ((u32)0x00080000) /* Write protection of page 38 to 39 */
S#define FLASH_WRProt_Pages40to41       ((u32)0x00100000) /* Write protection of page 40 to 41 */
S#define FLASH_WRProt_Pages42to43       ((u32)0x00200000) /* Write protection of page 42 to 43 */
S#define FLASH_WRProt_Pages44to45       ((u32)0x00400000) /* Write protection of page 44 to 45 */
S#define FLASH_WRProt_Pages46to47       ((u32)0x00800000) /* Write protection of page 46 to 47 */
S#define FLASH_WRProt_Pages48to49       ((u32)0x01000000) /* Write protection of page 48 to 49 */
S#define FLASH_WRProt_Pages50to51       ((u32)0x02000000) /* Write protection of page 50 to 51 */
S#define FLASH_WRProt_Pages52to53       ((u32)0x04000000) /* Write protection of page 52 to 53 */
S#define FLASH_WRProt_Pages54to55       ((u32)0x08000000) /* Write protection of page 54 to 55 */
S#define FLASH_WRProt_Pages56to57       ((u32)0x10000000) /* Write protection of page 56 to 57 */
S#define FLASH_WRProt_Pages58to59       ((u32)0x20000000) /* Write protection of page 58 to 59 */
S#define FLASH_WRProt_Pages60to61       ((u32)0x40000000) /* Write protection of page 60 to 61 */
S#define FLASH_WRProt_Pages62to255      ((u32)0x80000000) /* Write protection of page 62 to 255 */
S#define FLASH_WRProt_AllPages          ((u32)0xFFFFFFFF) /* Write protection of all Pages */
S
S#define IS_FLASH_WRPROT_PAGE(PAGE) (((PAGE) != 0x00000000))
S
S#define IS_FLASH_ADDRESS(ADDRESS) (((ADDRESS) >= 0x08000000) && ((ADDRESS) < 0x0807FFFF))
S#define IS_OB_DATA_ADDRESS(ADDRESS) (((ADDRESS) == 0x1FFFF804) || ((ADDRESS) == 0x1FFFF806))
S
S/* Option Bytes IWatchdog ----------------------------------------------------*/
S#define OB_IWDG_SW                     ((u16)0x0001)  /* Software IWDG selected */
S#define OB_IWDG_HW                     ((u16)0x0000)  /* Hardware IWDG selected */
S
S#define IS_OB_IWDG_SOURCE(SOURCE) (((SOURCE) == OB_IWDG_SW) || ((SOURCE) == OB_IWDG_HW))
S
S/* Option Bytes nRST_STOP ----------------------------------------------------*/
S#define OB_STOP_NoRST                  ((u16)0x0002) /* No reset generated when entering in STOP */
S#define OB_STOP_RST                    ((u16)0x0000) /* Reset generated when entering in STOP */
S
S#define IS_OB_STOP_SOURCE(SOURCE) (((SOURCE) == OB_STOP_NoRST) || ((SOURCE) == OB_STOP_RST))
S
S/* Option Bytes nRST_STDBY ---------------------------------------------------*/
S#define OB_STDBY_NoRST                 ((u16)0x0004) /* No reset generated when entering in STANDBY */
S#define OB_STDBY_RST                   ((u16)0x0000) /* Reset generated when entering in STANDBY */
S
S#define IS_OB_STDBY_SOURCE(SOURCE) (((SOURCE) == OB_STDBY_NoRST) || ((SOURCE) == OB_STDBY_RST))
S
S/* FLASH Interrupts ----------------------------------------------------------*/
S#define FLASH_IT_ERROR                 ((u32)0x00000400)  /* FPEC error interrupt source */
S#define FLASH_IT_EOP                   ((u32)0x00001000)  /* End of FLASH Operation Interrupt source */
S
S#define IS_FLASH_IT(IT) ((((IT) & (u32)0xFFFFEBFF) == 0x00000000) && (((IT) != 0x00000000)))
S
S/* FLASH Flags ---------------------------------------------------------------*/
S#define FLASH_FLAG_BSY                 ((u32)0x00000001)  /* FLASH Busy flag */
S#define FLASH_FLAG_EOP                 ((u32)0x00000020)  /* FLASH End of Operation flag */
S#define FLASH_FLAG_PGERR               ((u32)0x00000004)  /* FLASH Program error flag */
S#define FLASH_FLAG_WRPRTERR            ((u32)0x00000010)  /* FLASH Write protected error flag */
S#define FLASH_FLAG_OPTERR              ((u32)0x00000001)  /* FLASH Option Byte error flag */
S 
S#define IS_FLASH_CLEAR_FLAG(FLAG) ((((FLAG) & (u32)0xFFFFFFCA) == 0x00000000) && ((FLAG) != 0x00000000))
S
S#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) || \
S                                  ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) || \
S                                  ((FLAG) == FLASH_FLAG_OPTERR))
X#define IS_FLASH_GET_FLAG(FLAG)  (((FLAG) == FLASH_FLAG_BSY) || ((FLAG) == FLASH_FLAG_EOP) ||                                   ((FLAG) == FLASH_FLAG_PGERR) || ((FLAG) == FLASH_FLAG_WRPRTERR) ||                                   ((FLAG) == FLASH_FLAG_OPTERR))
N#endif
N								 
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid FLASH_SetLatency(u32 FLASH_Latency);
Nvoid FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess);
Nvoid FLASH_PrefetchBufferCmd(u32 FLASH_PrefetchBuffer);
N
N#ifdef _FLASH_PROG
Svoid FLASH_Unlock(void);
Svoid FLASH_Lock(void);
SFLASH_Status FLASH_ErasePage(u32 Page_Address);
SFLASH_Status FLASH_EraseAllPages(void);
SFLASH_Status FLASH_EraseOptionBytes(void);
SFLASH_Status FLASH_ProgramWord(u32 Address, u32 Data);
SFLASH_Status FLASH_ProgramHalfWord(u32 Address, u16 Data);
SFLASH_Status FLASH_ProgramOptionByteData(u32 Address, u8 Data);
SFLASH_Status FLASH_EnableWriteProtection(u32 FLASH_Pages);
SFLASH_Status FLASH_ReadOutProtection(FunctionalState NewState);
SFLASH_Status FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY);
Su32 FLASH_GetUserOptionByte(void);
Su32 FLASH_GetWriteProtectionOptionByte(void);
SFlagStatus FLASH_GetReadOutProtectionStatus(void);
SFlagStatus FLASH_GetPrefetchBufferStatus(void);
Svoid FLASH_ITConfig(u16 FLASH_IT, FunctionalState NewState);
SFlagStatus FLASH_GetFlagStatus(u16 FLASH_FLAG);
Svoid FLASH_ClearFlag(u16 FLASH_FLAG);
SFLASH_Status FLASH_GetStatus(void);
SFLASH_Status FLASH_WaitForLastOperation(u32 Timeout);
N#endif
N
N#endif /* __STM32F10x_FLASH_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 60 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_FLASH */
N
N#ifdef _FSMC
S  #include "stm32f10x_fsmc.h"
N#endif /*_FSMC */
N
N#ifdef _GPIO
N  #include "stm32f10x_gpio.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_gpio.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_gpio.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      GPIO firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_GPIO_H
N#define __STM32F10x_GPIO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N#define IS_GPIO_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == GPIOA_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOB_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOC_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOD_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOE_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOF_BASE) || \
N                                    ((*(u32*)&(PERIPH)) == GPIOG_BASE))
X#define IS_GPIO_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == GPIOA_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOB_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOC_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOD_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOE_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOF_BASE) ||                                     ((*(u32*)&(PERIPH)) == GPIOG_BASE))
N                                     
N/* Output Maximum frequency selection ----------------------------------------*/
Ntypedef enum
N{ 
N  GPIO_Speed_10MHz = 1,
N  GPIO_Speed_2MHz, 
N  GPIO_Speed_50MHz
N}GPIOSpeed_TypeDef;
N
N#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) || \
N                              ((SPEED) == GPIO_Speed_50MHz))
X#define IS_GPIO_SPEED(SPEED) (((SPEED) == GPIO_Speed_10MHz) || ((SPEED) == GPIO_Speed_2MHz) ||                               ((SPEED) == GPIO_Speed_50MHz))
N                                         
N/* Configuration Mode enumeration --------------------------------------------*/
Ntypedef enum
N{ GPIO_Mode_AIN = 0x0,
N  GPIO_Mode_IN_FLOATING = 0x04,
N  GPIO_Mode_IPD = 0x28,
N  GPIO_Mode_IPU = 0x48,
N  GPIO_Mode_Out_OD = 0x14,
N  GPIO_Mode_Out_PP = 0x10,
N  GPIO_Mode_AF_OD = 0x1C,
N  GPIO_Mode_AF_PP = 0x18
N}GPIOMode_TypeDef;
N
N#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) || \
N                            ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) || \
N                            ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) || \
N                            ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
X#define IS_GPIO_MODE(MODE) (((MODE) == GPIO_Mode_AIN) || ((MODE) == GPIO_Mode_IN_FLOATING) ||                             ((MODE) == GPIO_Mode_IPD) || ((MODE) == GPIO_Mode_IPU) ||                             ((MODE) == GPIO_Mode_Out_OD) || ((MODE) == GPIO_Mode_Out_PP) ||                             ((MODE) == GPIO_Mode_AF_OD) || ((MODE) == GPIO_Mode_AF_PP))
N                              
N/* GPIO Init structure definition */
Ntypedef struct
N{
N  u16 GPIO_Pin;
N  GPIOSpeed_TypeDef GPIO_Speed;
N  GPIOMode_TypeDef GPIO_Mode;
N}GPIO_InitTypeDef;
N
N/* Bit_SET and Bit_RESET enumeration -----------------------------------------*/
Ntypedef enum
N{ Bit_RESET = 0,
N  Bit_SET
N}BitAction;
N#define IS_GPIO_BIT_ACTION(ACTION) (((ACTION) == Bit_RESET) || ((ACTION) == Bit_SET))
N
N/* Exported constants --------------------------------------------------------*/
N/* GPIO pins define ----------------------------------------------------------*/
N#define GPIO_Pin_0                 ((u16)0x0001)  /* Pin 0 selected */
N#define GPIO_Pin_1                 ((u16)0x0002)  /* Pin 1 selected */
N#define GPIO_Pin_2                 ((u16)0x0004)  /* Pin 2 selected */
N#define GPIO_Pin_3                 ((u16)0x0008)  /* Pin 3 selected */
N#define GPIO_Pin_4                 ((u16)0x0010)  /* Pin 4 selected */
N#define GPIO_Pin_5                 ((u16)0x0020)  /* Pin 5 selected */
N#define GPIO_Pin_6                 ((u16)0x0040)  /* Pin 6 selected */
N#define GPIO_Pin_7                 ((u16)0x0080)  /* Pin 7 selected */
N#define GPIO_Pin_8                 ((u16)0x0100)  /* Pin 8 selected */
N#define GPIO_Pin_9                 ((u16)0x0200)  /* Pin 9 selected */
N#define GPIO_Pin_10                ((u16)0x0400)  /* Pin 10 selected */
N#define GPIO_Pin_11                ((u16)0x0800)  /* Pin 11 selected */
N#define GPIO_Pin_12                ((u16)0x1000)  /* Pin 12 selected */
N#define GPIO_Pin_13                ((u16)0x2000)  /* Pin 13 selected */
N#define GPIO_Pin_14                ((u16)0x4000)  /* Pin 14 selected */
N#define GPIO_Pin_15                ((u16)0x8000)  /* Pin 15 selected */
N#define GPIO_Pin_All               ((u16)0xFFFF)  /* All pins selected */
N
N#define IS_GPIO_PIN(PIN) ((((PIN) & (u16)0x00) == 0x00) && ((PIN) != (u16)0x00))
N
N#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) || \
N                              ((PIN) == GPIO_Pin_1) || \
N                              ((PIN) == GPIO_Pin_2) || \
N                              ((PIN) == GPIO_Pin_3) || \
N                              ((PIN) == GPIO_Pin_4) || \
N                              ((PIN) == GPIO_Pin_5) || \
N                              ((PIN) == GPIO_Pin_6) || \
N                              ((PIN) == GPIO_Pin_7) || \
N                              ((PIN) == GPIO_Pin_8) || \
N                              ((PIN) == GPIO_Pin_9) || \
N                              ((PIN) == GPIO_Pin_10) || \
N                              ((PIN) == GPIO_Pin_11) || \
N                              ((PIN) == GPIO_Pin_12) || \
N                              ((PIN) == GPIO_Pin_13) || \
N                              ((PIN) == GPIO_Pin_14) || \
N                              ((PIN) == GPIO_Pin_15))
X#define IS_GET_GPIO_PIN(PIN) (((PIN) == GPIO_Pin_0) ||                               ((PIN) == GPIO_Pin_1) ||                               ((PIN) == GPIO_Pin_2) ||                               ((PIN) == GPIO_Pin_3) ||                               ((PIN) == GPIO_Pin_4) ||                               ((PIN) == GPIO_Pin_5) ||                               ((PIN) == GPIO_Pin_6) ||                               ((PIN) == GPIO_Pin_7) ||                               ((PIN) == GPIO_Pin_8) ||                               ((PIN) == GPIO_Pin_9) ||                               ((PIN) == GPIO_Pin_10) ||                               ((PIN) == GPIO_Pin_11) ||                               ((PIN) == GPIO_Pin_12) ||                               ((PIN) == GPIO_Pin_13) ||                               ((PIN) == GPIO_Pin_14) ||                               ((PIN) == GPIO_Pin_15))
N                            
N/* GPIO Remap define ---------------------------------------------------------*/
N#define GPIO_Remap_SPI1            ((u32)0x00000001)  /* SPI1 Alternate Function mapping */
N#define GPIO_Remap_I2C1            ((u32)0x00000002)  /* I2C1 Alternate Function mapping */
N#define GPIO_Remap_USART1          ((u32)0x00000004)  /* USART1 Alternate Function mapping */
N#define GPIO_Remap_USART2          ((u32)0x00000008)  /* USART2 Alternate Function mapping */
N#define GPIO_PartialRemap_USART3   ((u32)0x00140010)  /* USART3 Partial Alternate Function mapping */
N#define GPIO_FullRemap_USART3      ((u32)0x00140030)  /* USART3 Full Alternate Function mapping */
N#define GPIO_PartialRemap_TIM1     ((u32)0x00160040)  /* TIM1 Partial Alternate Function mapping */
N#define GPIO_FullRemap_TIM1        ((u32)0x001600C0)  /* TIM1 Full Alternate Function mapping */
N#define GPIO_PartialRemap1_TIM2    ((u32)0x00180100)  /* TIM2 Partial1 Alternate Function mapping */
N#define GPIO_PartialRemap2_TIM2    ((u32)0x00180200)  /* TIM2 Partial2 Alternate Function mapping */
N#define GPIO_FullRemap_TIM2        ((u32)0x00180300)  /* TIM2 Full Alternate Function mapping */
N#define GPIO_PartialRemap_TIM3     ((u32)0x001A0800)  /* TIM3 Partial Alternate Function mapping */
N#define GPIO_FullRemap_TIM3        ((u32)0x001A0C00)  /* TIM3 Full Alternate Function mapping */
N#define GPIO_Remap_TIM4            ((u32)0x00001000)  /* TIM4 Alternate Function mapping */
N#define GPIO_Remap1_CAN            ((u32)0x001D4000)  /* CAN Alternate Function mapping */
N#define GPIO_Remap2_CAN            ((u32)0x001D6000)  /* CAN Alternate Function mapping */
N#define GPIO_Remap_PD01            ((u32)0x00008000)  /* PD01 Alternate Function mapping */
N#define GPIO_Remap_TIM5CH4_LSI     ((u32)0x00200001)  /* LSI connected to TIM5 Channel4 input capture for calibration */
N#define GPIO_Remap_ADC1_ETRGINJ    ((u32)0x00200002)  /* ADC1 External Trigger Injected Conversion remapping */
N#define GPIO_Remap_ADC1_ETRGREG    ((u32)0x00200004)  /* ADC1 External Trigger Regular Conversion remapping */
N#define GPIO_Remap_ADC2_ETRGINJ    ((u32)0x00200008)  /* ADC2 External Trigger Injected Conversion remapping */
N#define GPIO_Remap_ADC2_ETRGREG    ((u32)0x00200010)  /* ADC2 External Trigger Regular Conversion remapping */
N#define GPIO_Remap_SWJ_NoJTRST     ((u32)0x00300100)  /* Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST */
N#define GPIO_Remap_SWJ_JTAGDisable ((u32)0x00300200)  /* JTAG-DP Disabled and SW-DP Enabled */
N#define GPIO_Remap_SWJ_Disable     ((u32)0x00300400)  /* Full SWJ Disabled (JTAG-DP + SW-DP) */
N
N
N#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) || \
N                              ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) || \
N                              ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) || \
N                              ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) || \
N                              ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) || \
N                              ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) || \
N                              ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) || \
N                              ((REMAP) == GPIO_Remap1_CAN) || ((REMAP) == GPIO_Remap2_CAN) || \
N                              ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) || \
N                              ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) || \
N                              ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) || \
N                              ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable)|| \
N                              ((REMAP) == GPIO_Remap_SWJ_Disable))
X#define IS_GPIO_REMAP(REMAP) (((REMAP) == GPIO_Remap_SPI1) || ((REMAP) == GPIO_Remap_I2C1) ||                               ((REMAP) == GPIO_Remap_USART1) || ((REMAP) == GPIO_Remap_USART2) ||                               ((REMAP) == GPIO_PartialRemap_USART3) || ((REMAP) == GPIO_FullRemap_USART3) ||                               ((REMAP) == GPIO_PartialRemap_TIM1) || ((REMAP) == GPIO_FullRemap_TIM1) ||                               ((REMAP) == GPIO_PartialRemap1_TIM2) || ((REMAP) == GPIO_PartialRemap2_TIM2) ||                               ((REMAP) == GPIO_FullRemap_TIM2) || ((REMAP) == GPIO_PartialRemap_TIM3) ||                               ((REMAP) == GPIO_FullRemap_TIM3) || ((REMAP) == GPIO_Remap_TIM4) ||                               ((REMAP) == GPIO_Remap1_CAN) || ((REMAP) == GPIO_Remap2_CAN) ||                               ((REMAP) == GPIO_Remap_PD01) || ((REMAP) == GPIO_Remap_TIM5CH4_LSI) ||                               ((REMAP) == GPIO_Remap_ADC1_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC1_ETRGREG) ||                               ((REMAP) == GPIO_Remap_ADC2_ETRGINJ) ||((REMAP) == GPIO_Remap_ADC2_ETRGREG) ||                               ((REMAP) == GPIO_Remap_SWJ_NoJTRST) || ((REMAP) == GPIO_Remap_SWJ_JTAGDisable)||                               ((REMAP) == GPIO_Remap_SWJ_Disable))
N                              
N/* GPIO Port Sources ---------------------------------------------------------*/
N#define GPIO_PortSourceGPIOA       ((u8)0x00)
N#define GPIO_PortSourceGPIOB       ((u8)0x01)
N#define GPIO_PortSourceGPIOC       ((u8)0x02)
N#define GPIO_PortSourceGPIOD       ((u8)0x03)
N#define GPIO_PortSourceGPIOE       ((u8)0x04)
N#define GPIO_PortSourceGPIOF       ((u8)0x05)
N#define GPIO_PortSourceGPIOG       ((u8)0x06)
N
N#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
N                                                  ((PORTSOURCE) == GPIO_PortSourceGPIOE))
X#define IS_GPIO_EVENTOUT_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOB) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOC) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOD) ||                                                   ((PORTSOURCE) == GPIO_PortSourceGPIOE))
N                                         
N#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOB) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOC) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOD) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOE) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOF) || \
N                                              ((PORTSOURCE) == GPIO_PortSourceGPIOG))
X#define IS_GPIO_EXTI_PORT_SOURCE(PORTSOURCE) (((PORTSOURCE) == GPIO_PortSourceGPIOA) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOB) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOC) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOD) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOE) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOF) ||                                               ((PORTSOURCE) == GPIO_PortSourceGPIOG))
N                                       
N/* GPIO Pin sources ----------------------------------------------------------*/
N#define GPIO_PinSource0            ((u8)0x00)
N#define GPIO_PinSource1            ((u8)0x01)
N#define GPIO_PinSource2            ((u8)0x02)
N#define GPIO_PinSource3            ((u8)0x03)
N#define GPIO_PinSource4            ((u8)0x04)
N#define GPIO_PinSource5            ((u8)0x05)
N#define GPIO_PinSource6            ((u8)0x06)
N#define GPIO_PinSource7            ((u8)0x07)
N#define GPIO_PinSource8            ((u8)0x08)
N#define GPIO_PinSource9            ((u8)0x09)
N#define GPIO_PinSource10           ((u8)0x0A)
N#define GPIO_PinSource11           ((u8)0x0B)
N#define GPIO_PinSource12           ((u8)0x0C)
N#define GPIO_PinSource13           ((u8)0x0D)
N#define GPIO_PinSource14           ((u8)0x0E)
N#define GPIO_PinSource15           ((u8)0x0F)
N
N#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) || \
N                                       ((PINSOURCE) == GPIO_PinSource1) || \
N                                       ((PINSOURCE) == GPIO_PinSource2) || \
N                                       ((PINSOURCE) == GPIO_PinSource3) || \
N                                       ((PINSOURCE) == GPIO_PinSource4) || \
N                                       ((PINSOURCE) == GPIO_PinSource5) || \
N                                       ((PINSOURCE) == GPIO_PinSource6) || \
N                                       ((PINSOURCE) == GPIO_PinSource7) || \
N                                       ((PINSOURCE) == GPIO_PinSource8) || \
N                                       ((PINSOURCE) == GPIO_PinSource9) || \
N                                       ((PINSOURCE) == GPIO_PinSource10) || \
N                                       ((PINSOURCE) == GPIO_PinSource11) || \
N                                       ((PINSOURCE) == GPIO_PinSource12) || \
N                                       ((PINSOURCE) == GPIO_PinSource13) || \
N                                       ((PINSOURCE) == GPIO_PinSource14) || \
N                                       ((PINSOURCE) == GPIO_PinSource15))
X#define IS_GPIO_PIN_SOURCE(PINSOURCE) (((PINSOURCE) == GPIO_PinSource0) ||                                        ((PINSOURCE) == GPIO_PinSource1) ||                                        ((PINSOURCE) == GPIO_PinSource2) ||                                        ((PINSOURCE) == GPIO_PinSource3) ||                                        ((PINSOURCE) == GPIO_PinSource4) ||                                        ((PINSOURCE) == GPIO_PinSource5) ||                                        ((PINSOURCE) == GPIO_PinSource6) ||                                        ((PINSOURCE) == GPIO_PinSource7) ||                                        ((PINSOURCE) == GPIO_PinSource8) ||                                        ((PINSOURCE) == GPIO_PinSource9) ||                                        ((PINSOURCE) == GPIO_PinSource10) ||                                        ((PINSOURCE) == GPIO_PinSource11) ||                                        ((PINSOURCE) == GPIO_PinSource12) ||                                        ((PINSOURCE) == GPIO_PinSource13) ||                                        ((PINSOURCE) == GPIO_PinSource14) ||                                        ((PINSOURCE) == GPIO_PinSource15))
N                          
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid GPIO_DeInit(GPIO_TypeDef* GPIOx);
Nvoid GPIO_AFIODeInit(void);
Nvoid GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
Nvoid GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);
Nu8 GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nu16 GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
Nu8 GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nu16 GPIO_ReadOutputData(GPIO_TypeDef* GPIOx);
Nvoid GPIO_SetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nvoid GPIO_ResetBits(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, u16 GPIO_Pin, BitAction BitVal);
Nvoid GPIO_Write(GPIO_TypeDef* GPIOx, u16 PortVal);
Nvoid GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, u16 GPIO_Pin);
Nvoid GPIO_EventOutputConfig(u8 GPIO_PortSource, u8 GPIO_PinSource);
Nvoid GPIO_EventOutputCmd(FunctionalState NewState);
Nvoid GPIO_PinRemapConfig(u32 GPIO_Remap, FunctionalState NewState);
Nvoid GPIO_EXTILineConfig(u8 GPIO_PortSource, u8 GPIO_PinSource);
N
N#endif /* __STM32F10x_GPIO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 68 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_GPIO */
N
N#ifdef _I2C
N  #include "stm32f10x_i2c.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_i2c.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_i2c.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      I2C firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_I2C_H    
N#define __STM32F10x_I2C_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* I2C Init structure definition */
Ntypedef struct
N{
N  u16 I2C_Mode;
N  u16 I2C_DutyCycle;
N  u16 I2C_OwnAddress1;
N  u16 I2C_Ack;
N  u16 I2C_AcknowledgedAddress;
N  u32 I2C_ClockSpeed;
N}I2C_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N#define IS_I2C_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == I2C1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == I2C2_BASE))
X#define IS_I2C_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == I2C1_BASE) ||                                    ((*(u32*)&(PERIPH)) == I2C2_BASE))
N
N/* I2C modes */
N#define I2C_Mode_I2C                    ((u16)0x0000)
N#define I2C_Mode_SMBusDevice            ((u16)0x0002)
N#define I2C_Mode_SMBusHost              ((u16)0x000A)
N
N#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) || \
N                           ((MODE) == I2C_Mode_SMBusDevice) || \
N                           ((MODE) == I2C_Mode_SMBusHost))
X#define IS_I2C_MODE(MODE) (((MODE) == I2C_Mode_I2C) ||                            ((MODE) == I2C_Mode_SMBusDevice) ||                            ((MODE) == I2C_Mode_SMBusHost))
N/* I2C duty cycle in fast mode */
N#define I2C_DutyCycle_16_9              ((u16)0x4000)
N#define I2C_DutyCycle_2                 ((u16)0xBFFF)
N
N#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) || \
N                                  ((CYCLE) == I2C_DutyCycle_2))
X#define IS_I2C_DUTY_CYCLE(CYCLE) (((CYCLE) == I2C_DutyCycle_16_9) ||                                   ((CYCLE) == I2C_DutyCycle_2))
N
N/* I2C cknowledgementy */
N#define I2C_Ack_Enable                  ((u16)0x0400)
N#define I2C_Ack_Disable                 ((u16)0x0000)
N
N#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) || \
N                                 ((STATE) == I2C_Ack_Disable))
X#define IS_I2C_ACK_STATE(STATE) (((STATE) == I2C_Ack_Enable) ||                                  ((STATE) == I2C_Ack_Disable))
N
N/* I2C transfer direction */
N#define  I2C_Direction_Transmitter      ((u8)0x00)
N#define  I2C_Direction_Receiver         ((u8)0x01)
N
N#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) || \
N                                     ((DIRECTION) == I2C_Direction_Receiver))
X#define IS_I2C_DIRECTION(DIRECTION) (((DIRECTION) == I2C_Direction_Transmitter) ||                                      ((DIRECTION) == I2C_Direction_Receiver))
N
N/* I2C acknowledged address defines */
N#define I2C_AcknowledgedAddress_7bit    ((u16)0x4000)
N#define I2C_AcknowledgedAddress_10bit   ((u16)0xC000)
N
N#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) || \
N                                             ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
X#define IS_I2C_ACKNOWLEDGE_ADDRESS(ADDRESS) (((ADDRESS) == I2C_AcknowledgedAddress_7bit) ||                                              ((ADDRESS) == I2C_AcknowledgedAddress_10bit))
N
N/* I2C registers */
N#define I2C_Register_CR1                ((u8)0x00)
N#define I2C_Register_CR2                ((u8)0x04)
N#define I2C_Register_OAR1               ((u8)0x08)
N#define I2C_Register_OAR2               ((u8)0x0C)
N#define I2C_Register_DR                 ((u8)0x10)
N#define I2C_Register_SR1                ((u8)0x14)
N#define I2C_Register_SR2                ((u8)0x18)
N#define I2C_Register_CCR                ((u8)0x1C)
N#define I2C_Register_TRISE              ((u8)0x20)
N
N#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) || \
N                                   ((REGISTER) == I2C_Register_CR2) || \
N                                   ((REGISTER) == I2C_Register_OAR1) || \
N                                   ((REGISTER) == I2C_Register_OAR2) || \
N                                   ((REGISTER) == I2C_Register_DR) || \
N                                   ((REGISTER) == I2C_Register_SR1) || \
N                                   ((REGISTER) == I2C_Register_SR2) || \
N                                   ((REGISTER) == I2C_Register_CCR) || \
N                                   ((REGISTER) == I2C_Register_TRISE))
X#define IS_I2C_REGISTER(REGISTER) (((REGISTER) == I2C_Register_CR1) ||                                    ((REGISTER) == I2C_Register_CR2) ||                                    ((REGISTER) == I2C_Register_OAR1) ||                                    ((REGISTER) == I2C_Register_OAR2) ||                                    ((REGISTER) == I2C_Register_DR) ||                                    ((REGISTER) == I2C_Register_SR1) ||                                    ((REGISTER) == I2C_Register_SR2) ||                                    ((REGISTER) == I2C_Register_CCR) ||                                    ((REGISTER) == I2C_Register_TRISE))
N
N/* I2C SMBus alert pin level */
N#define I2C_SMBusAlert_Low              ((u16)0x2000)
N#define I2C_SMBusAlert_High             ((u16)0xDFFF)
N
N#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) || \
N                                   ((ALERT) == I2C_SMBusAlert_High))
X#define IS_I2C_SMBUS_ALERT(ALERT) (((ALERT) == I2C_SMBusAlert_Low) ||                                    ((ALERT) == I2C_SMBusAlert_High))
N
N/* I2C PEC position */
N#define I2C_PECPosition_Next            ((u16)0x0800)
N#define I2C_PECPosition_Current         ((u16)0xF7FF)
N
N#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) || \
N                                       ((POSITION) == I2C_PECPosition_Current))
X#define IS_I2C_PEC_POSITION(POSITION) (((POSITION) == I2C_PECPosition_Next) ||                                        ((POSITION) == I2C_PECPosition_Current))
N
N/* I2C interrupts definition */
N#define I2C_IT_BUF                      ((u16)0x0400)
N#define I2C_IT_EVT                      ((u16)0x0200)
N#define I2C_IT_ERR                      ((u16)0x0100)
N
N#define IS_I2C_CONFIG_IT(IT) ((((IT) & (u16)0xF8FF) == 0x00) && ((IT) != 0x00))
N
N/* I2C interrupts definition */
N#define I2C_IT_SMBALERT                 ((u32)0x10008000)
N#define I2C_IT_TIMEOUT                  ((u32)0x10004000)
N#define I2C_IT_PECERR                   ((u32)0x10001000)
N#define I2C_IT_OVR                      ((u32)0x10000800)
N#define I2C_IT_AF                       ((u32)0x10000400)
N#define I2C_IT_ARLO                     ((u32)0x10000200)
N#define I2C_IT_BERR                     ((u32)0x10000100)
N#define I2C_IT_TXE                      ((u32)0x00000080)
N#define I2C_IT_RXNE                     ((u32)0x00000040)
N#define I2C_IT_STOPF                    ((u32)0x60000010)
N#define I2C_IT_ADD10                    ((u32)0x20000008)
N#define I2C_IT_BTF                      ((u32)0x60000004)
N#define I2C_IT_ADDR                     ((u32)0xA0000002)
N#define I2C_IT_SB                       ((u32)0x20000001)
N
N#define IS_I2C_CLEAR_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
N                             ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
N                             ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
N                             ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_STOPF) || \
N                             ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
N                             ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
X#define IS_I2C_CLEAR_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) ||                              ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) ||                              ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) ||                              ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_STOPF) ||                              ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) ||                              ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
N
N#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) || \
N                           ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) || \
N                           ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) || \
N                           ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) || \
N                           ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) || \
N                           ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) || \
N                           ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
X#define IS_I2C_GET_IT(IT) (((IT) == I2C_IT_SMBALERT) || ((IT) == I2C_IT_TIMEOUT) ||                            ((IT) == I2C_IT_PECERR) || ((IT) == I2C_IT_OVR) ||                            ((IT) == I2C_IT_AF) || ((IT) == I2C_IT_ARLO) ||                            ((IT) == I2C_IT_BERR) || ((IT) == I2C_IT_TXE) ||                            ((IT) == I2C_IT_RXNE) || ((IT) == I2C_IT_STOPF) ||                            ((IT) == I2C_IT_ADD10) || ((IT) == I2C_IT_BTF) ||                            ((IT) == I2C_IT_ADDR) || ((IT) == I2C_IT_SB))
N
N/* I2C flags definition */
N#define I2C_FLAG_DUALF                  ((u32)0x00800000)
N#define I2C_FLAG_SMBHOST                ((u32)0x00400000)
N#define I2C_FLAG_SMBDEFAULT             ((u32)0x00200000)
N#define I2C_FLAG_GENCALL                ((u32)0x00100000)
N#define I2C_FLAG_TRA                    ((u32)0x00040000)
N#define I2C_FLAG_BUSY                   ((u32)0x00020000)
N#define I2C_FLAG_MSL                    ((u32)0x00010000)
N#define I2C_FLAG_SMBALERT               ((u32)0x10008000)
N#define I2C_FLAG_TIMEOUT                ((u32)0x10004000)
N#define I2C_FLAG_PECERR                 ((u32)0x10001000)
N#define I2C_FLAG_OVR                    ((u32)0x10000800)
N#define I2C_FLAG_AF                     ((u32)0x10000400)
N#define I2C_FLAG_ARLO                   ((u32)0x10000200)
N#define I2C_FLAG_BERR                   ((u32)0x10000100)
N#define I2C_FLAG_TXE                    ((u32)0x00000080)
N#define I2C_FLAG_RXNE                   ((u32)0x00000040)
N#define I2C_FLAG_STOPF                  ((u32)0x60000010)
N#define I2C_FLAG_ADD10                  ((u32)0x20000008)
N#define I2C_FLAG_BTF                    ((u32)0x60000004)
N#define I2C_FLAG_ADDR                   ((u32)0xA0000002)
N#define I2C_FLAG_SB                     ((u32)0x20000001)
N
N#define IS_I2C_CLEAR_FLAG(FLAG) (((FLAG) == I2C_FLAG_SMBALERT) || ((FLAG) == I2C_FLAG_TIMEOUT) || \
N                                 ((FLAG) == I2C_FLAG_PECERR) || ((FLAG) == I2C_FLAG_OVR) || \
N                                 ((FLAG) == I2C_FLAG_AF) || ((FLAG) == I2C_FLAG_ARLO) || \
N                                 ((FLAG) == I2C_FLAG_BERR) || ((FLAG) == I2C_FLAG_STOPF) || \
N                                 ((FLAG) == I2C_FLAG_ADD10) || ((FLAG) == I2C_FLAG_BTF) || \
N                                 ((FLAG) == I2C_FLAG_ADDR) || ((FLAG) == I2C_FLAG_SB))
X#define IS_I2C_CLEAR_FLAG(FLAG) (((FLAG) == I2C_FLAG_SMBALERT) || ((FLAG) == I2C_FLAG_TIMEOUT) ||                                  ((FLAG) == I2C_FLAG_PECERR) || ((FLAG) == I2C_FLAG_OVR) ||                                  ((FLAG) == I2C_FLAG_AF) || ((FLAG) == I2C_FLAG_ARLO) ||                                  ((FLAG) == I2C_FLAG_BERR) || ((FLAG) == I2C_FLAG_STOPF) ||                                  ((FLAG) == I2C_FLAG_ADD10) || ((FLAG) == I2C_FLAG_BTF) ||                                  ((FLAG) == I2C_FLAG_ADDR) || ((FLAG) == I2C_FLAG_SB))
N
N#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) || \
N                               ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) || \
N                               ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) || \
N                               ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) || \
N                               ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) || \
N                               ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) || \
N                               ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) || \
N                               ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) || \
N                               ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) || \
N                               ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) || \
N                               ((FLAG) == I2C_FLAG_SB))
X#define IS_I2C_GET_FLAG(FLAG) (((FLAG) == I2C_FLAG_DUALF) || ((FLAG) == I2C_FLAG_SMBHOST) ||                                ((FLAG) == I2C_FLAG_SMBDEFAULT) || ((FLAG) == I2C_FLAG_GENCALL) ||                                ((FLAG) == I2C_FLAG_TRA) || ((FLAG) == I2C_FLAG_BUSY) ||                                ((FLAG) == I2C_FLAG_MSL) || ((FLAG) == I2C_FLAG_SMBALERT) ||                                ((FLAG) == I2C_FLAG_TIMEOUT) || ((FLAG) == I2C_FLAG_PECERR) ||                                ((FLAG) == I2C_FLAG_OVR) || ((FLAG) == I2C_FLAG_AF) ||                                ((FLAG) == I2C_FLAG_ARLO) || ((FLAG) == I2C_FLAG_BERR) ||                                ((FLAG) == I2C_FLAG_TXE) || ((FLAG) == I2C_FLAG_RXNE) ||                                ((FLAG) == I2C_FLAG_STOPF) || ((FLAG) == I2C_FLAG_ADD10) ||                                ((FLAG) == I2C_FLAG_BTF) || ((FLAG) == I2C_FLAG_ADDR) ||                                ((FLAG) == I2C_FLAG_SB))
N
N/* I2C Events */
N/* EV1 */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED       ((u32)0x00060082) /* TRA, BUSY, TXE and ADDR flags */
N#define  I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED          ((u32)0x00020002) /* BUSY and ADDR flags */
N#define  I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED ((u32)0x00860080)  /* DUALF, TRA, BUSY and TXE flags */
N#define  I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED    ((u32)0x00820000)  /* DUALF and BUSY flags */
N#define  I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED        ((u32)0x00120000)  /* GENCALL and BUSY flags */
N
N/* EV2 */
N#define  I2C_EVENT_SLAVE_BYTE_RECEIVED                     ((u32)0x00020040)  /* BUSY and RXNE flags */
N     
N/* EV3 */
N#define  I2C_EVENT_SLAVE_BYTE_TRANSMITTED                  ((u32)0x00060084)  /* TRA, BUSY, TXE and BTF flags */
N
N/* EV4 */
N#define  I2C_EVENT_SLAVE_STOP_DETECTED                     ((u32)0x00000010)  /* STOPF flag */
N
N/* EV5 */
N#define  I2C_EVENT_MASTER_MODE_SELECT                      ((u32)0x00030001)  /* BUSY, MSL and SB flag */
N
N/* EV6 */
N#define  I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED        ((u32)0x00070082)  /* BUSY, MSL, ADDR, TXE and TRA flags */
N#define  I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED           ((u32)0x00030002)  /* BUSY, MSL and ADDR flags */
N
N/* EV7 */
N#define  I2C_EVENT_MASTER_BYTE_RECEIVED                    ((u32)0x00030040)  /* BUSY, MSL and RXNE flags */
N
N/* EV8 */
N#define  I2C_EVENT_MASTER_BYTE_TRANSMITTED                 ((u32)0x00070084)  /* TRA, BUSY, MSL, TXE and BTF flags */
N      
N/* EV9 */
N#define  I2C_EVENT_MASTER_MODE_ADDRESS10                   ((u32)0x00030008)  /* BUSY, MSL and ADD10 flags */
N                                          
N/* EV3_2 */
N#define  I2C_EVENT_SLAVE_ACK_FAILURE                       ((u32)0x00000400)  /* AF flag */
N
N#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) || \
N                             ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) || \
N                             ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) || \
N                             ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) || \
N                             ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
X#define IS_I2C_EVENT(EVENT) (((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_RECEIVED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_RECEIVED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_BYTE_TRANSMITTED) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_DUALF)) ||                              ((EVENT) == (I2C_EVENT_SLAVE_BYTE_TRANSMITTED | I2C_FLAG_GENCALL)) ||                              ((EVENT) == I2C_EVENT_SLAVE_STOP_DETECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_SELECT) ||                              ((EVENT) == I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_RECEIVED) ||                              ((EVENT) == I2C_EVENT_MASTER_BYTE_TRANSMITTED) ||                              ((EVENT) == I2C_EVENT_MASTER_MODE_ADDRESS10) ||                              ((EVENT) == I2C_EVENT_SLAVE_ACK_FAILURE))
N
N/* I2C own address1 -----------------------------------------------------------*/
N#define IS_I2C_OWN_ADDRESS1(ADDRESS1) ((ADDRESS1) <= 0x3FF)
N/* I2C clock speed ------------------------------------------------------------*/
N#define IS_I2C_CLOCK_SPEED(SPEED) (((SPEED) >= 0x1) && ((SPEED) <= 400000))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid I2C_DeInit(I2C_TypeDef* I2Cx);
Nvoid I2C_Init(I2C_TypeDef* I2Cx, I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_StructInit(I2C_InitTypeDef* I2C_InitStruct);
Nvoid I2C_Cmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DMACmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_DMALastTransferCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTART(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GenerateSTOP(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_AcknowledgeConfig(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_OwnAddress2Config(I2C_TypeDef* I2Cx, u8 Address);
Nvoid I2C_DualAddressCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_GeneralCallCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_ITConfig(I2C_TypeDef* I2Cx, u16 I2C_IT, FunctionalState NewState);
Nvoid I2C_SendData(I2C_TypeDef* I2Cx, u8 Data);
Nu8 I2C_ReceiveData(I2C_TypeDef* I2Cx);
Nvoid I2C_Send7bitAddress(I2C_TypeDef* I2Cx, u8 Address, u8 I2C_Direction);
Nu16 I2C_ReadRegister(I2C_TypeDef* I2Cx, u8 I2C_Register);
Nvoid I2C_SoftwareResetCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_SMBusAlertConfig(I2C_TypeDef* I2Cx, u16 I2C_SMBusAlert);
Nvoid I2C_TransmitPEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_PECPositionConfig(I2C_TypeDef* I2Cx, u16 I2C_PECPosition);
Nvoid I2C_CalculatePEC(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nu8 I2C_GetPEC(I2C_TypeDef* I2Cx);
Nvoid I2C_ARPCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_StretchClockCmd(I2C_TypeDef* I2Cx, FunctionalState NewState);
Nvoid I2C_FastModeDutyCycleConfig(I2C_TypeDef* I2Cx, u16 I2C_DutyCycle);
Nu32 I2C_GetLastEvent(I2C_TypeDef* I2Cx);
NErrorStatus I2C_CheckEvent(I2C_TypeDef* I2Cx, u32 I2C_EVENT);
NFlagStatus I2C_GetFlagStatus(I2C_TypeDef* I2Cx, u32 I2C_FLAG);
Nvoid I2C_ClearFlag(I2C_TypeDef* I2Cx, u32 I2C_FLAG);
NITStatus I2C_GetITStatus(I2C_TypeDef* I2Cx, u32 I2C_IT);
Nvoid I2C_ClearITPendingBit(I2C_TypeDef* I2Cx, u32 I2C_IT);
N
N#endif /*__STM32F10x_I2C_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 72 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_I2C */
N
N#ifdef _IWDG
S  #include "stm32f10x_iwdg.h"
N#endif /*_IWDG */
N
N#ifdef _NVIC
N  #include "stm32f10x_nvic.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_nvic.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_nvic.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      NVIC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_NVIC_H
N#define __STM32F10x_NVIC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* NVIC Init Structure definition */
Ntypedef struct
N{
N  u8 NVIC_IRQChannel;
N  u8 NVIC_IRQChannelPreemptionPriority;
N  u8 NVIC_IRQChannelSubPriority;
N  FunctionalState NVIC_IRQChannelCmd;
N} NVIC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* IRQ Channels --------------------------------------------------------------*/
N#define WWDG_IRQChannel              ((u8)0x00)  /* Window WatchDog Interrupt */
N#define PVD_IRQChannel               ((u8)0x01)  /* PVD through EXTI Line detection Interrupt */
N#define TAMPER_IRQChannel            ((u8)0x02)  /* Tamper Interrupt */
N#define RTC_IRQChannel               ((u8)0x03)  /* RTC global Interrupt */
N#define FLASH_IRQChannel             ((u8)0x04)  /* FLASH global Interrupt */
N#define RCC_IRQChannel               ((u8)0x05)  /* RCC global Interrupt */
N#define EXTI0_IRQChannel             ((u8)0x06)  /* EXTI Line0 Interrupt */
N#define EXTI1_IRQChannel             ((u8)0x07)  /* EXTI Line1 Interrupt */
N#define EXTI2_IRQChannel             ((u8)0x08)  /* EXTI Line2 Interrupt */
N#define EXTI3_IRQChannel             ((u8)0x09)  /* EXTI Line3 Interrupt */
N#define EXTI4_IRQChannel             ((u8)0x0A)  /* EXTI Line4 Interrupt */
N#define DMA1_Channel1_IRQChannel     ((u8)0x0B)  /* DMA1 Channel 1 global Interrupt */
N#define DMA1_Channel2_IRQChannel     ((u8)0x0C)  /* DMA1 Channel 2 global Interrupt */
N#define DMA1_Channel3_IRQChannel     ((u8)0x0D)  /* DMA1 Channel 3 global Interrupt */
N#define DMA1_Channel4_IRQChannel     ((u8)0x0E)  /* DMA1 Channel 4 global Interrupt */
N#define DMA1_Channel5_IRQChannel     ((u8)0x0F)  /* DMA1 Channel 5 global Interrupt */
N#define DMA1_Channel6_IRQChannel     ((u8)0x10)  /* DMA1 Channel 6 global Interrupt */
N#define DMA1_Channel7_IRQChannel     ((u8)0x11)  /* DMA1 Channel 7 global Interrupt */
N#define ADC1_2_IRQChannel            ((u8)0x12)  /* ADC1 et ADC2 global Interrupt */
N#define USB_HP_CAN_TX_IRQChannel     ((u8)0x13)  /* USB High Priority or CAN TX Interrupts */
N#define USB_LP_CAN_RX0_IRQChannel    ((u8)0x14)  /* USB Low Priority or CAN RX0 Interrupts */
N#define CAN_RX1_IRQChannel           ((u8)0x15)  /* CAN RX1 Interrupt */
N#define CAN_SCE_IRQChannel           ((u8)0x16)  /* CAN SCE Interrupt */
N#define EXTI9_5_IRQChannel           ((u8)0x17)  /* External Line[9:5] Interrupts */
N#define TIM1_BRK_IRQChannel          ((u8)0x18)  /* TIM1 Break Interrupt */
N#define TIM1_UP_IRQChannel           ((u8)0x19)  /* TIM1 Update Interrupt */
N#define TIM1_TRG_COM_IRQChannel      ((u8)0x1A)  /* TIM1 Trigger and Commutation Interrupt */
N#define TIM1_CC_IRQChannel           ((u8)0x1B)  /* TIM1 Capture Compare Interrupt */
N#define TIM2_IRQChannel              ((u8)0x1C)  /* TIM2 global Interrupt */
N#define TIM3_IRQChannel              ((u8)0x1D)  /* TIM3 global Interrupt */
N#define TIM4_IRQChannel              ((u8)0x1E)  /* TIM4 global Interrupt */
N#define I2C1_EV_IRQChannel           ((u8)0x1F)  /* I2C1 Event Interrupt */
N#define I2C1_ER_IRQChannel           ((u8)0x20)  /* I2C1 Error Interrupt */
N#define I2C2_EV_IRQChannel           ((u8)0x21)  /* I2C2 Event Interrupt */
N#define I2C2_ER_IRQChannel           ((u8)0x22)  /* I2C2 Error Interrupt */
N#define SPI1_IRQChannel              ((u8)0x23)  /* SPI1 global Interrupt */
N#define SPI2_IRQChannel              ((u8)0x24)  /* SPI2 global Interrupt */
N#define USART1_IRQChannel            ((u8)0x25)  /* USART1 global Interrupt */
N#define USART2_IRQChannel            ((u8)0x26)  /* USART2 global Interrupt */
N#define USART3_IRQChannel            ((u8)0x27)  /* USART3 global Interrupt */
N#define EXTI15_10_IRQChannel         ((u8)0x28)  /* External Line[15:10] Interrupts */
N#define RTCAlarm_IRQChannel          ((u8)0x29)  /* RTC Alarm through EXTI Line Interrupt */
N#define USBWakeUp_IRQChannel         ((u8)0x2A)  /* USB WakeUp from suspend through EXTI Line Interrupt */
N#define TIM8_BRK_IRQChannel          ((u8)0x2B)  /* TIM8 Break Interrupt */
N#define TIM8_UP_IRQChannel           ((u8)0x2C)  /* TIM8 Update Interrupt */
N#define TIM8_TRG_COM_IRQChannel      ((u8)0x2D)  /* TIM8 Trigger and Commutation Interrupt */
N#define TIM8_CC_IRQChannel           ((u8)0x2E)  /* TIM8 Capture Compare Interrupt */
N#define ADC3_IRQChannel              ((u8)0x2F)  /* ADC3 global Interrupt */
N#define FSMC_IRQChannel              ((u8)0x30)  /* FSMC global Interrupt */
N#define SDIO_IRQChannel              ((u8)0x31)  /* SDIO global Interrupt */
N#define TIM5_IRQChannel              ((u8)0x32)  /* TIM5 global Interrupt */
N#define SPI3_IRQChannel              ((u8)0x33)  /* SPI3 global Interrupt */
N#define UART4_IRQChannel             ((u8)0x34)  /* UART4 global Interrupt */
N#define UART5_IRQChannel             ((u8)0x35)  /* UART5 global Interrupt */
N#define TIM6_IRQChannel              ((u8)0x36)  /* TIM6 global Interrupt */
N#define TIM7_IRQChannel              ((u8)0x37)  /* TIM7 global Interrupt */
N#define DMA2_Channel1_IRQChannel     ((u8)0x38)  /* DMA2 Channel 1 global Interrupt */
N#define DMA2_Channel2_IRQChannel     ((u8)0x39)  /* DMA2 Channel 2 global Interrupt */
N#define DMA2_Channel3_IRQChannel     ((u8)0x3A)  /* DMA2 Channel 3 global Interrupt */
N#define DMA2_Channel4_5_IRQChannel   ((u8)0x3B)  /* DMA2 Channel 4 and DMA2 Channel 5 global Interrupt */
N
N
N#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) || \
N                                      ((CHANNEL) == PVD_IRQChannel) || \
N                                      ((CHANNEL) == TAMPER_IRQChannel) || \
N                                      ((CHANNEL) == RTC_IRQChannel) || \
N                                      ((CHANNEL) == FLASH_IRQChannel) || \
N                                      ((CHANNEL) == RCC_IRQChannel) || \
N                                      ((CHANNEL) == EXTI0_IRQChannel) || \
N                                      ((CHANNEL) == EXTI1_IRQChannel) || \
N                                      ((CHANNEL) == EXTI2_IRQChannel) || \
N                                      ((CHANNEL) == EXTI3_IRQChannel) || \
N                                      ((CHANNEL) == EXTI4_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel1_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel2_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel3_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel4_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel5_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel6_IRQChannel) || \
N                                      ((CHANNEL) == DMA1_Channel7_IRQChannel) || \
N                                      ((CHANNEL) == ADC1_2_IRQChannel) || \
N                                      ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) || \
N                                      ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) || \
N                                      ((CHANNEL) == CAN_RX1_IRQChannel) || \
N                                      ((CHANNEL) == CAN_SCE_IRQChannel) || \
N                                      ((CHANNEL) == EXTI9_5_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_BRK_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_UP_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_TRG_COM_IRQChannel) || \
N                                      ((CHANNEL) == TIM1_CC_IRQChannel) || \
N                                      ((CHANNEL) == TIM2_IRQChannel) || \
N                                      ((CHANNEL) == TIM3_IRQChannel) || \
N                                      ((CHANNEL) == TIM4_IRQChannel) || \
N                                      ((CHANNEL) == I2C1_EV_IRQChannel) || \
N                                      ((CHANNEL) == I2C1_ER_IRQChannel) || \
N                                      ((CHANNEL) == I2C2_EV_IRQChannel) || \
N                                      ((CHANNEL) == I2C2_ER_IRQChannel) || \
N                                      ((CHANNEL) == SPI1_IRQChannel) || \
N                                      ((CHANNEL) == SPI2_IRQChannel) || \
N                                      ((CHANNEL) == USART1_IRQChannel) || \
N                                      ((CHANNEL) == USART2_IRQChannel) || \
N                                      ((CHANNEL) == USART3_IRQChannel) || \
N                                      ((CHANNEL) == EXTI15_10_IRQChannel) || \
N                                      ((CHANNEL) == RTCAlarm_IRQChannel) || \
N                                      ((CHANNEL) == USBWakeUp_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_BRK_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_UP_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_TRG_COM_IRQChannel) || \
N                                      ((CHANNEL) == TIM8_CC_IRQChannel) || \
N                                      ((CHANNEL) == ADC3_IRQChannel) || \
N                                      ((CHANNEL) == FSMC_IRQChannel) || \
N                                      ((CHANNEL) == SDIO_IRQChannel) || \
N                                      ((CHANNEL) == TIM5_IRQChannel) || \
N                                      ((CHANNEL) == SPI3_IRQChannel) || \
N                                      ((CHANNEL) == UART4_IRQChannel) || \
N                                      ((CHANNEL) == UART5_IRQChannel) || \
N                                      ((CHANNEL) == TIM6_IRQChannel) || \
N                                      ((CHANNEL) == TIM7_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel1_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel2_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel3_IRQChannel) || \
N                                      ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
X#define IS_NVIC_IRQ_CHANNEL(CHANNEL) (((CHANNEL) == WWDG_IRQChannel) ||                                       ((CHANNEL) == PVD_IRQChannel) ||                                       ((CHANNEL) == TAMPER_IRQChannel) ||                                       ((CHANNEL) == RTC_IRQChannel) ||                                       ((CHANNEL) == FLASH_IRQChannel) ||                                       ((CHANNEL) == RCC_IRQChannel) ||                                       ((CHANNEL) == EXTI0_IRQChannel) ||                                       ((CHANNEL) == EXTI1_IRQChannel) ||                                       ((CHANNEL) == EXTI2_IRQChannel) ||                                       ((CHANNEL) == EXTI3_IRQChannel) ||                                       ((CHANNEL) == EXTI4_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel1_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel2_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel3_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel4_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel5_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel6_IRQChannel) ||                                       ((CHANNEL) == DMA1_Channel7_IRQChannel) ||                                       ((CHANNEL) == ADC1_2_IRQChannel) ||                                       ((CHANNEL) == USB_HP_CAN_TX_IRQChannel) ||                                       ((CHANNEL) == USB_LP_CAN_RX0_IRQChannel) ||                                       ((CHANNEL) == CAN_RX1_IRQChannel) ||                                       ((CHANNEL) == CAN_SCE_IRQChannel) ||                                       ((CHANNEL) == EXTI9_5_IRQChannel) ||                                       ((CHANNEL) == TIM1_BRK_IRQChannel) ||                                       ((CHANNEL) == TIM1_UP_IRQChannel) ||                                       ((CHANNEL) == TIM1_TRG_COM_IRQChannel) ||                                       ((CHANNEL) == TIM1_CC_IRQChannel) ||                                       ((CHANNEL) == TIM2_IRQChannel) ||                                       ((CHANNEL) == TIM3_IRQChannel) ||                                       ((CHANNEL) == TIM4_IRQChannel) ||                                       ((CHANNEL) == I2C1_EV_IRQChannel) ||                                       ((CHANNEL) == I2C1_ER_IRQChannel) ||                                       ((CHANNEL) == I2C2_EV_IRQChannel) ||                                       ((CHANNEL) == I2C2_ER_IRQChannel) ||                                       ((CHANNEL) == SPI1_IRQChannel) ||                                       ((CHANNEL) == SPI2_IRQChannel) ||                                       ((CHANNEL) == USART1_IRQChannel) ||                                       ((CHANNEL) == USART2_IRQChannel) ||                                       ((CHANNEL) == USART3_IRQChannel) ||                                       ((CHANNEL) == EXTI15_10_IRQChannel) ||                                       ((CHANNEL) == RTCAlarm_IRQChannel) ||                                       ((CHANNEL) == USBWakeUp_IRQChannel) ||                                       ((CHANNEL) == TIM8_BRK_IRQChannel) ||                                       ((CHANNEL) == TIM8_UP_IRQChannel) ||                                       ((CHANNEL) == TIM8_TRG_COM_IRQChannel) ||                                       ((CHANNEL) == TIM8_CC_IRQChannel) ||                                       ((CHANNEL) == ADC3_IRQChannel) ||                                       ((CHANNEL) == FSMC_IRQChannel) ||                                       ((CHANNEL) == SDIO_IRQChannel) ||                                       ((CHANNEL) == TIM5_IRQChannel) ||                                       ((CHANNEL) == SPI3_IRQChannel) ||                                       ((CHANNEL) == UART4_IRQChannel) ||                                       ((CHANNEL) == UART5_IRQChannel) ||                                       ((CHANNEL) == TIM6_IRQChannel) ||                                       ((CHANNEL) == TIM7_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel1_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel2_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel3_IRQChannel) ||                                       ((CHANNEL) == DMA2_Channel4_5_IRQChannel))
N
N
N/* System Handlers -----------------------------------------------------------*/
N#define SystemHandler_NMI            ((u32)0x00001F) /* NMI Handler */
N#define SystemHandler_HardFault      ((u32)0x000000) /* Hard Fault Handler */
N#define SystemHandler_MemoryManage   ((u32)0x043430) /* Memory Manage Handler */
N#define SystemHandler_BusFault       ((u32)0x547931) /* Bus Fault Handler */
N#define SystemHandler_UsageFault     ((u32)0x24C232) /* Usage Fault Handler */
N#define SystemHandler_SVCall         ((u32)0x01FF40) /* SVCall Handler */
N#define SystemHandler_DebugMonitor   ((u32)0x0A0080) /* Debug Monitor Handler */
N#define SystemHandler_PSV            ((u32)0x02829C) /* PSV Handler */
N#define SystemHandler_SysTick        ((u32)0x02C39A) /* SysTick Handler */
N
N#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                           ((HANDLER) == SystemHandler_BusFault) || \
N                                           ((HANDLER) == SystemHandler_UsageFault))
X#define IS_CONFIG_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                            ((HANDLER) == SystemHandler_BusFault) ||                                            ((HANDLER) == SystemHandler_UsageFault))
N
N#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                             ((HANDLER) == SystemHandler_BusFault) || \
N                                             ((HANDLER) == SystemHandler_UsageFault) || \
N                                             ((HANDLER) == SystemHandler_SVCall) || \
N                                             ((HANDLER) == SystemHandler_DebugMonitor) || \
N                                             ((HANDLER) == SystemHandler_PSV) || \
N                                             ((HANDLER) == SystemHandler_SysTick))
X#define IS_PRIORITY_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                              ((HANDLER) == SystemHandler_BusFault) ||                                              ((HANDLER) == SystemHandler_UsageFault) ||                                              ((HANDLER) == SystemHandler_SVCall) ||                                              ((HANDLER) == SystemHandler_DebugMonitor) ||                                              ((HANDLER) == SystemHandler_PSV) ||                                              ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                                ((HANDLER) == SystemHandler_BusFault) || \
N                                                ((HANDLER) == SystemHandler_SVCall))
X#define IS_GET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                 ((HANDLER) == SystemHandler_BusFault) ||                                                 ((HANDLER) == SystemHandler_SVCall))
N
N#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) || \
N                                                ((HANDLER) == SystemHandler_PSV) || \
N                                                ((HANDLER) == SystemHandler_SysTick))
X#define IS_SET_PENDING_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_NMI) ||                                                 ((HANDLER) == SystemHandler_PSV) ||                                                 ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) || \
N                                          ((HANDLER) == SystemHandler_SysTick))
X#define IS_CLEAR_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_PSV) ||                                           ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                               ((HANDLER) == SystemHandler_BusFault) || \
N                                               ((HANDLER) == SystemHandler_UsageFault) || \
N                                               ((HANDLER) == SystemHandler_SVCall) || \
N                                               ((HANDLER) == SystemHandler_DebugMonitor) || \
N                                               ((HANDLER) == SystemHandler_PSV) || \
N                                               ((HANDLER) == SystemHandler_SysTick))
X#define IS_GET_ACTIVE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                ((HANDLER) == SystemHandler_BusFault) ||                                                ((HANDLER) == SystemHandler_UsageFault) ||                                                ((HANDLER) == SystemHandler_SVCall) ||                                                ((HANDLER) == SystemHandler_DebugMonitor) ||                                                ((HANDLER) == SystemHandler_PSV) ||                                                ((HANDLER) == SystemHandler_SysTick))
N
N#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) || \
N                                                 ((HANDLER) == SystemHandler_MemoryManage) || \
N                                                 ((HANDLER) == SystemHandler_BusFault) || \
N                                                 ((HANDLER) == SystemHandler_UsageFault) || \
N                                                 ((HANDLER) == SystemHandler_DebugMonitor)) 
X#define IS_FAULT_SOURCE_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_HardFault) ||                                                  ((HANDLER) == SystemHandler_MemoryManage) ||                                                  ((HANDLER) == SystemHandler_BusFault) ||                                                  ((HANDLER) == SystemHandler_UsageFault) ||                                                  ((HANDLER) == SystemHandler_DebugMonitor)) 
N
N#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) || \
N                                                  ((HANDLER) == SystemHandler_BusFault))
X#define IS_FAULT_ADDRESS_SYSTEM_HANDLER(HANDLER) (((HANDLER) == SystemHandler_MemoryManage) ||                                                   ((HANDLER) == SystemHandler_BusFault))
N
N
N/* Vector Table Base ---------------------------------------------------------*/
N#define NVIC_VectTab_RAM             ((u32)0x20000000)
N#define NVIC_VectTab_FLASH           ((u32)0x08000000)
N
N#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) || \
N                                  ((VECTTAB) == NVIC_VectTab_FLASH))
X#define IS_NVIC_VECTTAB(VECTTAB) (((VECTTAB) == NVIC_VectTab_RAM) ||                                   ((VECTTAB) == NVIC_VectTab_FLASH))
N
N/* System Low Power ----------------------------------------------------------*/
N#define NVIC_LP_SEVONPEND            ((u8)0x10)
N#define NVIC_LP_SLEEPDEEP            ((u8)0x04)
N#define NVIC_LP_SLEEPONEXIT          ((u8)0x02)
N
N#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) || \
N                        ((LP) == NVIC_LP_SLEEPDEEP) || \
N                        ((LP) == NVIC_LP_SLEEPONEXIT))
X#define IS_NVIC_LP(LP) (((LP) == NVIC_LP_SEVONPEND) ||                         ((LP) == NVIC_LP_SLEEPDEEP) ||                         ((LP) == NVIC_LP_SLEEPONEXIT))
N
N/* Preemption Priority Group -------------------------------------------------*/
N#define NVIC_PriorityGroup_0         ((u32)0x700) /* 0 bits for pre-emption priority
N                                                     4 bits for subpriority */
N#define NVIC_PriorityGroup_1         ((u32)0x600) /* 1 bits for pre-emption priority
N                                                     3 bits for subpriority */
N#define NVIC_PriorityGroup_2         ((u32)0x500) /* 2 bits for pre-emption priority
N                                                     2 bits for subpriority */
N#define NVIC_PriorityGroup_3         ((u32)0x400) /* 3 bits for pre-emption priority
N                                                     1 bits for subpriority */
N#define NVIC_PriorityGroup_4         ((u32)0x300) /* 4 bits for pre-emption priority
N                                                     0 bits for subpriority */
N
N#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
N                                       ((GROUP) == NVIC_PriorityGroup_1) || \
N                                       ((GROUP) == NVIC_PriorityGroup_2) || \
N                                       ((GROUP) == NVIC_PriorityGroup_3) || \
N                                       ((GROUP) == NVIC_PriorityGroup_4))
X#define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) ||                                        ((GROUP) == NVIC_PriorityGroup_1) ||                                        ((GROUP) == NVIC_PriorityGroup_2) ||                                        ((GROUP) == NVIC_PriorityGroup_3) ||                                        ((GROUP) == NVIC_PriorityGroup_4))
N
N#define IS_NVIC_PREEMPTION_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N#define IS_NVIC_SUB_PRIORITY(PRIORITY)  ((PRIORITY) < 0x10)
N#define IS_NVIC_OFFSET(OFFSET)  ((OFFSET) < 0x0007FFFF)
N#define IS_NVIC_BASE_PRI(PRI)   ((PRI) < 0x10)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid NVIC_DeInit(void);
Nvoid NVIC_SCBDeInit(void);
Nvoid NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup);
Nvoid NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct);
Nvoid NVIC_SETPRIMASK(void);
Nvoid NVIC_RESETPRIMASK(void);
Nvoid NVIC_SETFAULTMASK(void);
Nvoid NVIC_RESETFAULTMASK(void);
Nvoid NVIC_BASEPRICONFIG(u32 NewPriority);
Nu32 NVIC_GetBASEPRI(void);
Nu16 NVIC_GetCurrentPendingIRQChannel(void);
NITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel);
Nvoid NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel);
Nvoid NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel);
Nu16 NVIC_GetCurrentActiveHandler(void);
NITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel);
Nu32 NVIC_GetCPUID(void);
Nvoid NVIC_SetVectorTable(u32 NVIC_VectTab, u32 Offset);
Nvoid NVIC_GenerateSystemReset(void);
Nvoid NVIC_GenerateCoreReset(void);
Nvoid NVIC_SystemLPConfig(u8 LowPowerMode, FunctionalState NewState);
Nvoid NVIC_SystemHandlerConfig(u32 SystemHandler, FunctionalState NewState);
Nvoid NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
N                                      u8 SystemHandlerSubPriority);
NITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler);
Nvoid NVIC_SetSystemHandlerPendingBit(u32 SystemHandler);
Nvoid NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler);
NITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler);
Nu32 NVIC_GetFaultHandlerSources(u32 SystemHandler);
Nu32 NVIC_GetFaultAddress(u32 SystemHandler);
N
N#endif /* __STM32F10x_NVIC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 80 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_NVIC */
N
N#ifdef _PWR
N  #include "stm32f10x_pwr.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_pwr.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_pwr.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      PWR firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_PWR_H
N#define __STM32F10x_PWR_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* PVD detection level */
N#define PWR_PVDLevel_2V2          ((u32)0x00000000)
N#define PWR_PVDLevel_2V3          ((u32)0x00000020)
N#define PWR_PVDLevel_2V4          ((u32)0x00000040)
N#define PWR_PVDLevel_2V5          ((u32)0x00000060)
N#define PWR_PVDLevel_2V6          ((u32)0x00000080)
N#define PWR_PVDLevel_2V7          ((u32)0x000000A0)
N#define PWR_PVDLevel_2V8          ((u32)0x000000C0)
N#define PWR_PVDLevel_2V9          ((u32)0x000000E0)
N
N#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)|| \
N                                 ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
X#define IS_PWR_PVD_LEVEL(LEVEL) (((LEVEL) == PWR_PVDLevel_2V2) || ((LEVEL) == PWR_PVDLevel_2V3)||                                  ((LEVEL) == PWR_PVDLevel_2V4) || ((LEVEL) == PWR_PVDLevel_2V5)||                                  ((LEVEL) == PWR_PVDLevel_2V6) || ((LEVEL) == PWR_PVDLevel_2V7)||                                  ((LEVEL) == PWR_PVDLevel_2V8) || ((LEVEL) == PWR_PVDLevel_2V9))
N
N/* Regulator state is STOP mode */
N#define PWR_Regulator_ON          ((u32)0x00000000)
N#define PWR_Regulator_LowPower    ((u32)0x00000001)
N
N#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) || \
N                                     ((REGULATOR) == PWR_Regulator_LowPower))
X#define IS_PWR_REGULATOR(REGULATOR) (((REGULATOR) == PWR_Regulator_ON) ||                                      ((REGULATOR) == PWR_Regulator_LowPower))
N
N/* STOP mode entry */
N#define PWR_STOPEntry_WFI         ((u8)0x01)
N#define PWR_STOPEntry_WFE         ((u8)0x02)
N
N#define IS_PWR_STOP_ENTRY(ENTRY) (((ENTRY) == PWR_STOPEntry_WFI) || ((ENTRY) == PWR_STOPEntry_WFE))
N 
N/* PWR Flag */
N#define PWR_FLAG_WU               ((u32)0x00000001)
N#define PWR_FLAG_SB               ((u32)0x00000002)
N#define PWR_FLAG_PVDO             ((u32)0x00000004)
N
N#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) || \
N                               ((FLAG) == PWR_FLAG_PVDO))
X#define IS_PWR_GET_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB) ||                                ((FLAG) == PWR_FLAG_PVDO))
N#define IS_PWR_CLEAR_FLAG(FLAG) (((FLAG) == PWR_FLAG_WU) || ((FLAG) == PWR_FLAG_SB))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid PWR_DeInit(void);
Nvoid PWR_BackupAccessCmd(FunctionalState NewState);
Nvoid PWR_PVDCmd(FunctionalState NewState);
Nvoid PWR_PVDLevelConfig(u32 PWR_PVDLevel);
Nvoid PWR_WakeUpPinCmd(FunctionalState NewState);
Nvoid PWR_EnterSTOPMode(u32 PWR_Regulator, u8 PWR_STOPEntry);
Nvoid PWR_EnterSTANDBYMode(void);
NFlagStatus PWR_GetFlagStatus(u32 PWR_FLAG);
Nvoid PWR_ClearFlag(u32 PWR_FLAG);
N
N#endif /* __STM32F10x_PWR_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 84 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_PWR */
N
N#ifdef _RCC
N  #include "stm32f10x_rcc.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_rcc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_rcc.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      RCC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RCC_H
N#define __STM32F10x_RCC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
Ntypedef struct
N{
N  u32 SYSCLK_Frequency;
N  u32 HCLK_Frequency;
N  u32 PCLK1_Frequency;
N  u32 PCLK2_Frequency;
N  u32 ADCCLK_Frequency;
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* HSE configuration */
N#define RCC_HSE_OFF                      ((u32)0x00000000)
N#define RCC_HSE_ON                       ((u32)0x00010000)
N#define RCC_HSE_Bypass                   ((u32)0x00040000)
N
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/* PLL entry clock source */
N#define RCC_PLLSource_HSI_Div2           ((u32)0x00000000)
N#define RCC_PLLSource_HSE_Div1           ((u32)0x00010000)
N#define RCC_PLLSource_HSE_Div2           ((u32)0x00030000)
N
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div1) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div2))
N
N/* PLL multiplication factor */
N#define RCC_PLLMul_2                     ((u32)0x00000000)
N#define RCC_PLLMul_3                     ((u32)0x00040000)
N#define RCC_PLLMul_4                     ((u32)0x00080000)
N#define RCC_PLLMul_5                     ((u32)0x000C0000)
N#define RCC_PLLMul_6                     ((u32)0x00100000)
N#define RCC_PLLMul_7                     ((u32)0x00140000)
N#define RCC_PLLMul_8                     ((u32)0x00180000)
N#define RCC_PLLMul_9                     ((u32)0x001C0000)
N#define RCC_PLLMul_10                    ((u32)0x00200000)
N#define RCC_PLLMul_11                    ((u32)0x00240000)
N#define RCC_PLLMul_12                    ((u32)0x00280000)
N#define RCC_PLLMul_13                    ((u32)0x002C0000)
N#define RCC_PLLMul_14                    ((u32)0x00300000)
N#define RCC_PLLMul_15                    ((u32)0x00340000)
N#define RCC_PLLMul_16                    ((u32)0x00380000)
N
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
N
N/* System clock source */
N#define RCC_SYSCLKSource_HSI             ((u32)0x00000000)
N#define RCC_SYSCLKSource_HSE             ((u32)0x00000001)
N#define RCC_SYSCLKSource_PLLCLK          ((u32)0x00000002)
N
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N
N/* AHB clock source */
N#define RCC_SYSCLK_Div1                  ((u32)0x00000000)
N#define RCC_SYSCLK_Div2                  ((u32)0x00000080)
N#define RCC_SYSCLK_Div4                  ((u32)0x00000090)
N#define RCC_SYSCLK_Div8                  ((u32)0x000000A0)
N#define RCC_SYSCLK_Div16                 ((u32)0x000000B0)
N#define RCC_SYSCLK_Div64                 ((u32)0x000000C0)
N#define RCC_SYSCLK_Div128                ((u32)0x000000D0)
N#define RCC_SYSCLK_Div256                ((u32)0x000000E0)
N#define RCC_SYSCLK_Div512                ((u32)0x000000F0)
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N
N/* APB1/APB2 clock source */
N#define RCC_HCLK_Div1                    ((u32)0x00000000)
N#define RCC_HCLK_Div2                    ((u32)0x00000400)
N#define RCC_HCLK_Div4                    ((u32)0x00000500)
N#define RCC_HCLK_Div8                    ((u32)0x00000600)
N#define RCC_HCLK_Div16                   ((u32)0x00000700)
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N
N/* RCC Interrupt source */
N#define RCC_IT_LSIRDY                    ((u8)0x01)
N#define RCC_IT_LSERDY                    ((u8)0x02)
N#define RCC_IT_HSIRDY                    ((u8)0x04)
N#define RCC_IT_HSERDY                    ((u8)0x08)
N#define RCC_IT_PLLRDY                    ((u8)0x10)
N#define RCC_IT_CSS                       ((u8)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (u8)0xE0) == 0x00) && ((IT) != 0x00))
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
N#define IS_RCC_CLEAR_IT(IT) ((((IT) & (u8)0x60) == 0x00) && ((IT) != 0x00))
N
N/* USB clock source */
N#define RCC_USBCLKSource_PLLCLK_1Div5    ((u8)0x00)
N#define RCC_USBCLKSource_PLLCLK_Div1     ((u8)0x01)
N
N#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
N                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
X#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) ||                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
N
N/* ADC clock source */
N#define RCC_PCLK2_Div2                   ((u32)0x00000000)
N#define RCC_PCLK2_Div4                   ((u32)0x00004000)
N#define RCC_PCLK2_Div6                   ((u32)0x00008000)
N#define RCC_PCLK2_Div8                   ((u32)0x0000C000)
N
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
N                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) ||                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
N
N/* LSE configuration */
N#define RCC_LSE_OFF                      ((u8)0x00)
N#define RCC_LSE_ON                       ((u8)0x01)
N#define RCC_LSE_Bypass                   ((u8)0x04)
N
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N
N/* RTC clock source */
N#define RCC_RTCCLKSource_LSE             ((u32)0x00000100)
N#define RCC_RTCCLKSource_LSI             ((u32)0x00000200)
N#define RCC_RTCCLKSource_HSE_Div128      ((u32)0x00000300)
N
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
N
N/* AHB peripheral */
N#define RCC_AHBPeriph_DMA1               ((u32)0x00000001)
N#define RCC_AHBPeriph_DMA2               ((u32)0x00000002)
N#define RCC_AHBPeriph_SRAM               ((u32)0x00000004)
N#define RCC_AHBPeriph_FLITF              ((u32)0x00000010)
N#define RCC_AHBPeriph_CRC                ((u32)0x00000040)
N#define RCC_AHBPeriph_FSMC               ((u32)0x00000100)
N#define RCC_AHBPeriph_SDIO               ((u32)0x00000400)
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB2 peripheral */
N#define RCC_APB2Periph_AFIO              ((u32)0x00000001)
N#define RCC_APB2Periph_GPIOA             ((u32)0x00000004)
N#define RCC_APB2Periph_GPIOB             ((u32)0x00000008)
N#define RCC_APB2Periph_GPIOC             ((u32)0x00000010)
N#define RCC_APB2Periph_GPIOD             ((u32)0x00000020)
N#define RCC_APB2Periph_GPIOE             ((u32)0x00000040)
N#define RCC_APB2Periph_GPIOF             ((u32)0x00000080)
N#define RCC_APB2Periph_GPIOG             ((u32)0x00000100)
N#define RCC_APB2Periph_ADC1              ((u32)0x00000200)
N#define RCC_APB2Periph_ADC2              ((u32)0x00000400)
N#define RCC_APB2Periph_TIM1              ((u32)0x00000800)
N#define RCC_APB2Periph_SPI1              ((u32)0x00001000)
N#define RCC_APB2Periph_TIM8              ((u32)0x00002000)
N#define RCC_APB2Periph_USART1            ((u32)0x00004000)
N#define RCC_APB2Periph_ADC3              ((u32)0x00008000)
N#define RCC_APB2Periph_ALL               ((u32)0x0000FFFD)
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFF0002) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB1 peripheral */
N#define RCC_APB1Periph_TIM2              ((u32)0x00000001)
N#define RCC_APB1Periph_TIM3              ((u32)0x00000002)
N#define RCC_APB1Periph_TIM4              ((u32)0x00000004)
N#define RCC_APB1Periph_TIM5              ((u32)0x00000008)
N#define RCC_APB1Periph_TIM6              ((u32)0x00000010)
N#define RCC_APB1Periph_TIM7              ((u32)0x00000020)
N#define RCC_APB1Periph_WWDG              ((u32)0x00000800)
N#define RCC_APB1Periph_SPI2              ((u32)0x00004000)
N#define RCC_APB1Periph_SPI3              ((u32)0x00008000)
N#define RCC_APB1Periph_USART2            ((u32)0x00020000)
N#define RCC_APB1Periph_USART3            ((u32)0x00040000)
N#define RCC_APB1Periph_UART4             ((u32)0x00080000)
N#define RCC_APB1Periph_UART5             ((u32)0x00100000)
N#define RCC_APB1Periph_I2C1              ((u32)0x00200000)
N#define RCC_APB1Periph_I2C2              ((u32)0x00400000)
N#define RCC_APB1Periph_USB               ((u32)0x00800000)
N#define RCC_APB1Periph_CAN               ((u32)0x02000000)
N#define RCC_APB1Periph_BKP               ((u32)0x08000000)
N#define RCC_APB1Periph_PWR               ((u32)0x10000000)
N#define RCC_APB1Periph_DAC               ((u32)0x20000000)
N#define RCC_APB1Periph_ALL               ((u32)0x3AFEC83F)
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0xC50137C0) == 0x00) && ((PERIPH) != 0x00))
N
N/* Clock source to output on MCO pin */
N#define RCC_MCO_NoClock                  ((u8)0x00)
N#define RCC_MCO_SYSCLK                   ((u8)0x04)
N#define RCC_MCO_HSI                      ((u8)0x05)
N#define RCC_MCO_HSE                      ((u8)0x06)
N#define RCC_MCO_PLLCLK_Div2              ((u8)0x07)
N
N#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
N                         ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
N                         ((MCO) == RCC_MCO_PLLCLK_Div2))
X#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) ||                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) ||                          ((MCO) == RCC_MCO_PLLCLK_Div2))
N
N/* RCC Flag */
N#define RCC_FLAG_HSIRDY                  ((u8)0x20)
N#define RCC_FLAG_HSERDY                  ((u8)0x31)
N#define RCC_FLAG_PLLRDY                  ((u8)0x39)
N#define RCC_FLAG_LSERDY                  ((u8)0x41)
N#define RCC_FLAG_LSIRDY                  ((u8)0x61)
N#define RCC_FLAG_PINRST                  ((u8)0x7A)
N#define RCC_FLAG_PORRST                  ((u8)0x7B)
N#define RCC_FLAG_SFTRST                  ((u8)0x7C)
N#define RCC_FLAG_IWDGRST                 ((u8)0x7D)
N#define RCC_FLAG_WWDGRST                 ((u8)0x7E)
N#define RCC_FLAG_LPWRRST                 ((u8)0x7F)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
N                           ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
N                           ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
N                           ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
N                           ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
N                           ((FLAG) == RCC_FLAG_LPWRRST))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) ||                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) ||                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)||                            ((FLAG) == RCC_FLAG_LPWRRST))
N
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid RCC_DeInit(void);
Nvoid RCC_HSEConfig(u32 RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_SYSCLKConfig(u32 RCC_SYSCLKSource);
Nu8 RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(u32 RCC_SYSCLK);
Nvoid RCC_PCLK1Config(u32 RCC_HCLK);
Nvoid RCC_PCLK2Config(u32 RCC_HCLK);
Nvoid RCC_ITConfig(u8 RCC_IT, FunctionalState NewState);
Nvoid RCC_USBCLKConfig(u32 RCC_USBCLKSource);
Nvoid RCC_ADCCLKConfig(u32 RCC_PCLK2);
Nvoid RCC_LSEConfig(u8 RCC_LSE);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_RTCCLKConfig(u32 RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
Nvoid RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_MCOConfig(u8 RCC_MCO);
NFlagStatus RCC_GetFlagStatus(u8 RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(u8 RCC_IT);
Nvoid RCC_ClearITPendingBit(u8 RCC_IT);
N
N#endif /* __STM32F10x_RCC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 88 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_RCC */
N
N#ifdef _RTC
N  #include "stm32f10x_rtc.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_rtc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_rtc.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      RTC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RTC_H
N#define __STM32F10x_RTC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* RTC interrupts define -----------------------------------------------------*/
N#define RTC_IT_OW            ((u16)0x0004)  /* Overflow interrupt */
N#define RTC_IT_ALR           ((u16)0x0002)  /* Alarm interrupt */
N#define RTC_IT_SEC           ((u16)0x0001)  /* Second interrupt */
N
N#define IS_RTC_IT(IT) ((((IT) & (u16)0xFFF8) == 0x00) && ((IT) != 0x00))
N
N#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) || \
N                           ((IT) == RTC_IT_SEC))
X#define IS_RTC_GET_IT(IT) (((IT) == RTC_IT_OW) || ((IT) == RTC_IT_ALR) ||                            ((IT) == RTC_IT_SEC))
N                                                                     
N/* RTC interrupts flags ------------------------------------------------------*/
N#define RTC_FLAG_RTOFF       ((u16)0x0020)  /* RTC Operation OFF flag */
N#define RTC_FLAG_RSF         ((u16)0x0008)  /* Registers Synchronized flag */
N#define RTC_FLAG_OW          ((u16)0x0004)  /* Overflow flag */
N#define RTC_FLAG_ALR         ((u16)0x0002)  /* Alarm flag */
N#define RTC_FLAG_SEC         ((u16)0x0001)  /* Second flag */
N
N#define IS_RTC_CLEAR_FLAG(FLAG) ((((FLAG) & (u16)0xFFF0) == 0x00) && ((FLAG) != 0x00))
N
N#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) || \
N                               ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) || \
N                               ((FLAG) == RTC_FLAG_SEC))
X#define IS_RTC_GET_FLAG(FLAG) (((FLAG) == RTC_FLAG_RTOFF) || ((FLAG) == RTC_FLAG_RSF) ||                                ((FLAG) == RTC_FLAG_OW) || ((FLAG) == RTC_FLAG_ALR) ||                                ((FLAG) == RTC_FLAG_SEC))
N
N#define IS_RTC_PRESCALER(PRESCALER) ((PRESCALER) <= 0xFFFFF)
N                           
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid RTC_ITConfig(u16 RTC_IT, FunctionalState NewState);
Nvoid RTC_EnterConfigMode(void);
Nvoid RTC_ExitConfigMode(void);
Nu32  RTC_GetCounter(void);
Nvoid RTC_SetCounter(u32 CounterValue);
Nvoid RTC_SetPrescaler(u32 PrescalerValue);
Nvoid RTC_SetAlarm(u32 AlarmValue);
Nu32  RTC_GetDivider(void);
Nvoid RTC_WaitForLastTask(void);
Nvoid RTC_WaitForSynchro(void);
NFlagStatus RTC_GetFlagStatus(u16 RTC_FLAG);
Nvoid RTC_ClearFlag(u16 RTC_FLAG);
NITStatus RTC_GetITStatus(u16 RTC_IT);
Nvoid RTC_ClearITPendingBit(u16 RTC_IT);
N
N#endif /* __STM32F10x_RTC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 92 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_RTC */
N
N#ifdef _SDIO
S  #include "stm32f10x_sdio.h"
N#endif /*_SDIO */
N
N#ifdef _SPI
N  #include "stm32f10x_spi.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_spi.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_spi.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      SPI firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_SPI_H
N#define __STM32F10x_SPI_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* SPI Init structure definition */
Ntypedef struct
N{
N  u16 SPI_Direction;
N  u16 SPI_Mode;
N  u16 SPI_DataSize;
N  u16 SPI_CPOL;
N  u16 SPI_CPHA;
N  u16 SPI_NSS;
N  u16 SPI_BaudRatePrescaler;
N  u16 SPI_FirstBit;
N  u16 SPI_CRCPolynomial;
N}SPI_InitTypeDef;
N
N/* I2S Init structure definition */
Ntypedef struct
N{
N  u16 I2S_Mode;
N  u16 I2S_Standard;
N  u16 I2S_DataFormat;
N  u16 I2S_MCLKOutput;
N  u16 I2S_AudioFreq;
N  u16 I2S_CPOL;
N}I2S_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N
N#define IS_SPI_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == SPI1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == SPI2_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == SPI3_BASE))
X#define IS_SPI_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == SPI1_BASE) ||                                    ((*(u32*)&(PERIPH)) == SPI2_BASE) ||                                    ((*(u32*)&(PERIPH)) == SPI3_BASE))
N
N#define IS_SPI_23_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == SPI2_BASE) || \
N                                  ((*(u32*)&(PERIPH)) == SPI3_BASE))
X#define IS_SPI_23_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == SPI2_BASE) ||                                   ((*(u32*)&(PERIPH)) == SPI3_BASE))
N
N/* SPI data direction mode */
N#define SPI_Direction_2Lines_FullDuplex ((u16)0x0000)
N#define SPI_Direction_2Lines_RxOnly     ((u16)0x0400)
N#define SPI_Direction_1Line_Rx          ((u16)0x8000)
N#define SPI_Direction_1Line_Tx          ((u16)0xC000)
N
N#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
N                                     ((MODE) == SPI_Direction_2Lines_RxOnly) || \
N                                     ((MODE) == SPI_Direction_1Line_Rx) || \
N                                     ((MODE) == SPI_Direction_1Line_Tx))
X#define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) ||                                      ((MODE) == SPI_Direction_2Lines_RxOnly) ||                                      ((MODE) == SPI_Direction_1Line_Rx) ||                                      ((MODE) == SPI_Direction_1Line_Tx))
N
N/* SPI master/slave mode */
N#define SPI_Mode_Master                 ((u16)0x0104)
N#define SPI_Mode_Slave                  ((u16)0x0000)
N
N#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
N                           ((MODE) == SPI_Mode_Slave))
X#define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) ||                            ((MODE) == SPI_Mode_Slave))
N
N/* SPI data size */
N#define SPI_DataSize_16b                ((u16)0x0800)
N#define SPI_DataSize_8b                 ((u16)0x0000)
N
N#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
N                                   ((DATASIZE) == SPI_DataSize_8b))
X#define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) ||                                    ((DATASIZE) == SPI_DataSize_8b))
N
N/* SPI Clock Polarity */
N#define SPI_CPOL_Low                    ((u16)0x0000)
N#define SPI_CPOL_High                   ((u16)0x0002)
N
N#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
N                           ((CPOL) == SPI_CPOL_High))
X#define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) ||                            ((CPOL) == SPI_CPOL_High))
N
N/* SPI Clock Phase */
N#define SPI_CPHA_1Edge                  ((u16)0x0000)
N#define SPI_CPHA_2Edge                  ((u16)0x0001)
N
N#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
N                           ((CPHA) == SPI_CPHA_2Edge))
X#define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) ||                            ((CPHA) == SPI_CPHA_2Edge))
N
N/* SPI Slave Select management */
N#define SPI_NSS_Soft                    ((u16)0x0200)
N#define SPI_NSS_Hard                    ((u16)0x0000)
N
N#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
N                         ((NSS) == SPI_NSS_Hard))                         
X#define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) ||                          ((NSS) == SPI_NSS_Hard))                         
N
N/* SPI BaudRate Prescaler  */
N#define SPI_BaudRatePrescaler_2         ((u16)0x0000)
N#define SPI_BaudRatePrescaler_4         ((u16)0x0008)
N#define SPI_BaudRatePrescaler_8         ((u16)0x0010)
N#define SPI_BaudRatePrescaler_16        ((u16)0x0018)
N#define SPI_BaudRatePrescaler_32        ((u16)0x0020)
N#define SPI_BaudRatePrescaler_64        ((u16)0x0028)
N#define SPI_BaudRatePrescaler_128       ((u16)0x0030)
N#define SPI_BaudRatePrescaler_256       ((u16)0x0038)
N
N#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_4) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_8) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_16) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_32) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_64) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_128) || \
N                                              ((PRESCALER) == SPI_BaudRatePrescaler_256))
X#define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_4) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_8) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_16) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_32) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_64) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_128) ||                                               ((PRESCALER) == SPI_BaudRatePrescaler_256))
N
N/* SPI MSB/LSB transmission */
N#define SPI_FirstBit_MSB                ((u16)0x0000)
N#define SPI_FirstBit_LSB                ((u16)0x0080)
N
N#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
N                               ((BIT) == SPI_FirstBit_LSB))
X#define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) ||                                ((BIT) == SPI_FirstBit_LSB))
N
N/* I2S Mode */
N#define I2S_Mode_SlaveTx                ((u16)0x0000)
N#define I2S_Mode_SlaveRx                ((u16)0x0100)
N#define I2S_Mode_MasterTx               ((u16)0x0200)
N#define I2S_Mode_MasterRx               ((u16)0x0300)
N
N#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) || \
N                           ((MODE) == I2S_Mode_SlaveRx) || \
N                           ((MODE) == I2S_Mode_MasterTx) || \
N                           ((MODE) == I2S_Mode_MasterRx) )
X#define IS_I2S_MODE(MODE) (((MODE) == I2S_Mode_SlaveTx) ||                            ((MODE) == I2S_Mode_SlaveRx) ||                            ((MODE) == I2S_Mode_MasterTx) ||                            ((MODE) == I2S_Mode_MasterRx) )
N
N/* I2S Standard */
N#define I2S_Standard_Phillips           ((u16)0x0000)
N#define I2S_Standard_MSB                ((u16)0x0010)
N#define I2S_Standard_LSB                ((u16)0x0020)
N#define I2S_Standard_PCMShort           ((u16)0x0030)
N#define I2S_Standard_PCMLong            ((u16)0x00B0)
N
N#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) || \
N                                   ((STANDARD) == I2S_Standard_MSB) || \
N                                   ((STANDARD) == I2S_Standard_LSB) || \
N                                   ((STANDARD) == I2S_Standard_PCMShort) || \
N                                   ((STANDARD) == I2S_Standard_PCMLong))
X#define IS_I2S_STANDARD(STANDARD) (((STANDARD) == I2S_Standard_Phillips) ||                                    ((STANDARD) == I2S_Standard_MSB) ||                                    ((STANDARD) == I2S_Standard_LSB) ||                                    ((STANDARD) == I2S_Standard_PCMShort) ||                                    ((STANDARD) == I2S_Standard_PCMLong))
N
N/* I2S Data Format */
N#define I2S_DataFormat_16b              ((u16)0x0000)
N#define I2S_DataFormat_16bextended      ((u16)0x0001)
N#define I2S_DataFormat_24b              ((u16)0x0003)
N#define I2S_DataFormat_32b              ((u16)0x0005)
N
N#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) || \
N                                    ((FORMAT) == I2S_DataFormat_16bextended) || \
N                                    ((FORMAT) == I2S_DataFormat_24b) || \
N                                    ((FORMAT) == I2S_DataFormat_32b))
X#define IS_I2S_DATA_FORMAT(FORMAT) (((FORMAT) == I2S_DataFormat_16b) ||                                     ((FORMAT) == I2S_DataFormat_16bextended) ||                                     ((FORMAT) == I2S_DataFormat_24b) ||                                     ((FORMAT) == I2S_DataFormat_32b))
N
N/* I2S MCLK Output */ 
N#define I2S_MCLKOutput_Enable           ((u16)0x0200)
N#define I2S_MCLKOutput_Disable          ((u16)0x0000)
N
N#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) || \
N                                    ((OUTPUT) == I2S_MCLKOutput_Disable))
X#define IS_I2S_MCLK_OUTPUT(OUTPUT) (((OUTPUT) == I2S_MCLKOutput_Enable) ||                                     ((OUTPUT) == I2S_MCLKOutput_Disable))
N
N/* I2S Audio Frequency */
N#define I2S_AudioFreq_48k                ((u16)48000)
N#define I2S_AudioFreq_44k                ((u16)44100)
N#define I2S_AudioFreq_22k                ((u16)22050)
N#define I2S_AudioFreq_16k                ((u16)16000)
N#define I2S_AudioFreq_8k                 ((u16)8000)
N#define I2S_AudioFreq_Default            ((u16)2)
N
N#define IS_I2S_AUDIO_FREQ(FREQ) (((FREQ) == I2S_AudioFreq_48k) || \
N                                 ((FREQ) == I2S_AudioFreq_44k) || \
N                                 ((FREQ) == I2S_AudioFreq_22k) || \
N                                 ((FREQ) == I2S_AudioFreq_16k) || \
N                                 ((FREQ) == I2S_AudioFreq_8k)  || \
N                                 ((FREQ) == I2S_AudioFreq_Default))
X#define IS_I2S_AUDIO_FREQ(FREQ) (((FREQ) == I2S_AudioFreq_48k) ||                                  ((FREQ) == I2S_AudioFreq_44k) ||                                  ((FREQ) == I2S_AudioFreq_22k) ||                                  ((FREQ) == I2S_AudioFreq_16k) ||                                  ((FREQ) == I2S_AudioFreq_8k)  ||                                  ((FREQ) == I2S_AudioFreq_Default))
N
N/* I2S Clock Polarity */
N#define I2S_CPOL_Low                    ((u16)0x0000)
N#define I2S_CPOL_High                   ((u16)0x0008)
N
N#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) || \
N                           ((CPOL) == I2S_CPOL_High))
X#define IS_I2S_CPOL(CPOL) (((CPOL) == I2S_CPOL_Low) ||                            ((CPOL) == I2S_CPOL_High))
N
N/* SPI_I2S DMA transfer requests */
N#define SPI_I2S_DMAReq_Tx               ((u16)0x0002)
N#define SPI_I2S_DMAReq_Rx               ((u16)0x0001)
N
N#define IS_SPI_I2S_DMAREQ(DMAREQ) ((((DMAREQ) & (u16)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))
N
N/* SPI NSS internal software mangement */
N#define SPI_NSSInternalSoft_Set         ((u16)0x0100)
N#define SPI_NSSInternalSoft_Reset       ((u16)0xFEFF)
N
N#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) || \
N                                       ((INTERNAL) == SPI_NSSInternalSoft_Reset))
X#define IS_SPI_NSS_INTERNAL(INTERNAL) (((INTERNAL) == SPI_NSSInternalSoft_Set) ||                                        ((INTERNAL) == SPI_NSSInternalSoft_Reset))
N
N/* SPI CRC Transmit/Receive */
N#define SPI_CRC_Tx                      ((u8)0x00)
N#define SPI_CRC_Rx                      ((u8)0x01)
N
N#define IS_SPI_CRC(CRC) (((CRC) == SPI_CRC_Tx) || ((CRC) == SPI_CRC_Rx))
N
N/* SPI direction transmit/receive */
N#define SPI_Direction_Rx                ((u16)0xBFFF)
N#define SPI_Direction_Tx                ((u16)0x4000)
N
N#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) || \
N                                     ((DIRECTION) == SPI_Direction_Tx))
X#define IS_SPI_DIRECTION(DIRECTION) (((DIRECTION) == SPI_Direction_Rx) ||                                      ((DIRECTION) == SPI_Direction_Tx))
N
N/* SPI_I2S interrupts definition */
N#define SPI_I2S_IT_TXE                  ((u8)0x71)
N#define SPI_I2S_IT_RXNE                 ((u8)0x60)
N#define SPI_I2S_IT_ERR                  ((u8)0x50)
N
N#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) || \
N                                 ((IT) == SPI_I2S_IT_RXNE) || \
N                                 ((IT) == SPI_I2S_IT_ERR))
X#define IS_SPI_I2S_CONFIG_IT(IT) (((IT) == SPI_I2S_IT_TXE) ||                                  ((IT) == SPI_I2S_IT_RXNE) ||                                  ((IT) == SPI_I2S_IT_ERR))
N
N#define SPI_I2S_IT_OVR                  ((u8)0x56)
N#define SPI_IT_MODF                     ((u8)0x55)
N#define SPI_IT_CRCERR                   ((u8)0x54)
N#define I2S_IT_UDR                      ((u8)0x53)
N
N#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_I2S_IT_OVR) || \
N                                 ((IT) == SPI_IT_MODF) || \
N                                 ((IT) == SPI_IT_CRCERR) || \
N                                 ((IT) == I2S_IT_UDR))
X#define IS_SPI_I2S_CLEAR_IT(IT) (((IT) == SPI_I2S_IT_OVR) ||                                  ((IT) == SPI_IT_MODF) ||                                  ((IT) == SPI_IT_CRCERR) ||                                  ((IT) == I2S_IT_UDR))
N
N#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) || \
N                               ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) || \
N                               ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
X#define IS_SPI_I2S_GET_IT(IT) (((IT) == SPI_I2S_IT_RXNE) || ((IT) == SPI_I2S_IT_TXE) ||                                ((IT) == I2S_IT_UDR) || ((IT) == SPI_IT_CRCERR) ||                                ((IT) == SPI_IT_MODF) || ((IT) == SPI_I2S_IT_OVR))
N
N/* SPI_I2S flags definition */
N#define SPI_I2S_FLAG_RXNE               ((u16)0x0001)
N#define SPI_I2S_FLAG_TXE                ((u16)0x0002)
N#define I2S_FLAG_CHSIDE                 ((u16)0x0004)
N#define I2S_FLAG_UDR                    ((u16)0x0008)
N#define SPI_FLAG_CRCERR                 ((u16)0x0010)
N#define SPI_FLAG_MODF                   ((u16)0x0020)
N#define SPI_I2S_FLAG_OVR                ((u16)0x0040)
N#define SPI_I2S_FLAG_BSY                ((u16)0x0080)
N
N#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_OVR) || ((FLAG) == SPI_FLAG_MODF) || \
N                                     ((FLAG) == SPI_FLAG_CRCERR) || ((FLAG) == I2S_FLAG_UDR))
X#define IS_SPI_I2S_CLEAR_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_OVR) || ((FLAG) == SPI_FLAG_MODF) ||                                      ((FLAG) == SPI_FLAG_CRCERR) || ((FLAG) == I2S_FLAG_UDR))
N#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) || \
N                                   ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) || \
N                                   ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) || \
N                                   ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
X#define IS_SPI_I2S_GET_FLAG(FLAG) (((FLAG) == SPI_I2S_FLAG_BSY) || ((FLAG) == SPI_I2S_FLAG_OVR) ||                                    ((FLAG) == SPI_FLAG_MODF) || ((FLAG) == SPI_FLAG_CRCERR) ||                                    ((FLAG) == I2S_FLAG_UDR) || ((FLAG) == I2S_FLAG_CHSIDE) ||                                    ((FLAG) == SPI_I2S_FLAG_TXE) || ((FLAG) == SPI_I2S_FLAG_RXNE))
N
N/* SPI CRC polynomial --------------------------------------------------------*/
N#define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid SPI_I2S_DeInit(SPI_TypeDef* SPIx);
Nvoid SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct);
Nvoid I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct);
Nvoid SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_I2S_ITConfig(SPI_TypeDef* SPIx, u8 SPI_I2S_IT, FunctionalState NewState);
Nvoid SPI_I2S_DMACmd(SPI_TypeDef* SPIx, u16 SPI_I2S_DMAReq, FunctionalState NewState);
Nvoid SPI_I2S_SendData(SPI_TypeDef* SPIx, u16 Data);
Nu16 SPI_I2S_ReceiveData(SPI_TypeDef* SPIx);
Nvoid SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, u16 SPI_NSSInternalSoft);
Nvoid SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
Nvoid SPI_DataSizeConfig(SPI_TypeDef* SPIx, u16 SPI_DataSize);
Nvoid SPI_TransmitCRC(SPI_TypeDef* SPIx);
Nvoid SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState);
Nu16 SPI_GetCRC(SPI_TypeDef* SPIx, u8 SPI_CRC);
Nu16 SPI_GetCRCPolynomial(SPI_TypeDef* SPIx);
Nvoid SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, u16 SPI_Direction);
NFlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG);
Nvoid SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, u16 SPI_I2S_FLAG);
NITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, u8 SPI_I2S_IT);
Nvoid SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, u8 SPI_I2S_IT);
N
N#endif /*__STM32F10x_SPI_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 100 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_SPI */
N
N#ifdef _SysTick
N  #include "stm32f10x_systick.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_systick.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_systick.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      SysTick firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_SYSTICK_H
N#define __STM32F10x_SYSTICK_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* SysTick clock source */
N#define SysTick_CLKSource_HCLK_Div8    ((u32)0xFFFFFFFB)
N#define SysTick_CLKSource_HCLK         ((u32)0x00000004)
N
N#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
N                                       ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
X#define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) ||                                        ((SOURCE) == SysTick_CLKSource_HCLK_Div8))
N
N/* SysTick counter state */
N#define SysTick_Counter_Disable        ((u32)0xFFFFFFFE)
N#define SysTick_Counter_Enable         ((u32)0x00000001)
N#define SysTick_Counter_Clear          ((u32)0x00000000)
N
N#define IS_SYSTICK_COUNTER(COUNTER) (((COUNTER) == SysTick_Counter_Disable) || \
N                                     ((COUNTER) == SysTick_Counter_Enable)  || \
N                                     ((COUNTER) == SysTick_Counter_Clear))
X#define IS_SYSTICK_COUNTER(COUNTER) (((COUNTER) == SysTick_Counter_Disable) ||                                      ((COUNTER) == SysTick_Counter_Enable)  ||                                      ((COUNTER) == SysTick_Counter_Clear))
N
N/* SysTick Flag */
N#define SysTick_FLAG_COUNT             ((u32)0x00000010)
N#define SysTick_FLAG_SKEW              ((u32)0x0000001E)
N#define SysTick_FLAG_NOREF             ((u32)0x0000001F)
N
N#define IS_SYSTICK_FLAG(FLAG) (((FLAG) == SysTick_FLAG_COUNT) || \
N                               ((FLAG) == SysTick_FLAG_SKEW)  || \
N                               ((FLAG) == SysTick_FLAG_NOREF))
X#define IS_SYSTICK_FLAG(FLAG) (((FLAG) == SysTick_FLAG_COUNT) ||                                ((FLAG) == SysTick_FLAG_SKEW)  ||                                ((FLAG) == SysTick_FLAG_NOREF))
N
N#define IS_SYSTICK_RELOAD(RELOAD) (((RELOAD) > 0) && ((RELOAD) <= 0xFFFFFF))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid SysTick_CLKSourceConfig(u32 SysTick_CLKSource);
Nvoid SysTick_SetReload(u32 Reload);
Nvoid SysTick_CounterCmd(u32 SysTick_Counter);
Nvoid SysTick_ITConfig(FunctionalState NewState);
Nu32 SysTick_GetCounter(void);
NFlagStatus SysTick_GetFlagStatus(u8 SysTick_FLAG);
N
N#endif /* __STM32F10x_SYSTICK_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 104 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_SysTick */
N
N#ifdef _TIM
N  #include "stm32f10x_tim.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_tim.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_tim.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the 
N*                      TIM firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TIM_H
N#define __STM32F10x_TIM_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N
N/* TIM Time Base Init structure definition */
Ntypedef struct
N{
N  u16 TIM_Prescaler;
N  u16 TIM_CounterMode;
N  u16 TIM_Period;
N  u16 TIM_ClockDivision;
N  u8 TIM_RepetitionCounter;
N} TIM_TimeBaseInitTypeDef;
N
N/* TIM Output Compare Init structure definition */
Ntypedef struct
N{
N  u16 TIM_OCMode;
N  u16 TIM_OutputState;
N  u16 TIM_OutputNState;
N  u16 TIM_Pulse;
N  u16 TIM_OCPolarity;
N  u16 TIM_OCNPolarity;
N  u16 TIM_OCIdleState;
N  u16 TIM_OCNIdleState;
N} TIM_OCInitTypeDef;
N
N/* TIM Input Capture Init structure definition */
Ntypedef struct
N{
N  u16 TIM_Channel;
N  u16 TIM_ICPolarity;
N  u16 TIM_ICSelection;
N  u16 TIM_ICPrescaler;
N  u16 TIM_ICFilter;
N} TIM_ICInitTypeDef;
N
N/* BDTR structure definition */
Ntypedef struct
N{
N  u16 TIM_OSSRState;
N  u16 TIM_OSSIState;
N  u16 TIM_LOCKLevel; 
N  u16 TIM_DeadTime;
N  u16 TIM_Break;
N  u16 TIM_BreakPolarity;
N  u16 TIM_AutomaticOutput;
N} TIM_BDTRInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/                             
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM2_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM4_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM5_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM6_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM7_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM2_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM4_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM5_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM6_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM7_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N#define IS_TIM_18_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                  ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_18_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                   ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N#define IS_TIM_123458_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM2_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM4_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM5_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_123458_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM2_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM4_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM5_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N/* TIM Output Compare and PWM modes -----------------------------------------*/
N#define TIM_OCMode_Timing                  ((u16)0x0000)
N#define TIM_OCMode_Active                  ((u16)0x0010)
N#define TIM_OCMode_Inactive                ((u16)0x0020)
N#define TIM_OCMode_Toggle                  ((u16)0x0030)
N#define TIM_OCMode_PWM1                    ((u16)0x0060)
N#define TIM_OCMode_PWM2                    ((u16)0x0070)
N
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/* TIM One Pulse Mode -------------------------------------------------------*/
N#define TIM_OPMode_Single                  ((u16)0x0008)
N#define TIM_OPMode_Repetitive              ((u16)0x0000)
N
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N
N/* TIM Channel -------------------------------------------------------------*/
N#define TIM_Channel_1                      ((u16)0x0000)
N#define TIM_Channel_2                      ((u16)0x0004)
N#define TIM_Channel_3                      ((u16)0x0008)
N#define TIM_Channel_4                      ((u16)0x000C)
N
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N
N#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                               ((CHANNEL) == TIM_Channel_2) || \
N                                               ((CHANNEL) == TIM_Channel_3))
X#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                                ((CHANNEL) == TIM_Channel_2) ||                                                ((CHANNEL) == TIM_Channel_3))
N/* TIM Clock Division CKD --------------------------------------------------*/
N#define TIM_CKD_DIV1                       ((u16)0x0000)
N#define TIM_CKD_DIV2                       ((u16)0x0100)
N#define TIM_CKD_DIV4                       ((u16)0x0200)
N
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N
N/* TIM Counter Mode --------------------------------------------------------*/
N#define TIM_CounterMode_Up                 ((u16)0x0000)
N#define TIM_CounterMode_Down               ((u16)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((u16)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((u16)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((u16)0x0060)
N
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N
N/* TIM Output Compare Polarity ---------------------------------------------*/
N#define TIM_OCPolarity_High                ((u16)0x0000)
N#define TIM_OCPolarity_Low                 ((u16)0x0002)
N
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N
N/* TIM Output Compare N Polarity -------------------------------------------*/
N#define TIM_OCNPolarity_High               ((u16)0x0000)
N#define TIM_OCNPolarity_Low                ((u16)0x0008)
N
N#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
N                                       ((POLARITY) == TIM_OCNPolarity_Low))
X#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) ||                                        ((POLARITY) == TIM_OCNPolarity_Low))
N
N/* TIM Output Compare states -----------------------------------------------*/
N#define TIM_OutputState_Disable            ((u16)0x0000)
N#define TIM_OutputState_Enable             ((u16)0x0001)
N
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N
N/* TIM Output Compare N States ---------------------------------------------*/
N#define TIM_OutputNState_Disable           ((u16)0x0000)
N#define TIM_OutputNState_Enable            ((u16)0x0004)
N
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
N                                     ((STATE) == TIM_OutputNState_Enable))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) ||                                      ((STATE) == TIM_OutputNState_Enable))
N
N/* TIM Capture Compare States -----------------------------------------------*/
N#define TIM_CCx_Enable                      ((u16)0x0001)
N#define TIM_CCx_Disable                     ((u16)0x0000)
N
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N
N/* TIM Capture Compare N States --------------------------------------------*/
N#define TIM_CCxN_Enable                     ((u16)0x0004)
N#define TIM_CCxN_Disable                    ((u16)0x0000)                                     
N
N#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
N                           ((CCXN) == TIM_CCxN_Disable))
X#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) ||                            ((CCXN) == TIM_CCxN_Disable))
N
N/* Break Input enable/disable -----------------------------------------------*/
N#define TIM_Break_Enable                   ((u16)0x1000)
N#define TIM_Break_Disable                  ((u16)0x0000)
N
N#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
N                                   ((STATE) == TIM_Break_Disable))
X#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) ||                                    ((STATE) == TIM_Break_Disable))
N
N/* Break Polarity -----------------------------------------------------------*/
N#define TIM_BreakPolarity_Low              ((u16)0x0000)
N#define TIM_BreakPolarity_High             ((u16)0x2000)
N
N#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
N                                         ((POLARITY) == TIM_BreakPolarity_High))
X#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) ||                                          ((POLARITY) == TIM_BreakPolarity_High))
N
N/* TIM AOE Bit Set/Reset ---------------------------------------------------*/
N#define TIM_AutomaticOutput_Enable         ((u16)0x4000)
N#define TIM_AutomaticOutput_Disable        ((u16)0x0000)
N
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
N                                              ((STATE) == TIM_AutomaticOutput_Disable))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) ||                                               ((STATE) == TIM_AutomaticOutput_Disable))
N/* Lock levels --------------------------------------------------------------*/
N#define TIM_LOCKLevel_OFF                  ((u16)0x0000)
N#define TIM_LOCKLevel_1                    ((u16)0x0100)
N#define TIM_LOCKLevel_2                    ((u16)0x0200)
N#define TIM_LOCKLevel_3                    ((u16)0x0300)
N
N#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
N                                  ((LEVEL) == TIM_LOCKLevel_1) || \
N                                  ((LEVEL) == TIM_LOCKLevel_2) || \
N                                  ((LEVEL) == TIM_LOCKLevel_3))
X#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) ||                                   ((LEVEL) == TIM_LOCKLevel_1) ||                                   ((LEVEL) == TIM_LOCKLevel_2) ||                                   ((LEVEL) == TIM_LOCKLevel_3))
N
N/* OSSI: Off-State Selection for Idle mode states ---------------------------*/
N#define TIM_OSSIState_Enable               ((u16)0x0400)
N#define TIM_OSSIState_Disable              ((u16)0x0000)
N
N#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
N                                  ((STATE) == TIM_OSSIState_Disable))
X#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) ||                                   ((STATE) == TIM_OSSIState_Disable))
N
N/* OSSR: Off-State Selection for Run mode states ----------------------------*/
N#define TIM_OSSRState_Enable               ((u16)0x0800)
N#define TIM_OSSRState_Disable              ((u16)0x0000)
N
N#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
N                                  ((STATE) == TIM_OSSRState_Disable))
X#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) ||                                   ((STATE) == TIM_OSSRState_Disable))
N
N/* TIM Output Compare Idle State -------------------------------------------*/
N#define TIM_OCIdleState_Set                ((u16)0x0100)
N#define TIM_OCIdleState_Reset              ((u16)0x0000)
N
N#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
N                                    ((STATE) == TIM_OCIdleState_Reset))
X#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) ||                                     ((STATE) == TIM_OCIdleState_Reset))
N
N/* TIM Output Compare N Idle State -----------------------------------------*/
N#define TIM_OCNIdleState_Set               ((u16)0x0200)
N#define TIM_OCNIdleState_Reset             ((u16)0x0000)
N
N#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
N                                     ((STATE) == TIM_OCNIdleState_Reset))
X#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) ||                                      ((STATE) == TIM_OCNIdleState_Reset))
N
N/* TIM Input Capture Polarity ----------------------------------------------*/
N#define  TIM_ICPolarity_Rising             ((u16)0x0000)
N#define  TIM_ICPolarity_Falling            ((u16)0x0002)
N
N#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                      ((POLARITY) == TIM_ICPolarity_Falling))
X#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                       ((POLARITY) == TIM_ICPolarity_Falling))
N
N/* TIM Input Capture Selection ---------------------------------------------*/
N#define TIM_ICSelection_DirectTI           ((u16)0x0001)
N#define TIM_ICSelection_IndirectTI         ((u16)0x0002)
N#define TIM_ICSelection_TRC                ((u16)0x0003)
N
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N
N/* TIM Input Capture Prescaler ---------------------------------------------*/
N#define TIM_ICPSC_DIV1                     ((u16)0x0000)
N#define TIM_ICPSC_DIV2                     ((u16)0x0004)
N#define TIM_ICPSC_DIV4                     ((u16)0x0008)
N#define TIM_ICPSC_DIV8                     ((u16)0x000C)
N
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))                                          
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))                                          
N
N/* TIM interrupt sources ---------------------------------------------------*/
N#define TIM_IT_Update                      ((u16)0x0001)
N#define TIM_IT_CC1                         ((u16)0x0002)
N#define TIM_IT_CC2                         ((u16)0x0004)
N#define TIM_IT_CC3                         ((u16)0x0008)
N#define TIM_IT_CC4                         ((u16)0x0010)
N#define TIM_IT_COM                         ((u16)0x0020)
N#define TIM_IT_Trigger                     ((u16)0x0040)
N#define TIM_IT_Break                       ((u16)0x0080)
N
N#define IS_TIM_IT(IT) ((((IT) & (u16)0xFF00) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_PERIPH_IT(PERIPH, TIM_IT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFFA0) == 0x0000) && ((TIM_IT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFF00) == 0x0000) && ((TIM_IT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFFFE) == 0x0000) && ((TIM_IT) != 0x0000)))
X#define IS_TIM_PERIPH_IT(PERIPH, TIM_IT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((TIM_IT) & (u16)0xFFA0) == 0x0000) && ((TIM_IT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((TIM_IT) & (u16)0xFF00) == 0x0000) && ((TIM_IT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((TIM_IT) & (u16)0xFFFE) == 0x0000) && ((TIM_IT) != 0x0000)))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_COM) || \
N                           ((IT) == TIM_IT_Trigger) || \
N                           ((IT) == TIM_IT_Break))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_COM) ||                            ((IT) == TIM_IT_Trigger) ||                            ((IT) == TIM_IT_Break))
N
N/* TIM DMA Base address ----------------------------------------------------*/
N#define TIM_DMABase_CR1                    ((u16)0x0000)
N#define TIM_DMABase_CR2                    ((u16)0x0001)
N#define TIM_DMABase_SMCR                   ((u16)0x0002)
N#define TIM_DMABase_DIER                   ((u16)0x0003)
N#define TIM_DMABase_SR                     ((u16)0x0004)
N#define TIM_DMABase_EGR                    ((u16)0x0005)
N#define TIM_DMABase_CCMR1                  ((u16)0x0006)
N#define TIM_DMABase_CCMR2                  ((u16)0x0007)
N#define TIM_DMABase_CCER                   ((u16)0x0008)
N#define TIM_DMABase_CNT                    ((u16)0x0009)
N#define TIM_DMABase_PSC                    ((u16)0x000A)
N#define TIM_DMABase_ARR                    ((u16)0x000B)
N#define TIM_DMABase_RCR                    ((u16)0x000C)
N#define TIM_DMABase_CCR1                   ((u16)0x000D)
N#define TIM_DMABase_CCR2                   ((u16)0x000E)
N#define TIM_DMABase_CCR3                   ((u16)0x000F)
N#define TIM_DMABase_CCR4                   ((u16)0x0010)
N#define TIM_DMABase_BDTR                   ((u16)0x0011)
N#define TIM_DMABase_DCR                    ((u16)0x0012)
N
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_RCR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_BDTR) || \
N                               ((BASE) == TIM_DMABase_DCR))
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_RCR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_BDTR) ||                                ((BASE) == TIM_DMABase_DCR))
N
N/* TIM DMA Burst Length ----------------------------------------------------*/
N#define TIM_DMABurstLength_1Byte           ((u16)0x0000)
N#define TIM_DMABurstLength_2Bytes          ((u16)0x0100)
N#define TIM_DMABurstLength_3Bytes          ((u16)0x0200)
N#define TIM_DMABurstLength_4Bytes          ((u16)0x0300)
N#define TIM_DMABurstLength_5Bytes          ((u16)0x0400)
N#define TIM_DMABurstLength_6Bytes          ((u16)0x0500)
N#define TIM_DMABurstLength_7Bytes          ((u16)0x0600)
N#define TIM_DMABurstLength_8Bytes          ((u16)0x0700)
N#define TIM_DMABurstLength_9Bytes          ((u16)0x0800)
N#define TIM_DMABurstLength_10Bytes         ((u16)0x0900)
N#define TIM_DMABurstLength_11Bytes         ((u16)0x0A00)
N#define TIM_DMABurstLength_12Bytes         ((u16)0x0B00)
N#define TIM_DMABurstLength_13Bytes         ((u16)0x0C00)
N#define TIM_DMABurstLength_14Bytes         ((u16)0x0D00)
N#define TIM_DMABurstLength_15Bytes         ((u16)0x0E00)
N#define TIM_DMABurstLength_16Bytes         ((u16)0x0F00)
N#define TIM_DMABurstLength_17Bytes         ((u16)0x1000)
N#define TIM_DMABurstLength_18Bytes         ((u16)0x1100)
N
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Byte) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Bytes))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Byte) ||                                    ((LENGTH) == TIM_DMABurstLength_2Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_3Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_4Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_5Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_6Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_7Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_8Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_9Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_10Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_11Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_12Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_13Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_14Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_15Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_16Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_17Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_18Bytes))
N
N/* TIM DMA sources ---------------------------------------------------------*/
N#define TIM_DMA_Update                     ((u16)0x0100)
N#define TIM_DMA_CC1                        ((u16)0x0200)
N#define TIM_DMA_CC2                        ((u16)0x0400)
N#define TIM_DMA_CC3                        ((u16)0x0800)
N#define TIM_DMA_CC4                        ((u16)0x1000)
N#define TIM_DMA_COM                        ((u16)0x2000)
N#define TIM_DMA_Trigger                    ((u16)0x4000)
N
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N#define IS_TIM_PERIPH_DMA(PERIPH, SOURCE) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((SOURCE) & (u16)0xA0FF) == 0x0000) && ((SOURCE) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((SOURCE) & (u16)0xFEFF) == 0x0000) && ((SOURCE) != 0x0000)))
X#define IS_TIM_PERIPH_DMA(PERIPH, SOURCE) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((SOURCE) & (u16)0xA0FF) == 0x0000) && ((SOURCE) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((SOURCE) & (u16)0xFEFF) == 0x0000) && ((SOURCE) != 0x0000)))
N
N/* TIM External Trigger Prescaler ------------------------------------------*/
N#define TIM_ExtTRGPSC_OFF                  ((u16)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((u16)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((u16)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((u16)0x3000)
N
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N
N/* TIM Internal Trigger Selection ------------------------------------------*/
N#define TIM_TS_ITR0                        ((u16)0x0000)
N#define TIM_TS_ITR1                        ((u16)0x0010)
N#define TIM_TS_ITR2                        ((u16)0x0020)
N#define TIM_TS_ITR3                        ((u16)0x0030)
N#define TIM_TS_TI1F_ED                     ((u16)0x0040)
N#define TIM_TS_TI1FP1                      ((u16)0x0050)
N#define TIM_TS_TI2FP2                      ((u16)0x0060)
N#define TIM_TS_ETRF                        ((u16)0x0070)
N
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N
N/* TIM TIx External Clock Source -------------------------------------------*/
N#define TIM_TIxExternalCLK1Source_TI1      ((u16)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((u16)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((u16)0x0040)
N
N#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
X#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
N
N/* TIM External Trigger Polarity -------------------------------------------*/
N#define TIM_ExtTRGPolarity_Inverted        ((u16)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((u16)0x0000)
N
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N
N/* TIM Prescaler Reload Mode -----------------------------------------------*/
N#define TIM_PSCReloadMode_Update           ((u16)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((u16)0x0001)
N
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N
N/* TIM Forced Action -------------------------------------------------------*/
N#define TIM_ForcedAction_Active            ((u16)0x0050)
N#define TIM_ForcedAction_InActive          ((u16)0x0040)
N
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N
N/* TIM Encoder Mode --------------------------------------------------------*/ 
N#define TIM_EncoderMode_TI1                ((u16)0x0001)
N#define TIM_EncoderMode_TI2                ((u16)0x0002)
N#define TIM_EncoderMode_TI12               ((u16)0x0003)
N
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N
N/* TIM Event Source --------------------------------------------------------*/
N#define TIM_EventSource_Update             ((u16)0x0001)
N#define TIM_EventSource_CC1                ((u16)0x0002)
N#define TIM_EventSource_CC2                ((u16)0x0004)
N#define TIM_EventSource_CC3                ((u16)0x0008)
N#define TIM_EventSource_CC4                ((u16)0x0010)
N#define TIM_EventSource_COM                ((u16)0x0020)
N#define TIM_EventSource_Trigger            ((u16)0x0040)
N#define TIM_EventSource_Break              ((u16)0x0080)
N
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (u16)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
N
N#define IS_TIM_PERIPH_EVENT(PERIPH, EVENT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((EVENT) & (u16)0xFFA0) == 0x0000) && ((EVENT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((EVENT) & (u16)0xFF00) == 0x0000) && ((EVENT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((EVENT) & (u16)0xFFFE) == 0x0000) && ((EVENT) != 0x0000)))
X#define IS_TIM_PERIPH_EVENT(PERIPH, EVENT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((EVENT) & (u16)0xFFA0) == 0x0000) && ((EVENT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((EVENT) & (u16)0xFF00) == 0x0000) && ((EVENT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((EVENT) & (u16)0xFFFE) == 0x0000) && ((EVENT) != 0x0000)))
N
N/* TIM Update Source --------------------------------------------------------*/
N#define TIM_UpdateSource_Global            ((u16)0x0000)
N#define TIM_UpdateSource_Regular           ((u16)0x0001)
N
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N
N/* TIM Ouput Compare Preload State ------------------------------------------*/
N#define TIM_OCPreload_Enable               ((u16)0x0008)
N#define TIM_OCPreload_Disable              ((u16)0x0000)
N
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N
N/* TIM Ouput Compare Fast State ---------------------------------------------*/
N#define TIM_OCFast_Enable                  ((u16)0x0004)
N#define TIM_OCFast_Disable                 ((u16)0x0000)
N
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/* TIM Ouput Compare Clear State --------------------------------------------*/
N#define TIM_OCClear_Enable                 ((u16)0x0080)
N#define TIM_OCClear_Disable                ((u16)0x0000)
N
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))                                     
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))                                     
N
N/* TIM Trigger Output Source ------------------------------------------------*/ 
N#define TIM_TRGOSource_Reset               ((u16)0x0000)
N#define TIM_TRGOSource_Enable              ((u16)0x0010)
N#define TIM_TRGOSource_Update              ((u16)0x0020)
N#define TIM_TRGOSource_OC1                 ((u16)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((u16)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((u16)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((u16)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((u16)0x0070)
N
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N
N#define IS_TIM_PERIPH_TRGO(PERIPH, TRGO)  (((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Reset)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Enable)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Update)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC1)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC1Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC2Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC3Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC4Ref)))
X#define IS_TIM_PERIPH_TRGO(PERIPH, TRGO)  (((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Reset)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Enable)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Update)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC1)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC1Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC2Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC3Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC4Ref)))
N
N/* TIM Slave Mode ----------------------------------------------------------*/
N#define TIM_SlaveMode_Reset                ((u16)0x0004)
N#define TIM_SlaveMode_Gated                ((u16)0x0005)
N#define TIM_SlaveMode_Trigger              ((u16)0x0006)
N#define TIM_SlaveMode_External1            ((u16)0x0007)
N
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N
N/* TIM Master Slave Mode ---------------------------------------------------*/
N#define TIM_MasterSlaveMode_Enable         ((u16)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((u16)0x0000)
N
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N
N/* TIM Flags ---------------------------------------------------------------*/
N#define TIM_FLAG_Update                    ((u16)0x0001)
N#define TIM_FLAG_CC1                       ((u16)0x0002)
N#define TIM_FLAG_CC2                       ((u16)0x0004)
N#define TIM_FLAG_CC3                       ((u16)0x0008)
N#define TIM_FLAG_CC4                       ((u16)0x0010)
N#define TIM_FLAG_COM                       ((u16)0x0020)
N#define TIM_FLAG_Trigger                   ((u16)0x0040)
N#define TIM_FLAG_Break                     ((u16)0x0080)
N#define TIM_FLAG_CC1OF                     ((u16)0x0200)
N#define TIM_FLAG_CC2OF                     ((u16)0x0400)
N#define TIM_FLAG_CC3OF                     ((u16)0x0800)
N#define TIM_FLAG_CC4OF                     ((u16)0x1000)
N
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_COM) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_Break) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_COM) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_Break) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N
N#define IS_TIM_CLEAR_FLAG(PERIPH, TIM_FLAG) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xE1A0) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xFFFE) == 0x0000) && ((TIM_FLAG) != 0x0000)))
X#define IS_TIM_CLEAR_FLAG(PERIPH, TIM_FLAG) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((TIM_FLAG) & (u16)0xE1A0) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((TIM_FLAG) & (u16)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((TIM_FLAG) & (u16)0xFFFE) == 0x0000) && ((TIM_FLAG) != 0x0000)))
N
N#define IS_TIM_PERIPH_FLAG(PERIPH, TIM_FLAG)  (((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||\
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_CC1) || ((TIM_FLAG) == TIM_FLAG_CC2) ||\
N                                                 ((TIM_FLAG) == TIM_FLAG_CC3) || ((TIM_FLAG) == TIM_FLAG_CC4) || \
N                                                 ((TIM_FLAG) == TIM_FLAG_Trigger))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||\
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE)|| ((*(u32*)&(PERIPH))==TIM8_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM7_BASE) || ((*(u32*)&(PERIPH))==TIM6_BASE)) && \
N                                                 (((TIM_FLAG) == TIM_FLAG_Update))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH)) == TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_COM) || ((TIM_FLAG) == TIM_FLAG_Break))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_CC1OF) || ((TIM_FLAG) == TIM_FLAG_CC2OF) ||\
N                                                 ((TIM_FLAG) == TIM_FLAG_CC3OF) || ((TIM_FLAG) == TIM_FLAG_CC4OF))))             
X#define IS_TIM_PERIPH_FLAG(PERIPH, TIM_FLAG)  (((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_CC1) || ((TIM_FLAG) == TIM_FLAG_CC2) ||                                                 ((TIM_FLAG) == TIM_FLAG_CC3) || ((TIM_FLAG) == TIM_FLAG_CC4) ||                                                  ((TIM_FLAG) == TIM_FLAG_Trigger))) ||                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                  ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                 ((*(u32*)&(PERIPH))==TIM1_BASE)|| ((*(u32*)&(PERIPH))==TIM8_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM7_BASE) || ((*(u32*)&(PERIPH))==TIM6_BASE)) &&                                                  (((TIM_FLAG) == TIM_FLAG_Update))) ||                                                 ((((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH)) == TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_COM) || ((TIM_FLAG) == TIM_FLAG_Break))) ||                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                  ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_CC1OF) || ((TIM_FLAG) == TIM_FLAG_CC2OF) ||                                                 ((TIM_FLAG) == TIM_FLAG_CC3OF) || ((TIM_FLAG) == TIM_FLAG_CC4OF))))             
N                                                                                            
N/* TIM Input Capture Filer Value ---------------------------------------------*/
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N
N/* TIM External Trigger Filter -----------------------------------------------*/
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)                              
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState);
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
N                                u16 TIM_ICPolarity, u16 ICFilter);                                
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
N                             u16 ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
N                             u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
N                   u16 ExtTRGFilter);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode);
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource);
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
N                                u16 TIM_IC1Polarity, u16 TIM_IC2Polarity);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx);
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD);
Nu16 TIM_GetCapture1(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture2(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture3(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture4(TIM_TypeDef* TIMx);
Nu16 TIM_GetCounter(TIM_TypeDef* TIMx);
Nu16 TIM_GetPrescaler(TIM_TypeDef* TIMx);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT);
N                                                                                                             
N#endif /*__STM32F10x_TIM_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
N
N
N
N
N
N
N
N
L 108 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_TIM */
N
N#ifdef _USART
N  #include "stm32f10x_usart.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_usart.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_usart.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      USART firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_USART_H
N#define __STM32F10x_USART_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* USART Init Structure definition */
Ntypedef struct
N{
N  u32 USART_BaudRate;
N  u16 USART_WordLength;
N  u16 USART_StopBits;
N  u16 USART_Parity;
N  u16 USART_Mode;
N  u16 USART_HardwareFlowControl;  
N} USART_InitTypeDef;
N
N/* USART Clock Init Structure definition */
Ntypedef struct
N{
N  u16 USART_Clock;
N  u16 USART_CPOL;
N  u16 USART_CPHA;
N  u16 USART_LastBit;
N} USART_ClockInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N#define IS_USART_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == USART2_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == USART3_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == UART4_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == UART5_BASE))
X#define IS_USART_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) ||                                      ((*(u32*)&(PERIPH)) == USART2_BASE) ||                                      ((*(u32*)&(PERIPH)) == USART3_BASE) ||                                      ((*(u32*)&(PERIPH)) == UART4_BASE) ||                                      ((*(u32*)&(PERIPH)) == UART5_BASE))
N
N#define IS_USART_123_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == USART2_BASE) || \
N                                     ((*(u32*)&(PERIPH)) == USART3_BASE))
X#define IS_USART_123_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) ||                                      ((*(u32*)&(PERIPH)) == USART2_BASE) ||                                      ((*(u32*)&(PERIPH)) == USART3_BASE))
N
N#define IS_USART_1234_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == USART2_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == USART3_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == UART4_BASE))
X#define IS_USART_1234_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == USART1_BASE) ||                                       ((*(u32*)&(PERIPH)) == USART2_BASE) ||                                       ((*(u32*)&(PERIPH)) == USART3_BASE) ||                                       ((*(u32*)&(PERIPH)) == UART4_BASE))
N
N/* USART Word Length ---------------------------------------------------------*/
N#define USART_WordLength_8b                  ((u16)0x0000)
N#define USART_WordLength_9b                  ((u16)0x1000)
N                                    
N#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
N                                      ((LENGTH) == USART_WordLength_9b))
X#define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) ||                                       ((LENGTH) == USART_WordLength_9b))
N
N/* USART Stop Bits -----------------------------------------------------------*/
N#define USART_StopBits_1                     ((u16)0x0000)
N#define USART_StopBits_0_5                   ((u16)0x1000)
N#define USART_StopBits_2                     ((u16)0x2000)
N#define USART_StopBits_1_5                   ((u16)0x3000)
N
N#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
N                                     ((STOPBITS) == USART_StopBits_0_5) || \
N                                     ((STOPBITS) == USART_StopBits_2) || \
N                                     ((STOPBITS) == USART_StopBits_1_5))
X#define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) ||                                      ((STOPBITS) == USART_StopBits_0_5) ||                                      ((STOPBITS) == USART_StopBits_2) ||                                      ((STOPBITS) == USART_StopBits_1_5))
N/* USART Parity --------------------------------------------------------------*/
N#define USART_Parity_No                      ((u16)0x0000)
N#define USART_Parity_Even                    ((u16)0x0400)
N#define USART_Parity_Odd                     ((u16)0x0600) 
N
N#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
N                                 ((PARITY) == USART_Parity_Even) || \
N                                 ((PARITY) == USART_Parity_Odd))
X#define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) ||                                  ((PARITY) == USART_Parity_Even) ||                                  ((PARITY) == USART_Parity_Odd))
N
N/* USART Mode ----------------------------------------------------------------*/
N#define USART_Mode_Rx                        ((u16)0x0004)
N#define USART_Mode_Tx                        ((u16)0x0008)
N
N#define IS_USART_MODE(MODE) ((((MODE) & (u16)0xFFF3) == 0x00) && ((MODE) != (u16)0x00))
N
N/* USART Hardware Flow Control -----------------------------------------------*/
N#define USART_HardwareFlowControl_None       ((u16)0x0000)
N#define USART_HardwareFlowControl_RTS        ((u16)0x0100)
N#define USART_HardwareFlowControl_CTS        ((u16)0x0200)
N#define USART_HardwareFlowControl_RTS_CTS    ((u16)0x0300)
N
N#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
N                              (((CONTROL) == USART_HardwareFlowControl_None) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_CTS) || \
N                               ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
X#define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)                              (((CONTROL) == USART_HardwareFlowControl_None) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS) ||                                ((CONTROL) == USART_HardwareFlowControl_CTS) ||                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
N
N#define IS_USART_PERIPH_HFC(PERIPH, HFC) ((((*(u32*)&(PERIPH)) != UART4_BASE) && \
N                                          ((*(u32*)&(PERIPH)) != UART5_BASE)) \
N                                          || ((HFC) == USART_HardwareFlowControl_None))                                
X#define IS_USART_PERIPH_HFC(PERIPH, HFC) ((((*(u32*)&(PERIPH)) != UART4_BASE) &&                                           ((*(u32*)&(PERIPH)) != UART5_BASE))                                           || ((HFC) == USART_HardwareFlowControl_None))                                
N
N/* USART Clock ---------------------------------------------------------------*/
N#define USART_Clock_Disable                  ((u16)0x0000)
N#define USART_Clock_Enable                   ((u16)0x0800)
N
N#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
N                               ((CLOCK) == USART_Clock_Enable))
X#define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) ||                                ((CLOCK) == USART_Clock_Enable))
N
N/* USART Clock Polarity ------------------------------------------------------*/
N#define USART_CPOL_Low                       ((u16)0x0000)
N#define USART_CPOL_High                      ((u16)0x0400)
N
N#define IS_USART_CPOL(CPOL) (((CPOL) == USART_CPOL_Low) || ((CPOL) == USART_CPOL_High))
N                               
N/* USART Clock Phase ---------------------------------------------------------*/
N#define USART_CPHA_1Edge                     ((u16)0x0000)
N#define USART_CPHA_2Edge                     ((u16)0x0200)
N#define IS_USART_CPHA(CPHA) (((CPHA) == USART_CPHA_1Edge) || ((CPHA) == USART_CPHA_2Edge))
N
N/* USART Last Bit ------------------------------------------------------------*/
N#define USART_LastBit_Disable                ((u16)0x0000)
N#define USART_LastBit_Enable                 ((u16)0x0100)
N
N#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) || \
N                                   ((LASTBIT) == USART_LastBit_Enable))
X#define IS_USART_LASTBIT(LASTBIT) (((LASTBIT) == USART_LastBit_Disable) ||                                    ((LASTBIT) == USART_LastBit_Enable))
N
N/* USART Interrupt definition ------------------------------------------------*/
N#define USART_IT_PE                          ((u16)0x0028)
N#define USART_IT_TXE                         ((u16)0x0727)
N#define USART_IT_TC                          ((u16)0x0626)
N#define USART_IT_RXNE                        ((u16)0x0525)
N#define USART_IT_IDLE                        ((u16)0x0424)
N#define USART_IT_LBD                         ((u16)0x0846)
N#define USART_IT_CTS                         ((u16)0x096A)
N#define USART_IT_ERR                         ((u16)0x0060)
N#define USART_IT_ORE                         ((u16)0x0360)
N#define USART_IT_NE                          ((u16)0x0260)
N#define USART_IT_FE                          ((u16)0x0160)
N
N#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                               ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                               ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                               ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
X#define IS_USART_CONFIG_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                                ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                                ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                                ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ERR))
N
N#define IS_USART_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) || \
N                         ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) || \
N                         ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) || \
N                         ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) || \
N                         ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
X#define IS_USART_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TXE) ||                          ((IT) == USART_IT_TC) || ((IT) == USART_IT_RXNE) ||                          ((IT) == USART_IT_IDLE) || ((IT) == USART_IT_LBD) ||                          ((IT) == USART_IT_CTS) || ((IT) == USART_IT_ORE) ||                          ((IT) == USART_IT_NE) || ((IT) == USART_IT_FE))
N
N#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TC) || \
N                               ((IT) == USART_IT_RXNE) || ((IT) == USART_IT_IDLE) || \
N                               ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS) ||  \
N                               ((IT) == USART_IT_ORE) || ((IT) == USART_IT_NE) || \
N                               ((IT) == USART_IT_FE))
X#define IS_USART_CLEAR_IT(IT) (((IT) == USART_IT_PE) || ((IT) == USART_IT_TC) ||                                ((IT) == USART_IT_RXNE) || ((IT) == USART_IT_IDLE) ||                                ((IT) == USART_IT_LBD) || ((IT) == USART_IT_CTS) ||                                 ((IT) == USART_IT_ORE) || ((IT) == USART_IT_NE) ||                                ((IT) == USART_IT_FE))
N
N#define IS_USART_PERIPH_IT(PERIPH, USART_IT) ((((*(u32*)&(PERIPH)) != UART4_BASE) && \
N                                              ((*(u32*)&(PERIPH)) != UART5_BASE)) \
N                                              || ((USART_IT) != USART_IT_CTS))                                                                           
X#define IS_USART_PERIPH_IT(PERIPH, USART_IT) ((((*(u32*)&(PERIPH)) != UART4_BASE) &&                                               ((*(u32*)&(PERIPH)) != UART5_BASE))                                               || ((USART_IT) != USART_IT_CTS))                                                                           
N
N/* USART DMA Requests --------------------------------------------------------*/
N#define USART_DMAReq_Tx                      ((u16)0x0080)
N#define USART_DMAReq_Rx                      ((u16)0x0040)
N
N#define IS_USART_DMAREQ(DMAREQ) ((((DMAREQ) & (u16)0xFF3F) == 0x00) && ((DMAREQ) != (u16)0x00))
N
N/* USART WakeUp methods ------------------------------------------------------*/
N#define USART_WakeUp_IdleLine                ((u16)0x0000)
N#define USART_WakeUp_AddressMark             ((u16)0x0800)
N
N#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) || \
N                                 ((WAKEUP) == USART_WakeUp_AddressMark))
X#define IS_USART_WAKEUP(WAKEUP) (((WAKEUP) == USART_WakeUp_IdleLine) ||                                  ((WAKEUP) == USART_WakeUp_AddressMark))
N
N/* USART LIN Break Detection Length ------------------------------------------*/
N#define USART_LINBreakDetectLength_10b      ((u16)0x0000)
N#define USART_LINBreakDetectLength_11b      ((u16)0x0020)
N
N#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH) \
N                               (((LENGTH) == USART_LINBreakDetectLength_10b) || \
N                                ((LENGTH) == USART_LINBreakDetectLength_11b))
X#define IS_USART_LIN_BREAK_DETECT_LENGTH(LENGTH)                                (((LENGTH) == USART_LINBreakDetectLength_10b) ||                                 ((LENGTH) == USART_LINBreakDetectLength_11b))
N
N/* USART IrDA Low Power ------------------------------------------------------*/
N#define USART_IrDAMode_LowPower              ((u16)0x0004)
N#define USART_IrDAMode_Normal                ((u16)0x0000)
N
N#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) || \
N                                  ((MODE) == USART_IrDAMode_Normal))
X#define IS_USART_IRDA_MODE(MODE) (((MODE) == USART_IrDAMode_LowPower) ||                                   ((MODE) == USART_IrDAMode_Normal))
N
N/* USART Flags ---------------------------------------------------------------*/
N#define USART_FLAG_CTS                       ((u16)0x0200)
N#define USART_FLAG_LBD                       ((u16)0x0100)
N#define USART_FLAG_TXE                       ((u16)0x0080)
N#define USART_FLAG_TC                        ((u16)0x0040)
N#define USART_FLAG_RXNE                      ((u16)0x0020)
N#define USART_FLAG_IDLE                      ((u16)0x0010)
N#define USART_FLAG_ORE                       ((u16)0x0008)
N#define USART_FLAG_NE                        ((u16)0x0004)
N#define USART_FLAG_FE                        ((u16)0x0002)
N#define USART_FLAG_PE                        ((u16)0x0001)
N
N#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) || \
N                             ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) || \
N                             ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) || \
N                             ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) || \
N                             ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
X#define IS_USART_FLAG(FLAG) (((FLAG) == USART_FLAG_PE) || ((FLAG) == USART_FLAG_TXE) ||                              ((FLAG) == USART_FLAG_TC) || ((FLAG) == USART_FLAG_RXNE) ||                              ((FLAG) == USART_FLAG_IDLE) || ((FLAG) == USART_FLAG_LBD) ||                              ((FLAG) == USART_FLAG_CTS) || ((FLAG) == USART_FLAG_ORE) ||                              ((FLAG) == USART_FLAG_NE) || ((FLAG) == USART_FLAG_FE))
N                              
N#define IS_USART_CLEAR_FLAG(FLAG) ((((FLAG) & (u16)0xFC80) == 0x00) && ((FLAG) != (u16)0x00))
N
N#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(u32*)&(PERIPH)) != UART4_BASE) &&\
N                                                  ((*(u32*)&(PERIPH)) != UART5_BASE)) \
N                                                  || ((USART_FLAG) != USART_FLAG_CTS)) 
X#define IS_USART_PERIPH_FLAG(PERIPH, USART_FLAG) ((((*(u32*)&(PERIPH)) != UART4_BASE) &&                                                  ((*(u32*)&(PERIPH)) != UART5_BASE))                                                   || ((USART_FLAG) != USART_FLAG_CTS)) 
N
N#define IS_USART_BAUDRATE(BAUDRATE) (((BAUDRATE) > 0) && ((BAUDRATE) < 0x0044AA21))
N#define IS_USART_ADDRESS(ADDRESS) ((ADDRESS) <= 0xF)
N#define IS_USART_DATA(DATA) ((DATA) <= 0x1FF)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid USART_DeInit(USART_TypeDef* USARTx);
Nvoid USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct);
Nvoid USART_StructInit(USART_InitTypeDef* USART_InitStruct);
Nvoid USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct);
Nvoid USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_ITConfig(USART_TypeDef* USARTx, u16 USART_IT, FunctionalState NewState);
Nvoid USART_DMACmd(USART_TypeDef* USARTx, u16 USART_DMAReq, FunctionalState NewState);
Nvoid USART_SetAddress(USART_TypeDef* USARTx, u8 USART_Address);
Nvoid USART_WakeUpConfig(USART_TypeDef* USARTx, u16 USART_WakeUp);
Nvoid USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, u16 USART_LINBreakDetectLength);
Nvoid USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SendData(USART_TypeDef* USARTx, u16 Data);
Nu16 USART_ReceiveData(USART_TypeDef* USARTx);
Nvoid USART_SendBreak(USART_TypeDef* USARTx);
Nvoid USART_SetGuardTime(USART_TypeDef* USARTx, u8 USART_GuardTime);
Nvoid USART_SetPrescaler(USART_TypeDef* USARTx, u8 USART_Prescaler);
Nvoid USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState);
Nvoid USART_IrDAConfig(USART_TypeDef* USARTx, u16 USART_IrDAMode);
Nvoid USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState);
NFlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, u16 USART_FLAG);
Nvoid USART_ClearFlag(USART_TypeDef* USARTx, u16 USART_FLAG);
NITStatus USART_GetITStatus(USART_TypeDef* USARTx, u16 USART_IT);
Nvoid USART_ClearITPendingBit(USART_TypeDef* USARTx, u16 USART_IT);
N
N#endif /* __STM32F10x_USART_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 112 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_lib.h" 2
N#endif /*_USART */
N
N#ifdef _WWDG
S  #include "stm32f10x_wwdg.h"
N#endif /*_WWDG */
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid debug(void);
N
N#endif /* __STM32F10x_LIB_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 66 "..\BSP\bsp.h" 2
N
N#include    <app_cfg.h>
N#include    <lcd.h>
L 1 "..\BSP\lcd.h" 1
N/******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
N* File Name          : lcd.h
N* Author             : MCD Application Team
N* Version            : V1.1
N* Date               : 11/26/2007
N* Description        : This file contains all the functions prototypes for the
N*                      lcd firmware driver.
N********************************************************************************
N* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __LCD_H
N#define __LCD_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_lib.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* LCD Registers */
N#define R0             0x00
N#define R1             0x01
N#define R2             0x02
N#define R3             0x03
N#define R4             0x04
N#define R5             0x05
N#define R6             0x06
N#define R7             0x07
N#define R8             0x08
N#define R9             0x09
N#define R10            0x0A
N#define R12            0x0C
N#define R13            0x0D
N#define R14            0x0E
N#define R15            0x0F
N#define R16            0x10
N#define R17            0x11
N#define R18            0x12
N#define R19            0x13
N#define R20            0x14
N#define R21            0x15
N#define R22            0x16
N#define R23            0x17
N#define R24            0x18
N#define R25            0x19
N#define R26            0x1A
N#define R27            0x1B
N#define R28            0x1C
N#define R29            0x1D
N#define R30            0x1E
N#define R31            0x1F
N#define R32            0x20
N#define R33            0x21
N#define R34            0x22
N#define R36            0x24
N#define R37            0x25
N#define R40            0x28
N#define R41            0x29
N#define R43            0x2B
N#define R45            0x2D
N#define R48            0x30
N#define R49            0x31
N#define R50            0x32
N#define R51            0x33
N#define R52            0x34
N#define R53            0x35
N#define R54            0x36
N#define R55            0x37
N#define R56            0x38
N#define R57            0x39
N#define R59            0x3B
N#define R60            0x3C
N#define R61            0x3D
N#define R62            0x3E
N#define R63            0x3F
N#define R64            0x40
N#define R65            0x41
N#define R66            0x42
N#define R67            0x43
N#define R68            0x44
N#define R69            0x45
N#define R70            0x46
N#define R71            0x47
N#define R72            0x48
N#define R73            0x49
N#define R74            0x4A
N#define R75            0x4B
N#define R76            0x4C
N#define R77            0x4D
N#define R78            0x4E
N#define R79            0x4F
N#define R80            0x50
N#define R81            0x51
N#define R82            0x52
N#define R83            0x53
N#define R96            0x60
N#define R97            0x61
N#define R106           0x6A
N#define R118           0x76
N#define R128           0x80
N#define R129           0x81
N#define R130           0x82
N#define R131           0x83
N#define R132           0x84
N#define R133           0x85
N#define R134           0x86
N#define R135           0x87
N#define R136           0x88
N#define R137           0x89
N#define R139           0x8B
N#define R140           0x8C
N#define R141           0x8D
N#define R143           0x8F
N#define R144           0x90
N#define R145           0x91
N#define R146           0x92
N#define R147           0x93
N#define R148           0x94
N#define R149           0x95
N#define R150           0x96
N#define R151           0x97
N#define R152           0x98
N#define R153           0x99
N#define R154           0x9A
N#define R157           0x9D
N#define R192           0xC0
N#define R193           0xC1
N#define R229           0xE5
N
N/* LCD Control pins */
N#define CtrlPin_NCS    GPIO_Pin_2   /* PB.02 */
N#define CtrlPin_RS     GPIO_Pin_7   /* PD.07 */
N#define CtrlPin_NWR    GPIO_Pin_15  /* PD.15 */
N
N/* LCD color */
N#define White          0xFFFF
N#define Black          0x0000
N#define Grey           0xF7DE
N#define Blue           0x001F
N#define Blue2          0x051F
N#define Red            0xF800
N#define Magenta        0xF81F
N#define Green          0x07E0
N#define Cyan           0x7FFF
N#define Yellow         0xFFE0
N
N#define Line0          0
N#define Line1          24
N#define Line2          48
N#define Line3          72
N#define Line4          96
N#define Line5          120
N#define Line6          144
N#define Line7          168
N#define Line8          192
N#define Line9          216
N
N#define Horizontal     0x00
N#define Vertical       0x01
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N/*----- High layer function -----*/
Nvoid LCD_Setup(void);
Nvoid STM3210B_LCD_Init(void);
Nvoid LCD_SetTextColor(vu16 Color);
Nvoid LCD_SetBackColor(vu16 Color);
Nvoid LCD_ClearLine(u8 Line);
Nvoid LCD_Clear(u16 Color);
Nvoid LCD_SetCursor(u8 Xpos, u16 Ypos);
Nvoid LCD_DrawChar(u8 Xpos, u16 Ypos, uc16 *c);
Nvoid LCD_DisplayChar(u8 Line, u16 Column, u8 Ascii);
Nvoid LCD_DisplayStringLine(u8 Line, u8 *ptr);
Nvoid LCD_SetDisplayWindow(u8 Xpos, u16 Ypos, u8 Height, u16 Width);
Nvoid LCD_WindowModeDisable(void);
Nvoid LCD_DrawLine(u8 Xpos, u16 Ypos, u16 Length, u8 Direction);
Nvoid LCD_DrawRect(u8 Xpos, u16 Ypos, u8 Height, u16 Width);
Nvoid LCD_DrawCircle(u8 Xpos, u16 Ypos, u16 Radius);
Nvoid LCD_DrawMonoPict(uc32 *Pict);
Nvoid LCD_DrawBMP(u32 BmpAddress);
N
N/*----- Medium layer function -----*/
Nvoid LCD_nCS_StartByte(u8 Start_Byte);
Nvoid LCD_WriteRegIndex(u8 LCD_Reg);
Nvoid LCD_WriteReg(u8 LCD_Reg, u16 LCD_RegValue);
Nvoid LCD_WriteRAM_Prepare(void);
Nvoid LCD_WriteRAMWord(u16 RGB_Code);
Nu16 LCD_ReadReg(u8 LCD_Reg);
Nvoid LCD_WriteRAM(u16 RGB_Code);
Nvoid LCD_PowerOn(void);
Nvoid LCD_DisplayOn(void);
Nvoid LCD_DisplayOff(void);
N
N/*----- Low layer function -----*/
Nvoid LCD_CtrlLinesConfig(void);
Nvoid LCD_CtrlLinesWrite(GPIO_TypeDef* GPIOx, u16 CtrlPins, BitAction BitVal);
Nvoid LCD_SPIConfig(void);
Nvoid LCD_DisplayString(u8 Line, u8 *ptr);
N
N#endif /* __LCD_H */
N
N/******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
L 69 "..\BSP\bsp.h" 2
N#include    <bsp.h>
L 1 "..\BSP\bsp.h" 1
N/*
N*********************************************************************************************************
N*                                     MICIRUM BOARD SUPPORT PACKAGE
N*
N*                             (c) Copyright 2007; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                        BOARD SUPPORT PACKAGE
N*
N*                                     ST Microelectronics STM32
N*                                              with the
N*                                   STM3210B-EVAL Evaluation Board
N*
N* Filename      : bsp.h
N* Version       : V1.10
N* Programmer(s) : BAN
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                                 MODULE
N*
N* Note(s) : (1) This header file is protected from multiple pre-processor inclusion through use of the
N*               BSP present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  BSP_PRESENT
S#define  BSP_PRESENT
S
S/*
S*********************************************************************************************************
S*                                                 EXTERNS
S*********************************************************************************************************
S*/
S
S#ifdef   BSP_MODULE
S#define  BSP_EXT
S#else
S#define  BSP_EXT  extern
S#endif
S
S/*
S*********************************************************************************************************
S*                                              INCLUDE FILES
S*********************************************************************************************************
S*/
S
S#include    <cpu.h>
S#include    <lib_def.h>
S#include    <lib_mem.h>
S#include    <lib_str.h>
S
S#include    <stm32f10x_conf.h>
S#include    <stm32f10x_lib.h>
S
S#include    <app_cfg.h>
S#include    <lcd.h>
S#include    <bsp.h>
S
S#include  <ucos_ii.h>
S
S#if (APP_OS_PROBE_EN == DEF_ENABLED)
S#include    <os_probe.h>
S#endif
S
S/*
S*********************************************************************************************************
S*                                                 DEFINES
S*********************************************************************************************************
S*/
S
S#define  BSP_JOYSTICK_NONE                       DEF_BIT_NONE
S#define  BSP_JOYSTICK_UP                         DEF_BIT_00
S#define  BSP_JOYSTICK_DOWN                       DEF_BIT_01
S#define  BSP_JOYSTICK_LEFT                       DEF_BIT_02
S#define  BSP_JOYSTICK_RIGHT                      DEF_BIT_03
S#define  BSP_JOYSTICK_CENTER                     DEF_BIT_04
S
S#define  BSP_PB_ID_KEY                                     1
S#define  BSP_PB_ID_WAKEUP                                  2
S#define  BSP_PB_ID_TAMPER                                  3
S
S/*
S*********************************************************************************************************
S*                                               INT DEFINES
S*********************************************************************************************************
S*/
S
S#define  BSP_INT_ID_WWDG                                   0    /* Window WatchDog Interrupt                            */
S#define  BSP_INT_ID_PVD                                    1    /* PVD through EXTI Line detection Interrupt            */
S#define  BSP_INT_ID_TAMPER                                 2    /* Tamper Interrupt                                     */
S#define  BSP_INT_ID_RTC                                    3    /* RTC global Interrupt                                 */
S#define  BSP_INT_ID_FLASH                                  4    /* FLASH global Interrupt                               */
S#define  BSP_INT_ID_RCC                                    5    /* RCC global Interrupt                                 */
S#define  BSP_INT_ID_EXTI0                                  6    /* EXTI Line0 Interrupt                                 */
S#define  BSP_INT_ID_EXTI1                                  7    /* EXTI Line1 Interrupt                                 */
S#define  BSP_INT_ID_EXTI2                                  8    /* EXTI Line2 Interrupt                                 */
S#define  BSP_INT_ID_EXTI3                                  9    /* EXTI Line3 Interrupt                                 */
S#define  BSP_INT_ID_EXTI4                                 10    /* EXTI Line4 Interrupt                                 */
S#define  BSP_INT_ID_DMA1_CH1                              11    /* DMA1 Channel 1 global Interrupt                      */
S#define  BSP_INT_ID_DMA1_CH2                              12    /* DMA1 Channel 2 global Interrupt                      */
S#define  BSP_INT_ID_DMA1_CH3                              13    /* DMA1 Channel 3 global Interrupt                      */
S#define  BSP_INT_ID_DMA1_CH4                              14    /* DMA1 Channel 4 global Interrupt                      */
S#define  BSP_INT_ID_DMA1_CH5                              15    /* DMA1 Channel 5 global Interrupt                      */
S#define  BSP_INT_ID_DMA1_CH6                              16    /* DMA1 Channel 6 global Interrupt                      */
S#define  BSP_INT_ID_DMA1_CH7                              17    /* DMA1 Channel 7 global Interrupt                      */
S#define  BSP_INT_ID_ADC1_2                                18    /* ADC1 et ADC2 global Interrupt                        */
S#define  BSP_INT_ID_USB_HP_CAN_TX                         19    /* USB High Priority or CAN TX Interrupts               */
S#define  BSP_INT_ID_USB_LP_CAN_RX0                        20    /* USB Low Priority or CAN RX0 Interrupts               */
S#define  BSP_INT_ID_CAN_RX1                               21    /* CAN RX1 Interrupt                                    */
S#define  BSP_INT_ID_CAN_SCE                               22    /* CAN SCE Interrupt                                    */
S#define  BSP_INT_ID_EXTI9_5                               23    /* External Line[9:5] Interrupts                        */
S#define  BSP_INT_ID_TIM1_BRK                              24    /* TIM1 Break Interrupt                                 */
S#define  BSP_INT_ID_TIM1_UP                               25    /* TIM1 Update Interrupt                                */
S#define  BSP_INT_ID_TIM1_TRG_COM                          26    /* TIM1 Trigger and Commutation Interrupt               */
S#define  BSP_INT_ID_TIM1_CC                               27    /* TIM1 Capture Compare Interrupt                       */
S#define  BSP_INT_ID_TIM2                                  28    /* TIM2 global Interrupt                                */
S#define  BSP_INT_ID_TIM3                                  29    /* TIM3 global Interrupt                                */
S#define  BSP_INT_ID_TIM4                                  30    /* TIM4 global Interrupt                                */
S#define  BSP_INT_ID_I2C1_EV                               31    /* I2C1 Event Interrupt                                 */
S#define  BSP_INT_ID_I2C1_ER                               32    /* I2C1 Error Interrupt                                 */
S#define  BSP_INT_ID_I2C2_EV                               33    /* I2C2 Event Interrupt                                 */
S#define  BSP_INT_ID_I2C2_ER                               34    /* I2C2 Error Interrupt                                 */
S#define  BSP_INT_ID_SPI1                                  35    /* SPI1 global Interrupt                                */
S#define  BSP_INT_ID_SPI2                                  36    /* SPI2 global Interrupt                                */
S#define  BSP_INT_ID_USART1                                37    /* USART1 global Interrupt                              */
S#define  BSP_INT_ID_USART2                                38    /* USART2 global Interrupt                              */
S#define  BSP_INT_ID_USART3                                39    /* USART3 global Interrupt                              */
S#define  BSP_INT_ID_EXTI15_10                             40    /* External Line[15:10] Interrupts                      */
S#define  BSP_INT_ID_RTCAlarm                              41    /* RTC Alarm through EXTI Line Interrupt                */
S#define  BSP_INT_ID_USBWakeUp                             42    /* USB WakeUp from suspend through EXTI Line Interrupt  */
S#define  BSP_INT_ID_TIM8_BRK                              43    /* TIM8 Break Interrupt                                 */
S#define  BSP_INT_ID_TIM8_UP                               44    /* TIM8 Update Interrupt                                */
S#define  BSP_INT_ID_TIM8_TRG_COM                          45    /* TIM8 Trigger and Commutation Interrupt               */
S#define  BSP_INT_ID_TIM8_CC                               46    /* TIM8 Capture Compare Interrupt                       */
S#define  BSP_INT_ID_ADC3                                  47    /* ADC3 global Interrupt                                */
S#define  BSP_INT_ID_FSMC                                  48    /* FSMC global Interrupt                                */
S#define  BSP_INT_ID_SDIO                                  49    /* SDIO global Interrupt                                */
S#define  BSP_INT_ID_TIM5                                  50    /* TIM5 global Interrupt                                */
S#define  BSP_INT_ID_SPI3                                  51    /* SPI3 global Interrupt                                */
S#define  BSP_INT_ID_UART4                                 52    /* UART4 global Interrupt                               */
S#define  BSP_INT_ID_UART5                                 53    /* UART5 global Interrupt                               */
S#define  BSP_INT_ID_TIM6                                  54    /* TIM6 global Interrupt                                */
S#define  BSP_INT_ID_TIM7                                  55    /* TIM7 global Interrupt                                */
S#define  BSP_INT_ID_DMA2_CH1                              56    /* DMA2 Channel 1 global Interrupt                      */
S#define  BSP_INT_ID_DMA2_CH2                              57    /* DMA2 Channel 2 global Interrupt                      */
S#define  BSP_INT_ID_DMA2_CH3                              58    /* DMA2 Channel 3 global Interrupt                      */
S#define  BSP_INT_ID_DMA2_CH4_5                            59    /* DMA2 Channel 4 and DMA2 Channel 5 global Interrupt   */
S
S/*
S*********************************************************************************************************
S*                                             PERIPH DEFINES
S*********************************************************************************************************
S*/
S
S#define  BSP_PERIPH_ID_DMA1                                0
S#define  BSP_PERIPH_ID_DMA2                                1
S#define  BSP_PERIPH_ID_SRAM                                2
S#define  BSP_PERIPH_ID_FLITF                               4
S#define  BSP_PERIPH_ID_CRC                                 6
S#define  BSP_PERIPH_ID_FSMC                                8
S#define  BSP_PERIPH_ID_SDIO                               10
S
S#define  BSP_PERIPH_ID_AFIO                               32
S#define  BSP_PERIPH_ID_IOPA                               34
S#define  BSP_PERIPH_ID_IOPB                               35
S#define  BSP_PERIPH_ID_IOPC                               36
S#define  BSP_PERIPH_ID_IOPD                               37
S#define  BSP_PERIPH_ID_IOPE                               38
S#define  BSP_PERIPH_ID_IOPF                               39
S#define  BSP_PERIPH_ID_IOPG                               40
S#define  BSP_PERIPH_ID_ADC1                               41
S#define  BSP_PERIPH_ID_ADC2                               42
S#define  BSP_PERIPH_ID_TIM1                               43
S#define  BSP_PERIPH_ID_SPI1                               44
S#define  BSP_PERIPH_ID_TIM8                               45
S#define  BSP_PERIPH_ID_USART1                             46
S#define  BSP_PERIPH_ID_ADC3                               47
S
S#define  BSP_PERIPH_ID_TIM2                               64
S#define  BSP_PERIPH_ID_TIM3                               65
S#define  BSP_PERIPH_ID_TIM4                               66
S#define  BSP_PERIPH_ID_TIM5                               67
S#define  BSP_PERIPH_ID_TIM6                               68
S#define  BSP_PERIPH_ID_TIM7                               69
S#define  BSP_PERIPH_ID_WWDG                               75
S#define  BSP_PERIPH_ID_SPI2                               78
S#define  BSP_PERIPH_ID_SPI3                               79
S#define  BSP_PERIPH_ID_USART2                             81
S#define  BSP_PERIPH_ID_USART3                             82
S#define  BSP_PERIPH_ID_USART4                             83
S#define  BSP_PERIPH_ID_USART5                             84
S#define  BSP_PERIPH_ID_I2C1                               85
S#define  BSP_PERIPH_ID_I2C2                               86
S#define  BSP_PERIPH_ID_USB                                87
S#define  BSP_PERIPH_ID_CAN                                89
S#define  BSP_PERIPH_ID_BKP                                91
S#define  BSP_PERIPH_ID_PWR                                92
S#define  BSP_PERIPH_ID_DAC                                93
S
S/*
S*********************************************************************************************************
S*                                               DATA TYPES
S*********************************************************************************************************
S*/
S
S
S/*
S*********************************************************************************************************
S*                                            GLOBAL VARIABLES
S*********************************************************************************************************
S*/
S
S
S/*
S*********************************************************************************************************
S*                                                 MACRO'S
S*********************************************************************************************************
S*/
S
S
S/*
S*********************************************************************************************************
S*                                           FUNCTION PROTOTYPES
S*********************************************************************************************************
S*/
S
Svoid         BSP_Init                    (void);
S
Svoid         BSP_IntDisAll               (void);
S
SCPU_INT32U   BSP_CPU_ClkFreq             (void);
S
S/*
S*********************************************************************************************************
S*                                           INTERRUPT SERVICES
S*********************************************************************************************************
S*/
S
Svoid         BSP_IntInit                 (void);
S
Svoid         BSP_IntEn                   (CPU_DATA       int_id);
S
Svoid         BSP_IntDis                  (CPU_DATA       int_id);
S
Svoid         BSP_IntClr                  (CPU_DATA       int_id);
S
Svoid         BSP_IntVectSet              (CPU_DATA       int_id,
S                                          CPU_FNCT_VOID  isr);
S
Svoid         BSP_IntPrioSet              (CPU_DATA       int_id,
S                                          CPU_INT08U     prio);
S
Svoid         BSP_IntHandlerWWDG          (void);
Svoid         BSP_IntHandlerPVD           (void);
Svoid         BSP_IntHandlerTAMPER        (void);
Svoid         BSP_IntHandlerRTC           (void);
Svoid         BSP_IntHandlerFLASH         (void);
Svoid         BSP_IntHandlerRCC           (void);
Svoid         BSP_IntHandlerEXTI0         (void);
Svoid         BSP_IntHandlerEXTI1         (void);
Svoid         BSP_IntHandlerEXTI2         (void);
Svoid         BSP_IntHandlerEXTI3         (void);
Svoid         BSP_IntHandlerEXTI4         (void);
Svoid         BSP_IntHandlerDMA1_CH1      (void);
Svoid         BSP_IntHandlerDMA1_CH2      (void);
Svoid         BSP_IntHandlerDMA1_CH3      (void);
Svoid         BSP_IntHandlerDMA1_CH4      (void);
Svoid         BSP_IntHandlerDMA1_CH5      (void);
S
Svoid         BSP_IntHandlerDMA1_CH6      (void);
Svoid         BSP_IntHandlerDMA1_CH7      (void);
Svoid         BSP_IntHandlerADC1_2        (void);
Svoid         BSP_IntHandlerUSB_HP_CAN_TX (void);
Svoid         BSP_IntHandlerUSB_LP_CAN_RX0(void);
Svoid         BSP_IntHandlerCAN_RX1       (void);
Svoid         BSP_IntHandlerCAN_SCE       (void);
Svoid         BSP_IntHandlerEXTI9_5       (void);
Svoid         BSP_IntHandlerTIM1_BRK      (void);
Svoid         BSP_IntHandlerTIM1_UP       (void);
Svoid         BSP_IntHandlerTIM1_TRG_COM  (void);
Svoid         BSP_IntHandlerTIM1_CC       (void);
Svoid         BSP_IntHandlerTIM2          (void);
Svoid         BSP_IntHandlerTIM3          (void);
Svoid         BSP_IntHandlerTIM4          (void);
Svoid         BSP_IntHandlerI2C1_EV       (void);
S
Svoid         BSP_IntHandlerI2C1_ER       (void);
Svoid         BSP_IntHandlerI2C2_EV       (void);
Svoid         BSP_IntHandlerI2C2_ER       (void);
Svoid         BSP_IntHandlerSPI1          (void);
Svoid         BSP_IntHandlerSPI2          (void);
Svoid         BSP_IntHandlerUSART1        (void);
Svoid         BSP_IntHandlerUSART2        (void);
Svoid         BSP_IntHandlerUSART3        (void);
Svoid         BSP_IntHandlerEXTI15_10     (void);
Svoid         BSP_IntHandlerRTCAlarm      (void);
Svoid         BSP_IntHandlerUSBWakeUp     (void);
S
S/*
S*********************************************************************************************************
S*                                     PERIPHERAL POWER/CLOCK SERVICES
S*********************************************************************************************************
S*/
S
SCPU_INT32U   BSP_PeriphClkFreqGet        (CPU_DATA       pwr_clk_id);
S
Svoid         BSP_PeriphEn                (CPU_DATA       pwr_clk_id);
S
Svoid         BSP_PeriphDis               (CPU_DATA       pwr_clk_id);
S
S/*
S*********************************************************************************************************
S*                                              LED SERVICES
S*********************************************************************************************************
S*/
S
Svoid         BSP_LED_On                  (CPU_INT08U     led);
S
Svoid         BSP_LED_Off                 (CPU_INT08U     led);
S
Svoid         BSP_LED_Toggle              (CPU_INT08U     led);
S
S/*
S*********************************************************************************************************
S*                                               PB SERVICES
S*********************************************************************************************************
S*/
S
SCPU_BOOLEAN  BSP_PB_GetStatus            (CPU_INT08U     pb);
S
S/*
S*********************************************************************************************************
S*                                              ADC SERVICES
S*********************************************************************************************************
S*/
S
SCPU_INT16U   BSP_ADC_GetStatus           (CPU_INT08U     led);
S
S/*
S*********************************************************************************************************
S*                                           JOYSTICK SERVICES
S*********************************************************************************************************
S*/
S
SCPU_INT32U   BSP_Joystick_GetStatus      (void);
S
S/*
S*********************************************************************************************************
S*                                               MODULE END
S*********************************************************************************************************
S*/
S
N#endif                                                          /* End of module include.                               */
L 70 "..\BSP\bsp.h" 2
N
N#include  <ucos_ii.h>
L 1 "..\..\..\..\..\uCOS-II\Source\ucos_ii.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/OS-II
N*                                          The Real-Time Kernel
N*
N*                              (c) Copyright 1992-2007, Micrium, Weston, FL
N*                                           All Rights Reserved
N*
N* File    : uCOS_II.H
N* By      : Jean J. Labrosse
N* Version : V2.86
N*
N* LICENSING TERMS:
N* ---------------
N*   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
N* If you plan on using  uC/OS-II  in a commercial product you need to contact Micrim to properly license
N* its use in your product. We provide ALL the source code for your convenience and to help you experience
N* uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
N* licensing fee.
N*********************************************************************************************************
N*/
N
N#ifndef   OS_uCOS_II_H
N#define   OS_uCOS_II_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*
N*********************************************************************************************************
N*                                          uC/OS-II VERSION NUMBER
N*********************************************************************************************************
N*/
N
N#define  OS_VERSION                 286u                /* Version of uC/OS-II (Vx.yy mult. by 100)    */
N
N/*
N*********************************************************************************************************
N*                                           INCLUDE HEADER FILES
N*********************************************************************************************************
N*/
N
N#include <app_cfg.h>
N#include <os_cfg.h>
L 1 ".\os_cfg.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/OS-II
N*                                          The Real-Time Kernel
N*                                  uC/OS-II Configuration File for V2.8x
N*
N*                               (c) Copyright 2005-2007, Micrium, Weston, FL
N*                                          All Rights Reserved
N*
N*
N* File    : OS_CFG.H
N* By      : Jean J. Labrosse
N* Version : V2.86
N*
N* LICENSING TERMS:
N* ---------------
N*   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.
N* If you plan on using  uC/OS-II  in a commercial product you need to contact Micrim to properly license
N* its use in your product. We provide ALL the source code for your convenience and to help you experience
N* uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a
N* licensing fee.
N*********************************************************************************************************
N*/
N
N#ifndef OS_CFG_H
N#define OS_CFG_H
N
N
N                                       /* ---------------------- MISCELLANEOUS ----------------------- */
N#define OS_APP_HOOKS_EN           1    /* Application-defined hooks are called from the uC/OS-II hooks */
N#define OS_ARG_CHK_EN             0    /* Enable (1) or Disable (0) argument checking                  */
N#define OS_CPU_HOOKS_EN           1    /* uC/OS-II hooks are found in the processor port files         */
N
N#define OS_DEBUG_EN               1    /* Enable(1) debug variables                                    */
N
N#define OS_EVENT_MULTI_EN         1    /* Include code for OSEventPendMulti()                          */
N#define OS_EVENT_NAME_SIZE       16    /* Determine the size of the name of a Sem, Mutex, Mbox or Q    */
N
N#define OS_LOWEST_PRIO           31    /* Defines the lowest priority that can be assigned ...         */
N                                       /* ... MUST NEVER be higher than 254!                           */
N
N#define OS_MAX_EVENTS            10    /* Max. number of event control blocks in your application      */
N#define OS_MAX_FLAGS              5    /* Max. number of Event Flag Groups    in your application      */
N#define OS_MAX_MEM_PART           5    /* Max. number of memory partitions                             */
N#define OS_MAX_QS                 4    /* Max. number of queue control blocks in your application      */
N#define OS_MAX_TASKS             20    /* Max. number of tasks in your application, MUST be >= 2       */
N
N#define OS_SCHED_LOCK_EN          1    /* Include code for OSSchedLock() and OSSchedUnlock()           */
N
N#define OS_TICK_STEP_EN           1    /* Enable tick stepping feature for uC/OS-View                  */
N#define OS_TICKS_PER_SEC       1000    /* Set the number of ticks in one second                        */
N
N
N                                       /* --------------------- TASK STACK SIZE ---------------------- */
N#define OS_TASK_TMR_STK_SIZE    128    /* Timer      task stack size (# of OS_STK wide entries)        */
N#define OS_TASK_STAT_STK_SIZE   128    /* Statistics task stack size (# of OS_STK wide entries)        */
N#define OS_TASK_IDLE_STK_SIZE   128    /* Idle       task stack size (# of OS_STK wide entries)        */
N
N
N                                       /* --------------------- TASK MANAGEMENT ---------------------- */
N#define OS_TASK_CHANGE_PRIO_EN    1    /*     Include code for OSTaskChangePrio()                      */
N#define OS_TASK_CREATE_EN         1    /*     Include code for OSTaskCreate()                          */
N#define OS_TASK_CREATE_EXT_EN     1    /*     Include code for OSTaskCreateExt()                       */
N#define OS_TASK_DEL_EN            1    /*     Include code for OSTaskDel()                             */
N#define OS_TASK_NAME_SIZE        16    /*     Determine the size of a task name                        */
N#define OS_TASK_PROFILE_EN        1    /*     Include variables in OS_TCB for profiling                */
N#define OS_TASK_QUERY_EN          1    /*     Include code for OSTaskQuery()                           */
N#define OS_TASK_STAT_EN           1    /*     Enable (1) or Disable(0) the statistics task             */
N#define OS_TASK_STAT_STK_CHK_EN   1    /*     Check task stacks from statistic task                    */
N#define OS_TASK_SUSPEND_EN        1    /*     Include code for OSTaskSuspend() and OSTaskResume()      */
N#define OS_TASK_SW_HOOK_EN        1    /*     Include code for OSTaskSwHook()                          */
N
N
N                                       /* ----------------------- EVENT FLAGS ------------------------ */
N#define OS_FLAG_EN                1    /* Enable (1) or Disable (0) code generation for EVENT FLAGS    */
N#define OS_FLAG_ACCEPT_EN         1    /*     Include code for OSFlagAccept()                          */
N#define OS_FLAG_DEL_EN            1    /*     Include code for OSFlagDel()                             */
N#define OS_FLAG_NAME_SIZE        16    /*     Determine the size of the name of an event flag group    */
N#define OS_FLAG_QUERY_EN          1    /*     Include code for OSFlagQuery()                           */
N#define OS_FLAG_WAIT_CLR_EN       1    /* Include code for Wait on Clear EVENT FLAGS                   */
N#define OS_FLAGS_NBITS           16    /* Size in #bits of OS_FLAGS data type (8, 16 or 32)            */
N
N
N                                       /* -------------------- MESSAGE MAILBOXES --------------------- */
N#define OS_MBOX_EN                1    /* Enable (1) or Disable (0) code generation for MAILBOXES      */
N#define OS_MBOX_ACCEPT_EN         1    /*     Include code for OSMboxAccept()                          */
N#define OS_MBOX_DEL_EN            1    /*     Include code for OSMboxDel()                             */
N#define OS_MBOX_PEND_ABORT_EN     1    /*     Include code for OSMboxPendAbort()                       */
N#define OS_MBOX_POST_EN           1    /*     Include code for OSMboxPost()                            */
N#define OS_MBOX_POST_OPT_EN       1    /*     Include code for OSMboxPostOpt()                         */
N#define OS_MBOX_QUERY_EN          1    /*     Include code for OSMboxQuery()                           */
N
N
N                                       /* --------------------- MEMORY MANAGEMENT -------------------- */
N#define OS_MEM_EN                 0    /* Enable (1) or Disable (0) code generation for MEMORY MANAGER */
N#define OS_MEM_NAME_SIZE         16    /*     Determine the size of a memory partition name            */
N#define OS_MEM_QUERY_EN           1    /*     Include code for OSMemQuery()                            */
N
N
N                                       /* ---------------- MUTUAL EXCLUSION SEMAPHORES --------------- */
N#define OS_MUTEX_EN               0    /* Enable (1) or Disable (0) code generation for MUTEX          */
N#define OS_MUTEX_ACCEPT_EN        1    /*     Include code for OSMutexAccept()                         */
N#define OS_MUTEX_DEL_EN           1    /*     Include code for OSMutexDel()                            */
N#define OS_MUTEX_QUERY_EN         1    /*     Include code for OSMutexQuery()                          */
N
N
N                                       /* ---------------------- MESSAGE QUEUES ---------------------- */
N#define OS_Q_EN                   0    /* Enable (1) or Disable (0) code generation for QUEUES         */
N#define OS_Q_ACCEPT_EN            1    /*     Include code for OSQAccept()                             */
N#define OS_Q_DEL_EN               1    /*     Include code for OSQDel()                                */
N#define OS_Q_FLUSH_EN             1    /*     Include code for OSQFlush()                              */
N#define OS_Q_PEND_ABORT_EN        1    /*     Include code for OSQPendAbort()                          */
N#define OS_Q_POST_EN              1    /*     Include code for OSQPost()                               */
N#define OS_Q_POST_FRONT_EN        1    /*     Include code for OSQPostFront()                          */
N#define OS_Q_POST_OPT_EN          1    /*     Include code for OSQPostOpt()                            */
N#define OS_Q_QUERY_EN             1    /*     Include code for OSQQuery()                              */
N
N
N                                       /* ------------------------ SEMAPHORES ------------------------ */
N#define OS_SEM_EN                 1    /* Enable (1) or Disable (0) code generation for SEMAPHORES     */
N#define OS_SEM_ACCEPT_EN          1    /*    Include code for OSSemAccept()                            */
N#define OS_SEM_DEL_EN             1    /*    Include code for OSSemDel()                               */
N#define OS_SEM_PEND_ABORT_EN      1    /*    Include code for OSSemPendAbort()                         */
N#define OS_SEM_QUERY_EN           1    /*    Include code for OSSemQuery()                             */
N#define OS_SEM_SET_EN             1    /*    Include code for OSSemSet()                               */
N
N
N                                       /* --------------------- TIME MANAGEMENT ---------------------- */
N#define OS_TIME_DLY_HMSM_EN       1    /*     Include code for OSTimeDlyHMSM()                         */
N#define OS_TIME_DLY_RESUME_EN     1    /*     Include code for OSTimeDlyResume()                       */
N#define OS_TIME_GET_SET_EN        1    /*     Include code for OSTimeGet() and OSTimeSet()             */
N#define OS_TIME_TICK_HOOK_EN      1    /*     Include code for OSTimeTickHook()                        */
N
N
N                                       /* --------------------- TIMER MANAGEMENT --------------------- */
N#define OS_TMR_EN                 0    /* Enable (1) or Disable (0) code generation for TIMERS         */
N#define OS_TMR_CFG_MAX           16    /*     Maximum number of timers                                 */
N#define OS_TMR_CFG_NAME_SIZE     16    /*     Determine the size of a timer name                       */
N#define OS_TMR_CFG_WHEEL_SIZE     8    /*     Size of timer wheel (#Spokes)                            */
N#define OS_TMR_CFG_TICKS_PER_SEC 10    /*     Rate at which timer management task runs (Hz)            */
N
N#endif
L 46 "..\..\..\..\..\uCOS-II\Source\ucos_ii.h" 2
N#include <os_cpu.h>
L 1 "..\..\..\..\..\uCOS-II\Ports\arm-cortex-m3\Generic\RealView\os_cpu.h" 1
N/*
N*********************************************************************************************************
N*                                               uC/OS-II
N*                                         The Real-Time Kernel
N*
N*
N*                                (c) Copyright 2006, Micrium, Weston, FL
N*                                          All Rights Reserved
N*
N*                                           ARM Cortex-M3 Port
N*
N* File      : OS_CPU.H
N* Version   : V2.86
N* By        : Jean J. Labrosse
N*
N* For       : ARMv7M Cortex-M3
N* Mode      : Thumb2
N* Toolchain : RealView Development Suite
N*             RealView Microcontroller Development Kit (MDK)
N*             ARM Developer Suite (ADS)
N*             Keil uVision
N*********************************************************************************************************
N*/
N
N#ifndef  OS_CPU_H
N#define  OS_CPU_H
N
N
N#ifdef   OS_CPU_GLOBALS
S#define  OS_CPU_EXT
N#else
N#define  OS_CPU_EXT  extern
N#endif
N
N/*
N*********************************************************************************************************
N*                                              DATA TYPES
N*                                         (Compiler Specific)
N*********************************************************************************************************
N*/
N
Ntypedef unsigned char  BOOLEAN;
Ntypedef unsigned char  INT8U;                    /* Unsigned  8 bit quantity                           */
Ntypedef signed   char  INT8S;                    /* Signed    8 bit quantity                           */
Ntypedef unsigned short INT16U;                   /* Unsigned 16 bit quantity                           */
Ntypedef signed   short INT16S;                   /* Signed   16 bit quantity                           */
Ntypedef unsigned int   INT32U;                   /* Unsigned 32 bit quantity                           */
Ntypedef signed   int   INT32S;                   /* Signed   32 bit quantity                           */
Ntypedef float          FP32;                     /* Single precision floating point                    */
Ntypedef double         FP64;                     /* Double precision floating point                    */
N
Ntypedef unsigned int   OS_STK;                   /* Each stack entry is 32-bit wide                    */
Ntypedef unsigned int   OS_CPU_SR;                /* Define size of CPU status register (PSR = 32 bits) */
N
N/*
N*********************************************************************************************************
N*                                              Cortex-M1
N*                                      Critical Section Management
N*
N* Method #1:  Disable/Enable interrupts using simple instructions.  After critical section, interrupts
N*             will be enabled even if they were disabled before entering the critical section.
N*             NOT IMPLEMENTED
N*
N* Method #2:  Disable/Enable interrupts by preserving the state of interrupts.  In other words, if
N*             interrupts were disabled before entering the critical section, they will be disabled when
N*             leaving the critical section.
N*             NOT IMPLEMENTED
N*
N* Method #3:  Disable/Enable interrupts by preserving the state of interrupts.  Generally speaking you
N*             would store the state of the interrupt disable flag in the local variable 'cpu_sr' and then
N*             disable interrupts.  'cpu_sr' is allocated in all of uC/OS-II's functions that need to
N*             disable interrupts.  You would restore the interrupt disable state by copying back 'cpu_sr'
N*             into the CPU's status register.
N*********************************************************************************************************
N*/
N
N#define  OS_CRITICAL_METHOD   3
N
N#if OS_CRITICAL_METHOD == 3
X#if 3 == 3
N#define  OS_ENTER_CRITICAL()  {cpu_sr = OS_CPU_SR_Save();}
N#define  OS_EXIT_CRITICAL()   {OS_CPU_SR_Restore(cpu_sr);}
N#endif
N
N/*
N*********************************************************************************************************
N*                                        Cortex-M3 Miscellaneous
N*********************************************************************************************************
N*/
N
N#define  OS_STK_GROWTH        1                   /* Stack grows from HIGH to LOW memory on ARM        */
N
N#define  OS_TASK_SW()         OSCtxSw()
N
N/*
N*********************************************************************************************************
N*                                              PROTOTYPES
N*********************************************************************************************************
N*/
N
N#if OS_CRITICAL_METHOD == 3                       /* See OS_CPU_A.ASM                                  */
X#if 3 == 3                        
NOS_CPU_SR  OS_CPU_SR_Save(void);
Nvoid       OS_CPU_SR_Restore(OS_CPU_SR cpu_sr);
N#endif
N
Nvoid       OSCtxSw(void);
Nvoid       OSIntCtxSw(void);
Nvoid       OSStartHighRdy(void);
N
Nvoid       OS_CPU_PendSVHandler(void);
N
N                                                  /* See OS_CPU_C.C                                    */
Nvoid       OS_CPU_SysTickHandler(void);
Nvoid       OS_CPU_SysTickInit(void);
N
N                                                  /* See BSP.C                                         */
NINT32U     OS_CPU_SysTickClkFreq(void);
N#endif
L 47 "..\..\..\..\..\uCOS-II\Source\ucos_ii.h" 2
N
N/*
N*********************************************************************************************************
N*                                             MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#ifdef   OS_GLOBALS
S#define  OS_EXT
N#else
N#define  OS_EXT  extern
N#endif
N
N#ifndef  OS_FALSE
N#define  OS_FALSE                     0u
N#endif
N
N#ifndef  OS_TRUE
N#define  OS_TRUE                      1u
N#endif
N
N#define  OS_ASCII_NUL          (INT8U)0
N
N#define  OS_PRIO_SELF              0xFFu                /* Indicate SELF priority                      */
N
N#if OS_TASK_STAT_EN > 0
X#if 1 > 0
N#define  OS_N_SYS_TASKS               2u                /* Number of system tasks                      */
N#else
S#define  OS_N_SYS_TASKS               1u
N#endif
N
N#define  OS_TASK_STAT_PRIO  (OS_LOWEST_PRIO - 1)        /* Statistic task priority                     */
N#define  OS_TASK_IDLE_PRIO  (OS_LOWEST_PRIO)            /* IDLE      task priority                     */
N
N#if OS_LOWEST_PRIO <= 63
X#if 31 <= 63
N#define  OS_EVENT_TBL_SIZE ((OS_LOWEST_PRIO) / 8 + 1)   /* Size of event table                         */
N#define  OS_RDY_TBL_SIZE   ((OS_LOWEST_PRIO) / 8 + 1)   /* Size of ready table                         */
N#else
S#define  OS_EVENT_TBL_SIZE ((OS_LOWEST_PRIO) / 16 + 1)  /* Size of event table                         */
S#define  OS_RDY_TBL_SIZE   ((OS_LOWEST_PRIO) / 16 + 1)  /* Size of ready table                         */
N#endif
N
N#define  OS_TASK_IDLE_ID          65535u                /* ID numbers for Idle, Stat and Timer tasks   */
N#define  OS_TASK_STAT_ID          65534u
N#define  OS_TASK_TMR_ID           65533u
N
N#define  OS_EVENT_EN           (((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0) || (OS_SEM_EN > 0) || (OS_MUTEX_EN > 0))
N
N#define  OS_TCB_RESERVED        ((OS_TCB *)1)
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                              TASK STATUS (Bit definition for OSTCBStat)
N*********************************************************************************************************
N*/
N#define  OS_STAT_RDY               0x00u    /* Ready to run                                            */
N#define  OS_STAT_SEM               0x01u    /* Pending on semaphore                                    */
N#define  OS_STAT_MBOX              0x02u    /* Pending on mailbox                                      */
N#define  OS_STAT_Q                 0x04u    /* Pending on queue                                        */
N#define  OS_STAT_SUSPEND           0x08u    /* Task is suspended                                       */
N#define  OS_STAT_MUTEX             0x10u    /* Pending on mutual exclusion semaphore                   */
N#define  OS_STAT_FLAG              0x20u    /* Pending on event flag group                             */
N#define  OS_STAT_MULTI             0x80u    /* Pending on multiple events                              */
N
N#define  OS_STAT_PEND_ANY         (OS_STAT_SEM | OS_STAT_MBOX | OS_STAT_Q | OS_STAT_MUTEX | OS_STAT_FLAG)
N
N/*
N*********************************************************************************************************
N*                           TASK PEND STATUS (Status codes for OSTCBStatPend)
N*********************************************************************************************************
N*/
N#define  OS_STAT_PEND_OK              0u    /* Pending status OK, not pending, or pending complete     */
N#define  OS_STAT_PEND_TO              1u    /* Pending timed out                                       */
N#define  OS_STAT_PEND_ABORT           2u    /* Pending aborted                                         */
N
N/*
N*********************************************************************************************************
N*                                        OS_EVENT types
N*********************************************************************************************************
N*/
N#define  OS_EVENT_TYPE_UNUSED         0u
N#define  OS_EVENT_TYPE_MBOX           1u
N#define  OS_EVENT_TYPE_Q              2u
N#define  OS_EVENT_TYPE_SEM            3u
N#define  OS_EVENT_TYPE_MUTEX          4u
N#define  OS_EVENT_TYPE_FLAG           5u
N
N#define  OS_TMR_TYPE                100u    /* Used to identify Timers ...                             */
N                                            /* ... (Must be different value than OS_EVENT_TYPE_xxx)    */
N
N/*
N*********************************************************************************************************
N*                                         EVENT FLAGS
N*********************************************************************************************************
N*/
N#define  OS_FLAG_WAIT_CLR_ALL         0u    /* Wait for ALL    the bits specified to be CLR (i.e. 0)   */
N#define  OS_FLAG_WAIT_CLR_AND         0u
N
N#define  OS_FLAG_WAIT_CLR_ANY         1u    /* Wait for ANY of the bits specified to be CLR (i.e. 0)   */
N#define  OS_FLAG_WAIT_CLR_OR          1u
N
N#define  OS_FLAG_WAIT_SET_ALL         2u    /* Wait for ALL    the bits specified to be SET (i.e. 1)   */
N#define  OS_FLAG_WAIT_SET_AND         2u
N
N#define  OS_FLAG_WAIT_SET_ANY         3u    /* Wait for ANY of the bits specified to be SET (i.e. 1)   */
N#define  OS_FLAG_WAIT_SET_OR          3u
N
N
N#define  OS_FLAG_CONSUME           0x80u    /* Consume the flags if condition(s) satisfied             */
N
N
N#define  OS_FLAG_CLR                  0u
N#define  OS_FLAG_SET                  1u
N
N/*
N*********************************************************************************************************
N*                                   Values for OSTickStepState
N*
N* Note(s): This feature is used by uC/OS-View.
N*********************************************************************************************************
N*/
N
N#if OS_TICK_STEP_EN > 0
X#if 1 > 0
N#define  OS_TICK_STEP_DIS             0u    /* Stepping is disabled, tick runs as mormal               */
N#define  OS_TICK_STEP_WAIT            1u    /* Waiting for uC/OS-View to set OSTickStepState to _ONCE  */
N#define  OS_TICK_STEP_ONCE            2u    /* Process tick once and wait for next cmd from uC/OS-View */
N#endif
N
N/*
N*********************************************************************************************************
N*       Possible values for 'opt' argument of OSSemDel(), OSMboxDel(), OSQDel() and OSMutexDel()
N*********************************************************************************************************
N*/
N#define  OS_DEL_NO_PEND               0u
N#define  OS_DEL_ALWAYS                1u
N
N/*
N*********************************************************************************************************
N*                                        OS???Pend() OPTIONS
N*
N* These #defines are used to establish the options for OS???PendAbort().
N*********************************************************************************************************
N*/
N#define  OS_PEND_OPT_NONE             0u    /* NO option selected                                      */
N#define  OS_PEND_OPT_BROADCAST        1u    /* Broadcast action to ALL tasks waiting                   */
N
N/*
N*********************************************************************************************************
N*                                     OS???PostOpt() OPTIONS
N*
N* These #defines are used to establish the options for OSMboxPostOpt() and OSQPostOpt().
N*********************************************************************************************************
N*/
N#define  OS_POST_OPT_NONE          0x00u    /* NO option selected                                      */
N#define  OS_POST_OPT_BROADCAST     0x01u    /* Broadcast message to ALL tasks waiting                  */
N#define  OS_POST_OPT_FRONT         0x02u    /* Post to highest priority task waiting                   */
N#define  OS_POST_OPT_NO_SCHED      0x04u    /* Do not call the scheduler if this option is selected    */
N
N/*
N*********************************************************************************************************
N*                                 TASK OPTIONS (see OSTaskCreateExt())
N*********************************************************************************************************
N*/
N#define  OS_TASK_OPT_NONE        0x0000u    /* NO option selected                                      */
N#define  OS_TASK_OPT_STK_CHK     0x0001u    /* Enable stack checking for the task                      */
N#define  OS_TASK_OPT_STK_CLR     0x0002u    /* Clear the stack when the task is create                 */
N#define  OS_TASK_OPT_SAVE_FP     0x0004u    /* Save the contents of any floating-point registers       */
N
N/*
N*********************************************************************************************************
N*                            TIMER OPTIONS (see OSTmrStart() and OSTmrStop())
N*********************************************************************************************************
N*/
N#define  OS_TMR_OPT_NONE              0u    /* No option selected                                      */
N
N#define  OS_TMR_OPT_ONE_SHOT          1u    /* Timer will not automatically restart when it expires    */
N#define  OS_TMR_OPT_PERIODIC          2u    /* Timer will     automatically restart when it expires    */
N
N#define  OS_TMR_OPT_CALLBACK          3u    /* OSTmrStop() option to call 'callback' w/ timer arg.     */
N#define  OS_TMR_OPT_CALLBACK_ARG      4u    /* OSTmrStop() option to call 'callback' w/ new   arg.     */
N
N/*
N*********************************************************************************************************
N*                                            TIMER STATES
N*********************************************************************************************************
N*/
N#define  OS_TMR_STATE_UNUSED          0u
N#define  OS_TMR_STATE_STOPPED         1u
N#define  OS_TMR_STATE_COMPLETED       2u
N#define  OS_TMR_STATE_RUNNING         3u
N
N/*
N*********************************************************************************************************
N*                                             ERROR CODES
N*********************************************************************************************************
N*/
N#define OS_ERR_NONE                   0u
N
N#define OS_ERR_EVENT_TYPE             1u
N#define OS_ERR_PEND_ISR               2u
N#define OS_ERR_POST_NULL_PTR          3u
N#define OS_ERR_PEVENT_NULL            4u
N#define OS_ERR_POST_ISR               5u
N#define OS_ERR_QUERY_ISR              6u
N#define OS_ERR_INVALID_OPT            7u
N#define OS_ERR_PDATA_NULL             9u
N
N#define OS_ERR_TIMEOUT               10u
N#define OS_ERR_EVENT_NAME_TOO_LONG   11u
N#define OS_ERR_PNAME_NULL            12u
N#define OS_ERR_PEND_LOCKED           13u
N#define OS_ERR_PEND_ABORT            14u
N#define OS_ERR_DEL_ISR               15u
N#define OS_ERR_CREATE_ISR            16u
N#define OS_ERR_NAME_GET_ISR          17u
N#define OS_ERR_NAME_SET_ISR          18u
N
N#define OS_ERR_MBOX_FULL             20u
N
N#define OS_ERR_Q_FULL                30u
N#define OS_ERR_Q_EMPTY               31u
N
N#define OS_ERR_PRIO_EXIST            40u
N#define OS_ERR_PRIO                  41u
N#define OS_ERR_PRIO_INVALID          42u
N
N#define OS_ERR_SEM_OVF               50u
N
N#define OS_ERR_TASK_CREATE_ISR       60u
N#define OS_ERR_TASK_DEL              61u
N#define OS_ERR_TASK_DEL_IDLE         62u
N#define OS_ERR_TASK_DEL_REQ          63u
N#define OS_ERR_TASK_DEL_ISR          64u
N#define OS_ERR_TASK_NAME_TOO_LONG    65u
N#define OS_ERR_TASK_NO_MORE_TCB      66u
N#define OS_ERR_TASK_NOT_EXIST        67u
N#define OS_ERR_TASK_NOT_SUSPENDED    68u
N#define OS_ERR_TASK_OPT              69u
N#define OS_ERR_TASK_RESUME_PRIO      70u
N#define OS_ERR_TASK_SUSPEND_IDLE     71u
N#define OS_ERR_TASK_SUSPEND_PRIO     72u
N#define OS_ERR_TASK_WAITING          73u
N
N#define OS_ERR_TIME_NOT_DLY          80u
N#define OS_ERR_TIME_INVALID_MINUTES  81u
N#define OS_ERR_TIME_INVALID_SECONDS  82u
N#define OS_ERR_TIME_INVALID_MS       83u
N#define OS_ERR_TIME_ZERO_DLY         84u
N#define OS_ERR_TIME_DLY_ISR          85u
N
N#define OS_ERR_MEM_INVALID_PART      90u
N#define OS_ERR_MEM_INVALID_BLKS      91u
N#define OS_ERR_MEM_INVALID_SIZE      92u
N#define OS_ERR_MEM_NO_FREE_BLKS      93u
N#define OS_ERR_MEM_FULL              94u
N#define OS_ERR_MEM_INVALID_PBLK      95u
N#define OS_ERR_MEM_INVALID_PMEM      96u
N#define OS_ERR_MEM_INVALID_PDATA     97u
N#define OS_ERR_MEM_INVALID_ADDR      98u
N#define OS_ERR_MEM_NAME_TOO_LONG     99u
N
N#define OS_ERR_NOT_MUTEX_OWNER      100u
N
N#define OS_ERR_FLAG_INVALID_PGRP    110u
N#define OS_ERR_FLAG_WAIT_TYPE       111u
N#define OS_ERR_FLAG_NOT_RDY         112u
N#define OS_ERR_FLAG_INVALID_OPT     113u
N#define OS_ERR_FLAG_GRP_DEPLETED    114u
N#define OS_ERR_FLAG_NAME_TOO_LONG   115u
N
N#define OS_ERR_PIP_LOWER            120u
N
N#define OS_ERR_TMR_INVALID_DLY      130u
N#define OS_ERR_TMR_INVALID_PERIOD   131u
N#define OS_ERR_TMR_INVALID_OPT      132u
N#define OS_ERR_TMR_INVALID_NAME     133u
N#define OS_ERR_TMR_NON_AVAIL        134u
N#define OS_ERR_TMR_INACTIVE         135u
N#define OS_ERR_TMR_INVALID_DEST     136u
N#define OS_ERR_TMR_INVALID_TYPE     137u
N#define OS_ERR_TMR_INVALID          138u
N#define OS_ERR_TMR_ISR              139u
N#define OS_ERR_TMR_NAME_TOO_LONG    140u
N#define OS_ERR_TMR_INVALID_STATE    141u
N#define OS_ERR_TMR_STOPPED          142u
N#define OS_ERR_TMR_NO_CALLBACK      143u
N
N/*
N*********************************************************************************************************
N*                                    OLD ERROR CODE NAMES (< V2.84)
N*********************************************************************************************************
N*/
N#define OS_NO_ERR                    OS_ERR_NONE
N#define OS_TIMEOUT                   OS_ERR_TIMEOUT
N#define OS_TASK_NOT_EXIST            OS_ERR_TASK_NOT_EXIST
N#define OS_MBOX_FULL                 OS_ERR_MBOX_FULL
N#define OS_Q_FULL                    OS_ERR_Q_FULL
N#define OS_Q_EMPTY                   OS_ERR_Q_EMPTY
N#define OS_PRIO_EXIST                OS_ERR_PRIO_EXIST
N#define OS_PRIO_ERR                  OS_ERR_PRIO
N#define OS_PRIO_INVALID              OS_ERR_PRIO_INVALID
N#define OS_SEM_OVF                   OS_ERR_SEM_OVF
N#define OS_TASK_DEL_ERR              OS_ERR_TASK_DEL
N#define OS_TASK_DEL_IDLE             OS_ERR_TASK_DEL_IDLE
N#define OS_TASK_DEL_REQ              OS_ERR_TASK_DEL_REQ
N#define OS_TASK_DEL_ISR              OS_ERR_TASK_DEL_ISR
N#define OS_NO_MORE_TCB               OS_ERR_TASK_NO_MORE_TCB
N#define OS_TIME_NOT_DLY              OS_ERR_TIME_NOT_DLY
N#define OS_TIME_INVALID_MINUTES      OS_ERR_TIME_INVALID_MINUTES
N#define OS_TIME_INVALID_SECONDS      OS_ERR_TIME_INVALID_SECONDS
N#define OS_TIME_INVALID_MS           OS_ERR_TIME_INVALID_MS
N#define OS_TIME_ZERO_DLY             OS_ERR_TIME_ZERO_DLY
N#define OS_TASK_SUSPEND_PRIO         OS_ERR_TASK_SUSPEND_PRIO
N#define OS_TASK_SUSPEND_IDLE         OS_ERR_TASK_SUSPEND_IDLE
N#define OS_TASK_RESUME_PRIO          OS_ERR_TASK_RESUME_PRIO
N#define OS_TASK_NOT_SUSPENDED        OS_ERR_TASK_NOT_SUSPENDED
N#define OS_MEM_INVALID_PART          OS_ERR_MEM_INVALID_PART
N#define OS_MEM_INVALID_BLKS          OS_ERR_MEM_INVALID_BLKS
N#define OS_MEM_INVALID_SIZE          OS_ERR_MEM_INVALID_SIZE
N#define OS_MEM_NO_FREE_BLKS          OS_ERR_MEM_NO_FREE_BLKS
N#define OS_MEM_FULL                  OS_ERR_MEM_FULL
N#define OS_MEM_INVALID_PBLK          OS_ERR_MEM_INVALID_PBLK
N#define OS_MEM_INVALID_PMEM          OS_ERR_MEM_INVALID_PMEM
N#define OS_MEM_INVALID_PDATA         OS_ERR_MEM_INVALID_PDATA
N#define OS_MEM_INVALID_ADDR          OS_ERR_MEM_INVALID_ADDR
N#define OS_MEM_NAME_TOO_LONG         OS_ERR_MEM_NAME_TOO_LONG
N#define OS_TASK_OPT_ERR              OS_ERR_TASK_OPT
N#define OS_FLAG_INVALID_PGRP         OS_ERR_FLAG_INVALID_PGRP
N#define OS_FLAG_ERR_WAIT_TYPE        OS_ERR_FLAG_WAIT_TYPE
N#define OS_FLAG_ERR_NOT_RDY          OS_ERR_FLAG_NOT_RDY
N#define OS_FLAG_INVALID_OPT          OS_ERR_FLAG_INVALID_OPT
N#define OS_FLAG_GRP_DEPLETED         OS_ERR_FLAG_GRP_DEPLETED
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          EVENT CONTROL BLOCK
N*********************************************************************************************************
N*/
N
N#if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
X#if ((((0 > 0) && (4 > 0)) || (1 > 0) || (1 > 0) || (0 > 0))) && (10 > 0)
Ntypedef struct os_event {
N    INT8U    OSEventType;                    /* Type of event control block (see OS_EVENT_TYPE_xxxx)    */
N    void    *OSEventPtr;                     /* Pointer to message or queue structure                   */
N    INT16U   OSEventCnt;                     /* Semaphore Count (not used if other EVENT type)          */
N#if OS_LOWEST_PRIO <= 63
X#if 31 <= 63
N    INT8U    OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N    INT8U    OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
X    INT8U    OSEventTbl[((31) / 8 + 1)];   
N#else
S    INT16U   OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
S    INT16U   OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
N#endif
N
N#if OS_EVENT_NAME_SIZE > 1
X#if 16 > 1
N    INT8U    OSEventName[OS_EVENT_NAME_SIZE];
X    INT8U    OSEventName[16];
N#endif
N} OS_EVENT;
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                       EVENT FLAGS CONTROL BLOCK
N*********************************************************************************************************
N*/
N
N#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
X#if (1 > 0) && (5 > 0)
N
N#if OS_FLAGS_NBITS == 8                     /* Determine the size of OS_FLAGS (8, 16 or 32 bits)       */
X#if 16 == 8                      
Stypedef  INT8U    OS_FLAGS;
N#endif
N
N#if OS_FLAGS_NBITS == 16
X#if 16 == 16
Ntypedef  INT16U   OS_FLAGS;
N#endif
N
N#if OS_FLAGS_NBITS == 32
X#if 16 == 32
Stypedef  INT32U   OS_FLAGS;
N#endif
N
N
Ntypedef struct os_flag_grp {                /* Event Flag Group                                        */
N    INT8U         OSFlagType;               /* Should be set to OS_EVENT_TYPE_FLAG                     */
N    void         *OSFlagWaitList;           /* Pointer to first NODE of task waiting on event flag     */
N    OS_FLAGS      OSFlagFlags;              /* 8, 16 or 32 bit flags                                   */
N#if OS_FLAG_NAME_SIZE > 1
X#if 16 > 1
N    INT8U         OSFlagName[OS_FLAG_NAME_SIZE];
X    INT8U         OSFlagName[16];
N#endif
N} OS_FLAG_GRP;
N
N
N
Ntypedef struct os_flag_node {               /* Event Flag Wait List Node                               */
N    void         *OSFlagNodeNext;           /* Pointer to next     NODE in wait list                   */
N    void         *OSFlagNodePrev;           /* Pointer to previous NODE in wait list                   */
N    void         *OSFlagNodeTCB;            /* Pointer to TCB of waiting task                          */
N    void         *OSFlagNodeFlagGrp;        /* Pointer to Event Flag Group                             */
N    OS_FLAGS      OSFlagNodeFlags;          /* Event flag to wait on                                   */
N    INT8U         OSFlagNodeWaitType;       /* Type of wait:                                           */
N                                            /*      OS_FLAG_WAIT_AND                                   */
N                                            /*      OS_FLAG_WAIT_ALL                                   */
N                                            /*      OS_FLAG_WAIT_OR                                    */
N                                            /*      OS_FLAG_WAIT_ANY                                   */
N} OS_FLAG_NODE;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          MESSAGE MAILBOX DATA
N*********************************************************************************************************
N*/
N
N#if OS_MBOX_EN > 0
X#if 1 > 0
Ntypedef struct os_mbox_data {
N    void   *OSMsg;                         /* Pointer to message in mailbox                            */
N#if OS_LOWEST_PRIO <= 63
X#if 31 <= 63
N    INT8U   OSEventTbl[OS_EVENT_TBL_SIZE]; /* List of tasks waiting for event to occur                 */
X    INT8U   OSEventTbl[((31) / 8 + 1)];  
N    INT8U   OSEventGrp;                    /* Group corresponding to tasks waiting for event to occur  */
N#else
S    INT16U  OSEventTbl[OS_EVENT_TBL_SIZE]; /* List of tasks waiting for event to occur                 */
S    INT16U  OSEventGrp;                    /* Group corresponding to tasks waiting for event to occur  */
N#endif
N} OS_MBOX_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                     MEMORY PARTITION DATA STRUCTURES
N*********************************************************************************************************
N*/
N
N#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
X#if (0 > 0) && (5 > 0)
Stypedef struct os_mem {                   /* MEMORY CONTROL BLOCK                                      */
S    void   *OSMemAddr;                    /* Pointer to beginning of memory partition                  */
S    void   *OSMemFreeList;                /* Pointer to list of free memory blocks                     */
S    INT32U  OSMemBlkSize;                 /* Size (in bytes) of each block of memory                   */
S    INT32U  OSMemNBlks;                   /* Total number of blocks in this partition                  */
S    INT32U  OSMemNFree;                   /* Number of memory blocks remaining in this partition       */
S#if OS_MEM_NAME_SIZE > 1
S    INT8U   OSMemName[OS_MEM_NAME_SIZE];  /* Memory partition name                                     */
S#endif
S} OS_MEM;
S
S
Stypedef struct os_mem_data {
S    void   *OSAddr;                    /* Pointer to the beginning address of the memory partition     */
S    void   *OSFreeList;                /* Pointer to the beginning of the free list of memory blocks   */
S    INT32U  OSBlkSize;                 /* Size (in bytes) of each memory block                         */
S    INT32U  OSNBlks;                   /* Total number of blocks in the partition                      */
S    INT32U  OSNFree;                   /* Number of memory blocks free                                 */
S    INT32U  OSNUsed;                   /* Number of memory blocks used                                 */
S} OS_MEM_DATA;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                    MUTUAL EXCLUSION SEMAPHORE DATA
N*********************************************************************************************************
N*/
N
N#if OS_MUTEX_EN > 0
X#if 0 > 0
Stypedef struct os_mutex_data {
S#if OS_LOWEST_PRIO <= 63
S    INT8U   OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
S    INT8U   OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
S#else
S    INT16U  OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
S    INT16U  OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
S#endif
S    BOOLEAN OSValue;                        /* Mutex value (OS_FALSE = used, OS_TRUE = available)      */
S    INT8U   OSOwnerPrio;                    /* Mutex owner's task priority or 0xFF if no owner         */
S    INT8U   OSMutexPIP;                     /* Priority Inheritance Priority or 0xFF if no owner       */
S} OS_MUTEX_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                          MESSAGE QUEUE DATA
N*********************************************************************************************************
N*/
N
N#if OS_Q_EN > 0
X#if 0 > 0
Stypedef struct os_q {                   /* QUEUE CONTROL BLOCK                                         */
S    struct os_q   *OSQPtr;              /* Link to next queue control block in list of free blocks     */
S    void         **OSQStart;            /* Pointer to start of queue data                              */
S    void         **OSQEnd;              /* Pointer to end   of queue data                              */
S    void         **OSQIn;               /* Pointer to where next message will be inserted  in   the Q  */
S    void         **OSQOut;              /* Pointer to where next message will be extracted from the Q  */
S    INT16U         OSQSize;             /* Size of queue (maximum number of entries)                   */
S    INT16U         OSQEntries;          /* Current number of entries in the queue                      */
S} OS_Q;
S
S
Stypedef struct os_q_data {
S    void          *OSMsg;               /* Pointer to next message to be extracted from queue          */
S    INT16U         OSNMsgs;             /* Number of messages in message queue                         */
S    INT16U         OSQSize;             /* Size of message queue                                       */
S#if OS_LOWEST_PRIO <= 63
S    INT8U          OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur         */
S    INT8U          OSEventGrp;          /* Group corresponding to tasks waiting for event to occur     */
S#else
S    INT16U         OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur         */
S    INT16U         OSEventGrp;          /* Group corresponding to tasks waiting for event to occur     */
S#endif
S} OS_Q_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                           SEMAPHORE DATA
N*********************************************************************************************************
N*/
N
N#if OS_SEM_EN > 0
X#if 1 > 0
Ntypedef struct os_sem_data {
N    INT16U  OSCnt;                          /* Semaphore count                                         */
N#if OS_LOWEST_PRIO <= 63
X#if 31 <= 63
N    INT8U   OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
X    INT8U   OSEventTbl[((31) / 8 + 1)];   
N    INT8U   OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N#else
S    INT16U  OSEventTbl[OS_EVENT_TBL_SIZE];  /* List of tasks waiting for event to occur                */
S    INT16U  OSEventGrp;                     /* Group corresponding to tasks waiting for event to occur */
N#endif
N} OS_SEM_DATA;
N#endif
N
N/*
N*********************************************************************************************************
N*                                            TASK STACK DATA
N*********************************************************************************************************
N*/
N
N#if OS_TASK_CREATE_EXT_EN > 0
X#if 1 > 0
Ntypedef struct os_stk_data {
N    INT32U  OSFree;                    /* Number of free bytes on the stack                            */
N    INT32U  OSUsed;                    /* Number of bytes used on the stack                            */
N} OS_STK_DATA;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          TASK CONTROL BLOCK
N*********************************************************************************************************
N*/
N
Ntypedef struct os_tcb {
N    OS_STK          *OSTCBStkPtr;           /* Pointer to current top of stack                         */
N
N#if OS_TASK_CREATE_EXT_EN > 0
X#if 1 > 0
N    void            *OSTCBExtPtr;           /* Pointer to user definable data for TCB extension        */
N    OS_STK          *OSTCBStkBottom;        /* Pointer to bottom of stack                              */
N    INT32U           OSTCBStkSize;          /* Size of task stack (in number of stack elements)        */
N    INT16U           OSTCBOpt;              /* Task options as passed by OSTaskCreateExt()             */
N    INT16U           OSTCBId;               /* Task ID (0..65535)                                      */
N#endif
N
N    struct os_tcb   *OSTCBNext;             /* Pointer to next     TCB in the TCB list                 */
N    struct os_tcb   *OSTCBPrev;             /* Pointer to previous TCB in the TCB list                 */
N
N#if (OS_EVENT_EN) || (OS_FLAG_EN > 0)
X#if ((((0 > 0) && (4 > 0)) || (1 > 0) || (1 > 0) || (0 > 0))) || (1 > 0)
N    OS_EVENT        *OSTCBEventPtr;         /* Pointer to          event control block                 */
N#endif
N
N#if (OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0)
X#if ((((0 > 0) && (4 > 0)) || (1 > 0) || (1 > 0) || (0 > 0))) && (1 > 0)
N    OS_EVENT       **OSTCBEventMultiPtr;    /* Pointer to multiple event control blocks                */
N#endif
N
N#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
X#if ((0 > 0) && (4 > 0)) || (1 > 0)
N    void            *OSTCBMsg;              /* Message received from OSMboxPost() or OSQPost()         */
N#endif
N
N#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
X#if (1 > 0) && (5 > 0)
N#if OS_TASK_DEL_EN > 0
X#if 1 > 0
N    OS_FLAG_NODE    *OSTCBFlagNode;         /* Pointer to event flag node                              */
N#endif
N    OS_FLAGS         OSTCBFlagsRdy;         /* Event flags that made task ready to run                 */
N#endif
N
N    INT16U           OSTCBDly;              /* Nbr ticks to delay task or, timeout waiting for event   */
N    INT8U            OSTCBStat;             /* Task      status                                        */
N    INT8U            OSTCBStatPend;         /* Task PEND status                                        */
N    INT8U            OSTCBPrio;             /* Task priority (0 == highest)                            */
N
N    INT8U            OSTCBX;                /* Bit position in group  corresponding to task priority   */
N    INT8U            OSTCBY;                /* Index into ready table corresponding to task priority   */
N#if OS_LOWEST_PRIO <= 63
X#if 31 <= 63
N    INT8U            OSTCBBitX;             /* Bit mask to access bit position in ready table          */
N    INT8U            OSTCBBitY;             /* Bit mask to access bit position in ready group          */
N#else
S    INT16U           OSTCBBitX;             /* Bit mask to access bit position in ready table          */
S    INT16U           OSTCBBitY;             /* Bit mask to access bit position in ready group          */
N#endif
N
N#if OS_TASK_DEL_EN > 0
X#if 1 > 0
N    INT8U            OSTCBDelReq;           /* Indicates whether a task needs to delete itself         */
N#endif
N
N#if OS_TASK_PROFILE_EN > 0
X#if 1 > 0
N    INT32U           OSTCBCtxSwCtr;         /* Number of time the task was switched in                 */
N    INT32U           OSTCBCyclesTot;        /* Total number of clock cycles the task has been running  */
N    INT32U           OSTCBCyclesStart;      /* Snapshot of cycle counter at start of task resumption   */
N    OS_STK          *OSTCBStkBase;          /* Pointer to the beginning of the task stack              */
N    INT32U           OSTCBStkUsed;          /* Number of bytes used from the stack                     */
N#endif
N
N#if OS_TASK_NAME_SIZE > 1
X#if 16 > 1
N    INT8U            OSTCBTaskName[OS_TASK_NAME_SIZE];
X    INT8U            OSTCBTaskName[16];
N#endif
N} OS_TCB;
N
N/*$PAGE*/
N/*
N************************************************************************************************************************
N*                                                   TIMER DATA TYPES
N************************************************************************************************************************
N*/
N
N#if OS_TMR_EN > 0
X#if 0 > 0
Stypedef  void (*OS_TMR_CALLBACK)(void *ptmr, void *parg);
S
S
S
Stypedef  struct  os_tmr {
S    INT8U            OSTmrType;                       /* Should be set to OS_TMR_TYPE                                  */
S    OS_TMR_CALLBACK  OSTmrCallback;                   /* Function to call when timer expires                           */
S    void            *OSTmrCallbackArg;                /* Argument to pass to function when timer expires               */
S    void            *OSTmrNext;                       /* Double link list pointers                                     */
S    void            *OSTmrPrev;
S    INT32U           OSTmrMatch;                      /* Timer expires when OSTmrTime == OSTmrMatch                    */
S    INT32U           OSTmrDly;                        /* Delay time before periodic update starts                      */
S    INT32U           OSTmrPeriod;                     /* Period to repeat timer                                        */
S#if OS_TMR_CFG_NAME_SIZE > 0
S    INT8U            OSTmrName[OS_TMR_CFG_NAME_SIZE]; /* Name to give the timer                                        */
S#endif
S    INT8U            OSTmrOpt;                        /* Options (see OS_TMR_OPT_xxx)                                  */
S    INT8U            OSTmrState;                      /* Indicates the state of the timer:                             */
S                                                      /*     OS_TMR_STATE_UNUSED                                       */
S                                                      /*     OS_TMR_STATE_RUNNING                                      */
S                                                      /*     OS_TMR_STATE_STOPPED                                      */
S} OS_TMR;
S
S
S
Stypedef  struct  os_tmr_wheel {
S    OS_TMR          *OSTmrFirst;                      /* Pointer to first timer in linked list                         */
S    INT16U           OSTmrEntries;
S} OS_TMR_WHEEL;
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
NOS_EXT  INT32U            OSCtxSwCtr;               /* Counter of number of context switches           */
Xextern  INT32U            OSCtxSwCtr;                
N
N#if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0)
X#if ((((0 > 0) && (4 > 0)) || (1 > 0) || (1 > 0) || (0 > 0))) && (10 > 0)
NOS_EXT  OS_EVENT         *OSEventFreeList;          /* Pointer to list of free EVENT control blocks    */
Xextern  OS_EVENT         *OSEventFreeList;           
NOS_EXT  OS_EVENT          OSEventTbl[OS_MAX_EVENTS];/* Table of EVENT control blocks                   */
Xextern  OS_EVENT          OSEventTbl[10]; 
N#endif
N
N#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
X#if (1 > 0) && (5 > 0)
NOS_EXT  OS_FLAG_GRP       OSFlagTbl[OS_MAX_FLAGS];  /* Table containing event flag groups              */
Xextern  OS_FLAG_GRP       OSFlagTbl[5];   
NOS_EXT  OS_FLAG_GRP      *OSFlagFreeList;           /* Pointer to free list of event flag groups       */
Xextern  OS_FLAG_GRP      *OSFlagFreeList;            
N#endif
N
N#if OS_TASK_STAT_EN > 0
X#if 1 > 0
NOS_EXT  INT8U             OSCPUUsage;               /* Percentage of CPU used                          */
Xextern  INT8U             OSCPUUsage;                
NOS_EXT  INT32U            OSIdleCtrMax;             /* Max. value that idle ctr can take in 1 sec.     */
Xextern  INT32U            OSIdleCtrMax;              
NOS_EXT  INT32U            OSIdleCtrRun;             /* Val. reached by idle ctr at run time in 1 sec.  */
Xextern  INT32U            OSIdleCtrRun;              
NOS_EXT  BOOLEAN           OSStatRdy;                /* Flag indicating that the statistic task is rdy  */
Xextern  BOOLEAN           OSStatRdy;                 
NOS_EXT  OS_STK            OSTaskStatStk[OS_TASK_STAT_STK_SIZE];      /* Statistics task stack          */
Xextern  OS_STK            OSTaskStatStk[128];       
N#endif
N
NOS_EXT  INT8U             OSIntNesting;             /* Interrupt nesting level                         */
Xextern  INT8U             OSIntNesting;              
N
NOS_EXT  INT8U             OSLockNesting;            /* Multitasking lock nesting level                 */
Xextern  INT8U             OSLockNesting;             
N
NOS_EXT  INT8U             OSPrioCur;                /* Priority of current task                        */
Xextern  INT8U             OSPrioCur;                 
NOS_EXT  INT8U             OSPrioHighRdy;            /* Priority of highest priority task               */
Xextern  INT8U             OSPrioHighRdy;             
N
N#if OS_LOWEST_PRIO <= 63
X#if 31 <= 63
NOS_EXT  INT8U             OSRdyGrp;                        /* Ready list group                         */
Xextern  INT8U             OSRdyGrp;                         
NOS_EXT  INT8U             OSRdyTbl[OS_RDY_TBL_SIZE];       /* Table of tasks which are ready to run    */
Xextern  INT8U             OSRdyTbl[((31) / 8 + 1)];        
N#else
SOS_EXT  INT16U            OSRdyGrp;                        /* Ready list group                         */
SOS_EXT  INT16U            OSRdyTbl[OS_RDY_TBL_SIZE];       /* Table of tasks which are ready to run    */
N#endif
N
NOS_EXT  BOOLEAN           OSRunning;                       /* Flag indicating that kernel is running   */
Xextern  BOOLEAN           OSRunning;                        
N
NOS_EXT  INT8U             OSTaskCtr;                       /* Number of tasks created                  */
Xextern  INT8U             OSTaskCtr;                        
N
NOS_EXT  volatile  INT32U  OSIdleCtr;                                 /* Idle counter                   */
Xextern  volatile  INT32U  OSIdleCtr;                                  
N
NOS_EXT  OS_STK            OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE];      /* Idle task stack                */
Xextern  OS_STK            OSTaskIdleStk[128];       
N
N
NOS_EXT  OS_TCB           *OSTCBCur;                        /* Pointer to currently running TCB         */
Xextern  OS_TCB           *OSTCBCur;                         
NOS_EXT  OS_TCB           *OSTCBFreeList;                   /* Pointer to list of free TCBs             */
Xextern  OS_TCB           *OSTCBFreeList;                    
NOS_EXT  OS_TCB           *OSTCBHighRdy;                    /* Pointer to highest priority TCB R-to-R   */
Xextern  OS_TCB           *OSTCBHighRdy;                     
NOS_EXT  OS_TCB           *OSTCBList;                       /* Pointer to doubly linked list of TCBs    */
Xextern  OS_TCB           *OSTCBList;                        
NOS_EXT  OS_TCB           *OSTCBPrioTbl[OS_LOWEST_PRIO + 1];/* Table of pointers to created TCBs        */
Xextern  OS_TCB           *OSTCBPrioTbl[31 + 1]; 
NOS_EXT  OS_TCB            OSTCBTbl[OS_MAX_TASKS + OS_N_SYS_TASKS];   /* Table of TCBs                  */
Xextern  OS_TCB            OSTCBTbl[20 + 2u];    
N
N#if OS_TICK_STEP_EN > 0
X#if 1 > 0
NOS_EXT  INT8U             OSTickStepState;          /* Indicates the state of the tick step feature    */
Xextern  INT8U             OSTickStepState;           
N#endif
N
N#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
X#if (0 > 0) && (5 > 0)
SOS_EXT  OS_MEM           *OSMemFreeList;            /* Pointer to free list of memory partitions       */
SOS_EXT  OS_MEM            OSMemTbl[OS_MAX_MEM_PART];/* Storage for memory partition manager            */
N#endif
N
N#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
X#if (0 > 0) && (4 > 0)
SOS_EXT  OS_Q             *OSQFreeList;              /* Pointer to list of free QUEUE control blocks    */
SOS_EXT  OS_Q              OSQTbl[OS_MAX_QS];        /* Table of QUEUE control blocks                   */
N#endif
N
N#if OS_TIME_GET_SET_EN > 0
X#if 1 > 0
NOS_EXT  volatile  INT32U  OSTime;                   /* Current value of system time (in ticks)         */
Xextern  volatile  INT32U  OSTime;                    
N#endif
N
N#if OS_TMR_EN > 0
X#if 0 > 0
SOS_EXT  INT16U            OSTmrFree;                /* Number of free entries in the timer pool        */
SOS_EXT  INT16U            OSTmrUsed;                /* Number of timers used                           */
SOS_EXT  INT32U            OSTmrTime;                /* Current timer time                              */
S
SOS_EXT  OS_EVENT         *OSTmrSem;                 /* Sem. used to gain exclusive access to timers    */
SOS_EXT  OS_EVENT         *OSTmrSemSignal;           /* Sem. used to signal the update of timers        */
S
SOS_EXT  OS_TMR            OSTmrTbl[OS_TMR_CFG_MAX]; /* Table containing pool of timers                 */
SOS_EXT  OS_TMR           *OSTmrFreeList;            /* Pointer to free list of timers                  */
SOS_EXT  OS_STK            OSTmrTaskStk[OS_TASK_TMR_STK_SIZE];
S
SOS_EXT  OS_TMR_WHEEL      OSTmrWheelTbl[OS_TMR_CFG_WHEEL_SIZE];
N#endif
N
Nextern  INT8U   const     OSUnMapTbl[256];          /* Priority->Index    lookup table                 */
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                     (Target Independent Functions)
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                            MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#if (OS_EVENT_EN)
X#if ((((0 > 0) && (4 > 0)) || (1 > 0) || (1 > 0) || (0 > 0)))
N
N#if (OS_EVENT_NAME_SIZE > 1)
X#if (16 > 1)
NINT8U         OSEventNameGet          (OS_EVENT        *pevent,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N
Nvoid          OSEventNameSet          (OS_EVENT        *pevent,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
N#if (OS_EVENT_MULTI_EN > 0)
X#if (1 > 0)
NINT16U        OSEventPendMulti        (OS_EVENT       **pevents_pend,
N                                       OS_EVENT       **pevents_rdy,
N                                       void           **pmsgs_rdy,
N                                       INT16U           timeout,
N                                       INT8U           *perr);
N#endif
N
N#endif
N
N/*
N*********************************************************************************************************
N*                                         EVENT FLAGS MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
X#if (1 > 0) && (5 > 0)
N
N#if OS_FLAG_ACCEPT_EN > 0
X#if 1 > 0
NOS_FLAGS      OSFlagAccept            (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            wait_type,
N                                       INT8U           *perr);
N#endif
N
NOS_FLAG_GRP  *OSFlagCreate            (OS_FLAGS         flags,
N                                      INT8U            *perr);
N
N#if OS_FLAG_DEL_EN > 0
X#if 1 > 0
NOS_FLAG_GRP  *OSFlagDel               (OS_FLAG_GRP     *pgrp,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
N#if (OS_FLAG_EN > 0) && (OS_FLAG_NAME_SIZE > 1)
X#if (1 > 0) && (16 > 1)
NINT8U         OSFlagNameGet           (OS_FLAG_GRP     *pgrp,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N
Nvoid          OSFlagNameSet           (OS_FLAG_GRP     *pgrp,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
NOS_FLAGS      OSFlagPend              (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            wait_type,
N                                       INT16U           timeout,
N                                       INT8U           *perr);
N
NOS_FLAGS      OSFlagPendGetFlagsRdy   (void);
NOS_FLAGS      OSFlagPost              (OS_FLAG_GRP     *pgrp,
N                                       OS_FLAGS         flags,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N
N#if OS_FLAG_QUERY_EN > 0
X#if 1 > 0
NOS_FLAGS      OSFlagQuery             (OS_FLAG_GRP     *pgrp,
N                                       INT8U           *perr);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                        MESSAGE MAILBOX MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_MBOX_EN > 0
X#if 1 > 0
N
N#if OS_MBOX_ACCEPT_EN > 0
X#if 1 > 0
Nvoid         *OSMboxAccept            (OS_EVENT        *pevent);
N#endif
N
NOS_EVENT     *OSMboxCreate            (void            *pmsg);
N
N#if OS_MBOX_DEL_EN > 0
X#if 1 > 0
NOS_EVENT     *OSMboxDel               (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
Nvoid         *OSMboxPend              (OS_EVENT        *pevent,
N                                       INT16U           timeout,
N                                       INT8U           *perr);
N
N#if OS_MBOX_PEND_ABORT_EN > 0
X#if 1 > 0
NINT8U         OSMboxPendAbort         (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
N#if OS_MBOX_POST_EN > 0
X#if 1 > 0
NINT8U         OSMboxPost              (OS_EVENT        *pevent,
N                                       void            *pmsg);
N#endif
N
N#if OS_MBOX_POST_OPT_EN > 0
X#if 1 > 0
NINT8U         OSMboxPostOpt           (OS_EVENT        *pevent,
N                                       void            *pmsg,
N                                       INT8U            opt);
N#endif
N
N#if OS_MBOX_QUERY_EN > 0
X#if 1 > 0
NINT8U         OSMboxQuery             (OS_EVENT        *pevent,
N                                       OS_MBOX_DATA    *p_mbox_data);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           MEMORY MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
X#if (0 > 0) && (5 > 0)
S
SOS_MEM       *OSMemCreate             (void            *addr,
S                                       INT32U           nblks,
S                                       INT32U           blksize,
S                                       INT8U           *perr);
S
Svoid         *OSMemGet                (OS_MEM          *pmem,
S                                       INT8U           *perr);
S#if OS_MEM_NAME_SIZE > 1
SINT8U         OSMemNameGet            (OS_MEM          *pmem,
S                                       INT8U           *pname,
S                                       INT8U           *perr);
S
Svoid          OSMemNameSet            (OS_MEM          *pmem,
S                                       INT8U           *pname,
S                                       INT8U           *perr);
S#endif
SINT8U         OSMemPut                (OS_MEM          *pmem,
S                                       void            *pblk);
S
S#if OS_MEM_QUERY_EN > 0
SINT8U         OSMemQuery              (OS_MEM          *pmem,
S                                       OS_MEM_DATA     *p_mem_data);
S#endif
S
N#endif
N
N/*
N*********************************************************************************************************
N*                                MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_MUTEX_EN > 0
X#if 0 > 0
S
S#if OS_MUTEX_ACCEPT_EN > 0
SBOOLEAN       OSMutexAccept           (OS_EVENT        *pevent,
S                                       INT8U           *perr);
S#endif
S
SOS_EVENT     *OSMutexCreate           (INT8U            prio,
S                                       INT8U           *perr);
S
S#if OS_MUTEX_DEL_EN > 0
SOS_EVENT     *OSMutexDel              (OS_EVENT        *pevent,
S                                       INT8U            opt,
S                                       INT8U           *perr);
S#endif
S
Svoid          OSMutexPend             (OS_EVENT        *pevent,
S                                       INT16U           timeout,
S                                       INT8U           *perr);
S
SINT8U         OSMutexPost             (OS_EVENT        *pevent);
S
S#if OS_MUTEX_QUERY_EN > 0
SINT8U         OSMutexQuery            (OS_EVENT        *pevent,
S                                       OS_MUTEX_DATA   *p_mutex_data);
S#endif
S
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                         MESSAGE QUEUE MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
X#if (0 > 0) && (4 > 0)
S
S#if OS_Q_ACCEPT_EN > 0
Svoid         *OSQAccept               (OS_EVENT        *pevent,
S                                       INT8U           *perr);
S#endif
S
SOS_EVENT     *OSQCreate               (void           **start,
S                                       INT16U           size);
S
S#if OS_Q_DEL_EN > 0
SOS_EVENT     *OSQDel                  (OS_EVENT        *pevent,
S                                       INT8U            opt,
S                                       INT8U           *perr);
S#endif
S
S#if OS_Q_FLUSH_EN > 0
SINT8U         OSQFlush                (OS_EVENT        *pevent);
S#endif
S
Svoid         *OSQPend                 (OS_EVENT        *pevent,
S                                       INT16U           timeout,
S                                       INT8U           *perr);
S
S#if OS_Q_PEND_ABORT_EN > 0
SINT8U         OSQPendAbort            (OS_EVENT        *pevent,
S                                       INT8U            opt,
S                                       INT8U           *perr);
S#endif
S
S#if OS_Q_POST_EN > 0
SINT8U         OSQPost                 (OS_EVENT        *pevent,
S                                       void            *pmsg);
S#endif
S
S#if OS_Q_POST_FRONT_EN > 0
SINT8U         OSQPostFront            (OS_EVENT        *pevent,
S                                       void            *pmsg);
S#endif
S
S#if OS_Q_POST_OPT_EN > 0
SINT8U         OSQPostOpt              (OS_EVENT        *pevent,
S                                       void            *pmsg,
S                                       INT8U            opt);
S#endif
S
S#if OS_Q_QUERY_EN > 0
SINT8U         OSQQuery                (OS_EVENT        *pevent,
S                                       OS_Q_DATA       *p_q_data);
S#endif
S
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          SEMAPHORE MANAGEMENT
N*********************************************************************************************************
N*/
N#if OS_SEM_EN > 0
X#if 1 > 0
N
N#if OS_SEM_ACCEPT_EN > 0
X#if 1 > 0
NINT16U        OSSemAccept             (OS_EVENT        *pevent);
N#endif
N
NOS_EVENT     *OSSemCreate             (INT16U           cnt);
N
N#if OS_SEM_DEL_EN > 0
X#if 1 > 0
NOS_EVENT     *OSSemDel                (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
Nvoid          OSSemPend               (OS_EVENT        *pevent,
N                                       INT16U           timeout,
N                                       INT8U           *perr);
N
N#if OS_SEM_PEND_ABORT_EN > 0
X#if 1 > 0
NINT8U         OSSemPendAbort          (OS_EVENT        *pevent,
N                                       INT8U            opt,
N                                       INT8U           *perr);
N#endif
N
NINT8U         OSSemPost               (OS_EVENT        *pevent);
N
N#if OS_SEM_QUERY_EN > 0
X#if 1 > 0
NINT8U         OSSemQuery              (OS_EVENT        *pevent,
N                                       OS_SEM_DATA     *p_sem_data);
N#endif
N
N#if OS_SEM_SET_EN > 0
X#if 1 > 0
Nvoid          OSSemSet                (OS_EVENT        *pevent,
N                                       INT16U           cnt,
N                                       INT8U           *perr);
N#endif
N
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            TASK MANAGEMENT
N*********************************************************************************************************
N*/
N#if OS_TASK_CHANGE_PRIO_EN > 0
X#if 1 > 0
NINT8U         OSTaskChangePrio        (INT8U            oldprio,
N                                       INT8U            newprio);
N#endif
N
N#if OS_TASK_CREATE_EN > 0
X#if 1 > 0
NINT8U         OSTaskCreate            (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT8U            prio);
N#endif
N
N#if OS_TASK_CREATE_EXT_EN > 0
X#if 1 > 0
NINT8U         OSTaskCreateExt         (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT8U            prio,
N                                       INT16U           id,
N                                       OS_STK          *pbos,
N                                       INT32U           stk_size,
N                                       void            *pext,
N                                       INT16U           opt);
N#endif
N
N#if OS_TASK_DEL_EN > 0
X#if 1 > 0
NINT8U         OSTaskDel               (INT8U            prio);
NINT8U         OSTaskDelReq            (INT8U            prio);
N#endif
N
N#if OS_TASK_NAME_SIZE > 1
X#if 16 > 1
NINT8U         OSTaskNameGet           (INT8U            prio,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N
Nvoid          OSTaskNameSet           (INT8U            prio,
N                                       INT8U           *pname,
N                                       INT8U           *perr);
N#endif
N
N#if OS_TASK_SUSPEND_EN > 0
X#if 1 > 0
NINT8U         OSTaskResume            (INT8U            prio);
NINT8U         OSTaskSuspend           (INT8U            prio);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
X#if (1 > 0) && (1 > 0)
NINT8U         OSTaskStkChk            (INT8U            prio,
N                                       OS_STK_DATA     *p_stk_data);
N#endif
N
N#if OS_TASK_QUERY_EN > 0
X#if 1 > 0
NINT8U         OSTaskQuery             (INT8U            prio,
N                                       OS_TCB          *p_task_data);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                            TIME MANAGEMENT
N*********************************************************************************************************
N*/
N
Nvoid          OSTimeDly               (INT16U           ticks);
N
N#if OS_TIME_DLY_HMSM_EN > 0
X#if 1 > 0
NINT8U         OSTimeDlyHMSM           (INT8U            hours,
N                                       INT8U            minutes,
N                                       INT8U            seconds,
N                                       INT16U           milli);
N#endif
N
N#if OS_TIME_DLY_RESUME_EN > 0
X#if 1 > 0
NINT8U         OSTimeDlyResume         (INT8U            prio);
N#endif
N
N#if OS_TIME_GET_SET_EN > 0
X#if 1 > 0
NINT32U        OSTimeGet               (void);
Nvoid          OSTimeSet               (INT32U           ticks);
N#endif
N
Nvoid          OSTimeTick              (void);
N
N/*
N*********************************************************************************************************
N*                                            TIMER MANAGEMENT
N*********************************************************************************************************
N*/
N
N#if OS_TMR_EN > 0
X#if 0 > 0
SOS_TMR      *OSTmrCreate              (INT32U           dly,
S                                       INT32U           period,
S                                       INT8U            opt,
S                                       OS_TMR_CALLBACK  callback,
S                                       void            *callback_arg,
S                                       INT8U           *pname,
S                                       INT8U           *perr);
S
SBOOLEAN      OSTmrDel                 (OS_TMR          *ptmr,
S                                       INT8U           *perr);
S
S#if OS_TMR_CFG_NAME_SIZE > 0
SINT8U        OSTmrNameGet             (OS_TMR          *ptmr,
S                                       INT8U           *pdest,
S                                       INT8U           *perr);
S#endif
SINT32U       OSTmrRemainGet           (OS_TMR          *ptmr,
S                                       INT8U           *perr);
S
SINT8U        OSTmrStateGet            (OS_TMR          *ptmr,
S                                       INT8U           *perr);
S
SBOOLEAN      OSTmrStart               (OS_TMR          *ptmr,
S                                       INT8U           *perr);
S
SBOOLEAN      OSTmrStop                (OS_TMR          *ptmr,
S                                       INT8U            opt,
S                                       void            *callback_arg,
S                                       INT8U           *perr);
S
SINT8U        OSTmrSignal              (void);
N#endif
N
N/*
N*********************************************************************************************************
N*                                             MISCELLANEOUS
N*********************************************************************************************************
N*/
N
Nvoid          OSInit                  (void);
N
Nvoid          OSIntEnter              (void);
Nvoid          OSIntExit               (void);
N
N#if OS_SCHED_LOCK_EN > 0
X#if 1 > 0
Nvoid          OSSchedLock             (void);
Nvoid          OSSchedUnlock           (void);
N#endif
N
Nvoid          OSStart                 (void);
N
Nvoid          OSStatInit              (void);
N
NINT16U        OSVersion               (void);
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                      INTERNAL FUNCTION PROTOTYPES
N*                            (Your application MUST NOT call these functions)
N*********************************************************************************************************
N*/
N
N#if OS_TASK_DEL_EN > 0
X#if 1 > 0
Nvoid          OS_Dummy                (void);
N#endif
N
N#if (OS_EVENT_EN)
X#if ((((0 > 0) && (4 > 0)) || (1 > 0) || (1 > 0) || (0 > 0)))
NINT8U         OS_EventTaskRdy         (OS_EVENT        *pevent,
N                                       void            *pmsg,
N                                       INT8U            msk,
N                                       INT8U            pend_stat);
N
Nvoid          OS_EventTaskWait        (OS_EVENT        *pevent);
N
Nvoid          OS_EventTaskRemove      (OS_TCB          *ptcb,
N                                       OS_EVENT        *pevent);
N
N#if (OS_EVENT_MULTI_EN > 0)
X#if (1 > 0)
Nvoid          OS_EventTaskWaitMulti   (OS_EVENT       **pevents_wait);
N
Nvoid          OS_EventTaskRemoveMulti (OS_TCB          *ptcb,
N                                       OS_EVENT       **pevents_multi);
N#endif
N
Nvoid          OS_EventWaitListInit    (OS_EVENT        *pevent);
N#endif
N
N#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
X#if (1 > 0) && (5 > 0)
Nvoid          OS_FlagInit             (void);
Nvoid          OS_FlagUnlink           (OS_FLAG_NODE    *pnode);
N#endif
N
Nvoid          OS_MemClr               (INT8U           *pdest,
N                                       INT16U           size);
N
Nvoid          OS_MemCopy              (INT8U           *pdest,
N                                       INT8U           *psrc,
N                                       INT16U           size);
N
N#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
X#if (0 > 0) && (5 > 0)
Svoid          OS_MemInit              (void);
N#endif
N
N#if OS_Q_EN > 0
X#if 0 > 0
Svoid          OS_QInit                (void);
N#endif
N
Nvoid          OS_Sched                (void);
N
N#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1)
X#if (16 > 1) || (16 > 1) || (16 > 1) || (16 > 1)
NINT8U         OS_StrCopy              (INT8U           *pdest,
N                                       INT8U           *psrc);
N
NINT8U         OS_StrLen               (INT8U           *psrc);
N#endif
N
Nvoid          OS_TaskIdle             (void            *p_arg);
N
N#if OS_TASK_STAT_EN > 0
X#if 1 > 0
Nvoid          OS_TaskStat             (void            *p_arg);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
X#if (1 > 0) && (1 > 0)
Nvoid          OS_TaskStkClr           (OS_STK          *pbos,
N                                       INT32U           size,
N                                       INT16U           opt);
N#endif
N
N#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
X#if (1 > 0) && (1 > 0)
Nvoid          OS_TaskStatStkChk       (void);
N#endif
N
NINT8U         OS_TCBInit              (INT8U            prio,
N                                       OS_STK          *ptos,
N                                       OS_STK          *pbos,
N                                       INT16U           id,
N                                       INT32U           stk_size,
N                                       void            *pext,
N                                       INT16U           opt);
N
N#if OS_TMR_EN > 0
X#if 0 > 0
Svoid          OSTmr_Init              (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                      (Target Specific Functions)
N*********************************************************************************************************
N*/
N
N#if OS_DEBUG_EN > 0
X#if 1 > 0
Nvoid          OSDebugInit             (void);
N#endif
N
Nvoid          OSInitHookBegin         (void);
Nvoid          OSInitHookEnd           (void);
N
Nvoid          OSTaskCreateHook        (OS_TCB          *ptcb);
Nvoid          OSTaskDelHook           (OS_TCB          *ptcb);
N
Nvoid          OSTaskIdleHook          (void);
N
Nvoid          OSTaskStatHook          (void);
NOS_STK       *OSTaskStkInit           (void           (*task)(void *p_arg),
N                                       void            *p_arg,
N                                       OS_STK          *ptos,
N                                       INT16U           opt);
N
N#if OS_TASK_SW_HOOK_EN > 0
X#if 1 > 0
Nvoid          OSTaskSwHook            (void);
N#endif
N
Nvoid          OSTCBInitHook           (OS_TCB          *ptcb);
N
N#if OS_TIME_TICK_HOOK_EN > 0
X#if 1 > 0
Nvoid          OSTimeTickHook          (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*                                   (Application Specific Functions)
N*********************************************************************************************************
N*/
N
N#if OS_APP_HOOKS_EN > 0
X#if 1 > 0
Nvoid          App_TaskCreateHook      (OS_TCB          *ptcb);
Nvoid          App_TaskDelHook         (OS_TCB          *ptcb);
Nvoid          App_TaskIdleHook        (void);
N
Nvoid          App_TaskStatHook        (void);
N
N#if OS_TASK_SW_HOOK_EN > 0
X#if 1 > 0
Nvoid          App_TaskSwHook          (void);
N#endif
N
Nvoid          App_TCBInitHook         (OS_TCB          *ptcb);
N
N#if OS_TIME_TICK_HOOK_EN > 0
X#if 1 > 0
Nvoid          App_TimeTickHook        (void);
N#endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                          FUNCTION PROTOTYPES
N*
N* IMPORTANT: These prototypes MUST be placed in OS_CPU.H
N*********************************************************************************************************
N*/
N
N#if 0
Svoid          OSStartHighRdy          (void);
Svoid          OSIntCtxSw              (void);
Svoid          OSCtxSw                 (void);
N#endif
N
N/*$PAGE*/
N/*
N*********************************************************************************************************
N*                                   LOOK FOR MISSING #define CONSTANTS
N*
N* This section is used to generate ERROR messages at compile time if certain #define constants are
N* MISSING in OS_CFG.H.  This allows you to quickly determine the source of the error.
N*
N* You SHOULD NOT change this section UNLESS you would like to add more comments as to the source of the
N* compile time error.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                            EVENT FLAGS
N*********************************************************************************************************
N*/
N
N#ifndef OS_FLAG_EN
S#error  "OS_CFG.H, Missing OS_FLAG_EN: Enable (1) or Disable (0) code generation for Event Flags"
N#else
N    #ifndef OS_MAX_FLAGS
S    #error  "OS_CFG.H, Missing OS_MAX_FLAGS: Max. number of Event Flag Groups in your application"
N    #else
N        #if     OS_MAX_FLAGS > 65500u
X        #if     5 > 65500u
S        #error  "OS_CFG.H, OS_MAX_FLAGS must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_FLAGS_NBITS
S    #error  "OS_CFG.H, Missing OS_FLAGS_NBITS: Determine #bits used for event flags, MUST be either 8, 16 or 32"
N    #endif
N
N    #ifndef OS_FLAG_WAIT_CLR_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_WAIT_CLR_EN: Include code for Wait on Clear EVENT FLAGS"
N    #endif
N
N    #ifndef OS_FLAG_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_ACCEPT_EN: Include code for OSFlagAccept()"
N    #endif
N
N    #ifndef OS_FLAG_DEL_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_DEL_EN: Include code for OSFlagDel()"
N    #endif
N
N    #ifndef OS_FLAG_NAME_SIZE
S    #error  "OS_CFG.H, Missing OS_FLAG_NAME_SIZE: Determines the size of flag group names"
N    #endif
N
N    #ifndef OS_FLAG_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_FLAG_QUERY_EN: Include code for OSFlagQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           MESSAGE MAILBOXES
N*********************************************************************************************************
N*/
N
N#ifndef OS_MBOX_EN
S#error  "OS_CFG.H, Missing OS_MBOX_EN: Enable (1) or Disable (0) code generation for MAILBOXES"
N#else
N    #ifndef OS_MBOX_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_ACCEPT_EN: Include code for OSMboxAccept()"
N    #endif
N
N    #ifndef OS_MBOX_DEL_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_DEL_EN: Include code for OSMboxDel()"
N    #endif
N
N    #ifndef OS_MBOX_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_PEND_ABORT_EN: Include code for OSMboxPendAbort()"
N    #endif
N
N    #ifndef OS_MBOX_POST_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_POST_EN: Include code for OSMboxPost()"
N    #endif
N
N    #ifndef OS_MBOX_POST_OPT_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_POST_OPT_EN: Include code for OSMboxPostOpt()"
N    #endif
N
N    #ifndef OS_MBOX_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MBOX_QUERY_EN: Include code for OSMboxQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                           MEMORY MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_MEM_EN
S#error  "OS_CFG.H, Missing OS_MEM_EN: Enable (1) or Disable (0) code generation for MEMORY MANAGER"
N#else
N    #ifndef OS_MAX_MEM_PART
S    #error  "OS_CFG.H, Missing OS_MAX_MEM_PART: Max. number of memory partitions"
N    #else
N        #if     OS_MAX_MEM_PART > 65500u
X        #if     5 > 65500u
S        #error  "OS_CFG.H, OS_MAX_MEM_PART must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_MEM_NAME_SIZE
S    #error  "OS_CFG.H, Missing OS_MEM_NAME_SIZE: Determines the size of memory partition names"
N    #endif
N
N    #ifndef OS_MEM_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MEM_QUERY_EN: Include code for OSMemQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                       MUTUAL EXCLUSION SEMAPHORES
N*********************************************************************************************************
N*/
N
N#ifndef OS_MUTEX_EN
S#error  "OS_CFG.H, Missing OS_MUTEX_EN: Enable (1) or Disable (0) code generation for MUTEX"
N#else
N    #ifndef OS_MUTEX_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_ACCEPT_EN: Include code for OSMutexAccept()"
N    #endif
N
N    #ifndef OS_MUTEX_DEL_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_DEL_EN: Include code for OSMutexDel()"
N    #endif
N
N    #ifndef OS_MUTEX_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_MUTEX_QUERY_EN: Include code for OSMutexQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                              MESSAGE QUEUES
N*********************************************************************************************************
N*/
N
N#ifndef OS_Q_EN
S#error  "OS_CFG.H, Missing OS_Q_EN: Enable (1) or Disable (0) code generation for QUEUES"
N#else
N    #ifndef OS_MAX_QS
S    #error  "OS_CFG.H, Missing OS_MAX_QS: Max. number of queue control blocks"
N    #else
N        #if     OS_MAX_QS > 65500u
X        #if     4 > 65500u
S        #error  "OS_CFG.H, OS_MAX_QS must be <= 65500"
N        #endif
N    #endif
N
N    #ifndef OS_Q_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_Q_ACCEPT_EN: Include code for OSQAccept()"
N    #endif
N
N    #ifndef OS_Q_DEL_EN
S    #error  "OS_CFG.H, Missing OS_Q_DEL_EN: Include code for OSQDel()"
N    #endif
N
N    #ifndef OS_Q_FLUSH_EN
S    #error  "OS_CFG.H, Missing OS_Q_FLUSH_EN: Include code for OSQFlush()"
N    #endif
N
N    #ifndef OS_Q_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_Q_PEND_ABORT_EN: Include code for OSQPendAbort()"
N    #endif
N
N    #ifndef OS_Q_POST_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_EN: Include code for OSQPost()"
N    #endif
N
N    #ifndef OS_Q_POST_FRONT_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_FRONT_EN: Include code for OSQPostFront()"
N    #endif
N
N    #ifndef OS_Q_POST_OPT_EN
S    #error  "OS_CFG.H, Missing OS_Q_POST_OPT_EN: Include code for OSQPostOpt()"
N    #endif
N
N    #ifndef OS_Q_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_Q_QUERY_EN: Include code for OSQQuery()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                              SEMAPHORES
N*********************************************************************************************************
N*/
N
N#ifndef OS_SEM_EN
S#error  "OS_CFG.H, Missing OS_SEM_EN: Enable (1) or Disable (0) code generation for SEMAPHORES"
N#else
N    #ifndef OS_SEM_ACCEPT_EN
S    #error  "OS_CFG.H, Missing OS_SEM_ACCEPT_EN: Include code for OSSemAccept()"
N    #endif
N
N    #ifndef OS_SEM_DEL_EN
S    #error  "OS_CFG.H, Missing OS_SEM_DEL_EN: Include code for OSSemDel()"
N    #endif
N
N    #ifndef OS_SEM_PEND_ABORT_EN
S    #error  "OS_CFG.H, Missing OS_SEM_PEND_ABORT_EN: Include code for OSSemPendAbort()"
N    #endif
N
N    #ifndef OS_SEM_QUERY_EN
S    #error  "OS_CFG.H, Missing OS_SEM_QUERY_EN: Include code for OSSemQuery()"
N    #endif
N
N    #ifndef OS_SEM_SET_EN
S    #error  "OS_CFG.H, Missing OS_SEM_SET_EN: Include code for OSSemSet()"
N    #endif
N#endif
N
N/*
N*********************************************************************************************************
N*                                             TASK MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_MAX_TASKS
S#error  "OS_CFG.H, Missing OS_MAX_TASKS: Max. number of tasks in your application"
N#else
N    #if     OS_MAX_TASKS < 2
X    #if     20 < 2
S    #error  "OS_CFG.H,         OS_MAX_TASKS must be >= 2"
N    #endif
N
N    #if     OS_MAX_TASKS >  ((OS_LOWEST_PRIO - OS_N_SYS_TASKS) + 1)
X    #if     20 >  ((31 - 2u) + 1)
S    #error  "OS_CFG.H,         OS_MAX_TASKS must be <= OS_LOWEST_PRIO - OS_N_SYS_TASKS + 1"
N    #endif
N
N#endif
N
N#if     OS_LOWEST_PRIO >  254
X#if     31 >  254
S#error  "OS_CFG.H,         OS_LOWEST_PRIO must be <= 254 in V2.8x and higher"
N#endif
N
N#ifndef OS_TASK_IDLE_STK_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_IDLE_STK_SIZE: Idle task stack size"
N#endif
N
N#ifndef OS_TASK_STAT_EN
S#error  "OS_CFG.H, Missing OS_TASK_STAT_EN: Enable (1) or Disable(0) the statistics task"
N#endif
N
N#ifndef OS_TASK_STAT_STK_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_STAT_STK_SIZE: Statistics task stack size"
N#endif
N
N#ifndef OS_TASK_STAT_STK_CHK_EN
S#error  "OS_CFG.H, Missing OS_TASK_STAT_STK_CHK_EN: Check task stacks from statistics task"
N#endif
N
N#ifndef OS_TASK_CHANGE_PRIO_EN
S#error  "OS_CFG.H, Missing OS_TASK_CHANGE_PRIO_EN: Include code for OSTaskChangePrio()"
N#endif
N
N#ifndef OS_TASK_CREATE_EN
S#error  "OS_CFG.H, Missing OS_TASK_CREATE_EN: Include code for OSTaskCreate()"
N#endif
N
N#ifndef OS_TASK_CREATE_EXT_EN
S#error  "OS_CFG.H, Missing OS_TASK_CREATE_EXT_EN: Include code for OSTaskCreateExt()"
N#endif
N
N#ifndef OS_TASK_DEL_EN
S#error  "OS_CFG.H, Missing OS_TASK_DEL_EN: Include code for OSTaskDel()"
N#endif
N
N#ifndef OS_TASK_NAME_SIZE
S#error  "OS_CFG.H, Missing OS_TASK_NAME_SIZE: Determine the size of task names"
N#endif
N
N#ifndef OS_TASK_SUSPEND_EN
S#error  "OS_CFG.H, Missing OS_TASK_SUSPEND_EN: Include code for OSTaskSuspend() and OSTaskResume()"
N#endif
N
N#ifndef OS_TASK_QUERY_EN
S#error  "OS_CFG.H, Missing OS_TASK_QUERY_EN: Include code for OSTaskQuery()"
N#endif
N
N/*
N*********************************************************************************************************
N*                                             TIME MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_TICKS_PER_SEC
S#error  "OS_CFG.H, Missing OS_TICKS_PER_SEC: Sets the number of ticks in one second"
N#endif
N
N#ifndef OS_TIME_DLY_HMSM_EN
S#error  "OS_CFG.H, Missing OS_TIME_DLY_HMSM_EN: Include code for OSTimeDlyHMSM()"
N#endif
N
N#ifndef OS_TIME_DLY_RESUME_EN
S#error  "OS_CFG.H, Missing OS_TIME_DLY_RESUME_EN: Include code for OSTimeDlyResume()"
N#endif
N
N#ifndef OS_TIME_GET_SET_EN
S#error  "OS_CFG.H, Missing OS_TIME_GET_SET_EN: Include code for OSTimeGet() and OSTimeSet()"
N#endif
N
N/*
N*********************************************************************************************************
N*                                             TIMER MANAGEMENT
N*********************************************************************************************************
N*/
N
N#ifndef OS_TMR_EN
S#error  "OS_CFG.H, Missing OS_TMR_EN: When (1) enables code generation for Timer Management"
S#elif   OS_TMR_EN > 0
X#elif   0 > 0
S    #if     OS_SEM_EN == 0
S    #error  "OS_CFG.H, Semaphore management is required (set OS_SEM_EN to 1) when enabling Timer Management."
S    #error  "          Timer management require TWO semaphores."
S    #endif
S
S    #ifndef OS_TMR_CFG_MAX
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_MAX: Determines the total number of timers in an application (2 .. 65500)"
S    #else
S        #if OS_TMR_CFG_MAX < 2
S        #error  "OS_CFG.H, OS_TMR_CFG_MAX should be between 2 and 65500"
S        #endif
S
S        #if OS_TMR_CFG_MAX > 65500
S        #error  "OS_CFG.H, OS_TMR_CFG_MAX should be between 2 and 65500"
S        #endif
S    #endif
S
S    #ifndef OS_TMR_CFG_WHEEL_SIZE
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_WHEEL_SIZE: Sets the size of the timer wheel (1 .. 1023)"
S    #else
S        #if OS_TMR_CFG_WHEEL_SIZE < 2
S        #error  "OS_CFG.H, OS_TMR_CFG_WHEEL_SIZE should be between 2 and 1024"
S        #endif
S
S        #if OS_TMR_CFG_WHEEL_SIZE > 1024
S        #error  "OS_CFG.H, OS_TMR_CFG_WHEEL_SIZE should be between 2 and 1024"
S        #endif
S    #endif
S
S    #ifndef OS_TMR_CFG_NAME_SIZE
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_NAME_SIZE: Determines the number of characters used for Timer names"
S    #endif
S
S    #ifndef OS_TMR_CFG_TICKS_PER_SEC
S    #error  "OS_CFG.H, Missing OS_TMR_CFG_TICKS_PER_SEC: Determines the rate at which tiem timer management task will run (Hz)"
S    #endif
S
S    #ifndef OS_TASK_TMR_STK_SIZE
S    #error  "OS_CFG.H, Missing OS_TASK_TMR_STK_SIZE: Determines the size of the Timer Task's stack"
S    #endif
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                            MISCELLANEOUS
N*********************************************************************************************************
N*/
N
N#ifndef OS_ARG_CHK_EN
S#error  "OS_CFG.H, Missing OS_ARG_CHK_EN: Enable (1) or Disable (0) argument checking"
N#endif
N
N
N#ifndef OS_CPU_HOOKS_EN
S#error  "OS_CFG.H, Missing OS_CPU_HOOKS_EN: uC/OS-II hooks are found in the processor port files when 1"
N#endif
N
N
N#ifndef OS_APP_HOOKS_EN
S#error  "OS_CFG.H, Missing OS_APP_HOOKS_EN: Application-defined hooks are called from the uC/OS-II hooks"
N#endif
N
N
N#ifndef OS_DEBUG_EN
S#error  "OS_CFG.H, Missing OS_DEBUG_EN: Allows you to include variables for debugging or not"
N#endif
N
N
N#ifndef OS_LOWEST_PRIO
S#error  "OS_CFG.H, Missing OS_LOWEST_PRIO: Defines the lowest priority that can be assigned"
N#endif
N
N
N#ifndef OS_MAX_EVENTS
S#error  "OS_CFG.H, Missing OS_MAX_EVENTS: Max. number of event control blocks in your application"
N#else
N    #if     OS_MAX_EVENTS > 65500u
X    #if     10 > 65500u
S    #error  "OS_CFG.H, OS_MAX_EVENTS must be <= 65500"
N    #endif
N#endif
N
N
N#ifndef OS_SCHED_LOCK_EN
S#error  "OS_CFG.H, Missing OS_SCHED_LOCK_EN: Include code for OSSchedLock() and OSSchedUnlock()"
N#endif
N
N
N#ifndef OS_EVENT_MULTI_EN
S#error  "OS_CFG.H, Missing OS_EVENT_MULTI_EN: Include code for OSEventPendMulti()"
N#endif
N
N
N#ifndef OS_TASK_PROFILE_EN
S#error  "OS_CFG.H, Missing OS_TASK_PROFILE_EN: Include data structure for run-time task profiling"
N#endif
N
N
N#ifndef OS_TASK_SW_HOOK_EN
S#error  "OS_CFG.H, Missing OS_TASK_SW_HOOK_EN: Allows you to include the code for OSTaskSwHook() or not"
N#endif
N
N
N#ifndef OS_TICK_STEP_EN
S#error  "OS_CFG.H, Missing OS_TICK_STEP_EN: Allows to 'step' one tick at a time with uC/OS-View"
N#endif
N
N
N#ifndef OS_TIME_TICK_HOOK_EN
S#error  "OS_CFG.H, Missing OS_TIME_TICK_HOOK_EN: Allows you to include the code for OSTimeTickHook() or not"
N#endif
N
N/*
N*********************************************************************************************************
N*                                         SAFETY CRITICAL USE
N*********************************************************************************************************
N*/
N
N#ifdef SAFETY_CRITICAL_RELEASE
S
S#if    OS_ARG_CHK_EN < 1
S#error "OS_CFG.H, OS_ARG_CHK_EN must be enabled for safety-critical release code"
S#endif
S
S#if    OS_APP_HOOKS_EN > 0
S#error "OS_CFG.H, OS_APP_HOOKS_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_DEBUG_EN > 0
S#error "OS_CFG.H, OS_DEBUG_EN must be disabled for safety-critical release code"
S#endif
S
S#ifdef CANTATA
S#error "OS_CFG.H, CANTATA must be disabled for safety-critical release code"
S#endif
S
S#ifdef OS_SCHED_LOCK_EN
S#error "OS_CFG.H, OS_SCHED_LOCK_EN must be disabled for safety-critical release code"
S#endif
S
S#ifdef VSC_VALIDATION_MODE
S#error "OS_CFG.H, VSC_VALIDATION_MODE must be disabled for safety-critical release code"
S#endif
S
S#if    OS_TASK_STAT_EN > 0
S#error "OS_CFG.H, OS_TASK_STAT_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_TICK_STEP_EN > 0
S#error "OS_CFG.H, OS_TICK_STEP_EN must be disabled for safety-critical release code"
S#endif
S
S#if    OS_FLAG_EN > 0
S    #if    OS_FLAG_DEL_EN > 0
S    #error "OS_CFG.H, OS_FLAG_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_MBOX_EN > 0
S    #if    OS_MBOX_DEL_EN > 0
S    #error "OS_CFG.H, OS_MBOX_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_MUTEX_EN > 0
S    #if    OS_MUTEX_DEL_EN > 0
S    #error "OS_CFG.H, OS_MUTEX_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_Q_EN > 0
S    #if    OS_Q_DEL_EN > 0
S    #error "OS_CFG.H, OS_Q_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_SEM_EN > 0
S    #if    OS_SEM_DEL_EN > 0
S    #error "OS_CFG.H, OS_SEM_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_TASK_EN > 0
S    #if    OS_TASK_DEL_EN > 0
S    #error "OS_CFG.H, OS_TASK_DEL_EN must be disabled for safety-critical release code"
S    #endif
S#endif
S
S#if    OS_CRITICAL_METHOD != 3
S#error "OS_CPU.H, OS_CRITICAL_METHOD must be type 3 for safety-critical release code"
S#endif
S
N#endif  /* ------------------------ SAFETY_CRITICAL_RELEASE ------------------------ */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 72 "..\BSP\bsp.h" 2
N
N#if (APP_OS_PROBE_EN == DEF_ENABLED)
X#if (1 == 1)
N#include    <os_probe.h>
L 1 "..\..\..\..\..\uC-Probe\Target\Plugins\uCOS-II\os_probe.h" 1
N/*
N*********************************************************************************************************
N*                                        uC/Probe uC/OS-II Plug-in
N*
N*                          (c) Copyright 2003-2006; Micrium, Inc.; Weston, FL
N*
N*               All rights reserved.  Protected by international copyright laws.
N*               Knowledge of the source code may NOT be used to develop a similar product.
N*               Please help us continue to provide the Embedded community with the finest
N*               software available.  Your honesty is greatly appreciated.
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*
N*                                                uC/Probe
N*
N*                                          Plug-in for uC/OS-II
N*
N* Filename      : os_probe.h
N* Version       : V2.00
N* Programmer(s) : BAN
N*********************************************************************************************************
N*/
N
N/*
N*********************************************************************************************************
N*                                                 MODULE
N*
N* Note(s) : (1) This header file is protected from multiple pre-processor inclusion through use of the
N*               PROBE_OS present pre-processor macro definition.
N*********************************************************************************************************
N*/
N
N#ifndef  PROBE_OS_PRESENT                                       /* See Note #1.                                         */
N#define  PROBE_OS_PRESENT
N
N
N/*
N*********************************************************************************************************
N*                                     PROBE OS MODULE VERSION NUMBER
N*
N* Note(s) : (1) (a) The Probe OS module software version is denoted as follows :
N*
N*                       Vx.yy
N*
N*                           where
N*                                  V     denotes 'Version' label
N*                                  x     denotes major software version revision number
N*                                  yy    denotes minor software version revision number
N*
N*               (b) The Probe OS module software version label #define is formatted as follows :
N*
N*                       ver = x.yy * 100
N*
N*                           where
N*                                  ver   denotes software version number scaled as
N*                                        an integer value
N*                                  x.yy  denotes software version number
N*********************************************************************************************************
N*/
N
N#define  PROBE_OS_VERSION          200u                         /* See Note #1.                                         */
N
N
N/*
N*********************************************************************************************************
N*                                                 EXTERNS
N*********************************************************************************************************
N*/
N
N#ifdef   OS_PROBE_MODULE
S#define  OS_PROBE_EXT
N#else
N#define  OS_PROBE_EXT  extern
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                              INCLUDE FILES
N*********************************************************************************************************
N*/
N
N#include  <app_cfg.h>
N#include  <ucos_ii.h>
N
N
N/*
N*********************************************************************************************************
N*                                                 DEFINES
N*
N* Note(s)     : (1) If OS_PROBE_USE_FP is defined as 0 in user header file, then the task CPU usages
N*                   and task stack usages stored in OSProbe_TaskCPUUsage[] and OSProbe_TaskStkUsage[]
N*                   will be 16-bit integers. This option removes the usage of floating-point types
N*                   in this code, thereby eliminating the need for a floating-point library.  If
N*                   OS_PROBE_USE_FP is not defined in user header file, the value defaults to 1.
N*********************************************************************************************************
N*/
N
N#ifndef  OS_PROBE_USE_FP
S#define  OS_PROBE_USE_FP             1
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                          GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
NOS_PROBE_EXT            void    (*OSProbe_CallbackFnct)(void);
Xextern            void    (*OSProbe_CallbackFnct)(void);
NOS_PROBE_EXT            INT16U    OSProbe_Delay;
Xextern            INT16U    OSProbe_Delay;
N
N#if (OS_PROBE_TASK   > 0)
X#if (1   > 0)
N#if (OS_PROBE_USE_FP > 0)
X#if (1 > 0)
NOS_PROBE_EXT  volatile  FP32      OSProbe_TaskCPUUsage[OS_MAX_TASKS];
Xextern  volatile  FP32      OSProbe_TaskCPUUsage[20];
NOS_PROBE_EXT  volatile  FP32      OSProbe_TaskStkUsage[OS_MAX_TASKS];
Xextern  volatile  FP32      OSProbe_TaskStkUsage[20];
N#else
SOS_PROBE_EXT  volatile  INT16U    OSProbe_TaskCPUUsage[OS_MAX_TASKS];
SOS_PROBE_EXT  volatile  INT16U    OSProbe_TaskStkUsage[OS_MAX_TASKS];
N#endif
N#endif
N
N#if (OS_PROBE_HOOKS_EN > 0)
X#if (1 > 0)
NOS_PROBE_EXT            INT32U    OSProbe_CyclesCtr;
Xextern            INT32U    OSProbe_CyclesCtr;
N#if (OS_PROBE_TMR_32_BITS > 0)
X#if (0 > 0)
SOS_PROBE_EXT            INT32U    OSProbe_TmrCntsPrev;
N#else
NOS_PROBE_EXT            INT16U    OSProbe_TmrCntsPrev;
Xextern            INT16U    OSProbe_TmrCntsPrev;
N#endif
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                                 MACRO'S
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                           FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid    OSProbe_Init          (void);                               /* Initialize uC/Probe uC/OS-II Plug-In.                */
N
N#if (OS_PROBE_TASK > 0)
X#if (1 > 0)
Nvoid    OSProbe_SetCallback   (void   (*call_back)(void));
Nvoid    OSProbe_SetDelay      (INT16U   delay);
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                           FUNCTION PROTOTYPES
N*                                HOOKS CALLED FROM USER'S APPLICATION CODE
N*********************************************************************************************************
N*/
N
N#if (OS_PROBE_HOOKS_EN > 0)
X#if (1 > 0)
Nvoid    OSProbe_TaskSwHook    (void);                               /* MUST be called by App_TaskSwHook().                  */
Nvoid    OSProbe_TaskCreateHook(OS_TCB  *ptcb);                      /* MUST be called by App_TaskCreateHook().              */
Nvoid    OSProbe_TickHook      (void);                               /* MUST be called by App_TimeTickHook().                */
N
NINT32U  OSProbe_TimeGetCycles (void);
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                           FUNCTION PROTOTYPES
N*                                             DEFINED IN bsp.c
N*********************************************************************************************************
N*/
N
N#if (OS_PROBE_HOOKS_EN > 0)
X#if (1 > 0)
Nvoid    OSProbe_TmrInit       (void);
NINT32U  OSProbe_TmrRd         (void);
N#endif
N
N
N/*
N*********************************************************************************************************
N*                                          CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N#if       (OS_TASK_PROFILE_EN == 0)
X#if       (1 == 0)
S  #error  "OS_TASK_PROFILE_EN       illegally #define'd in 'os_cfg.h'                       "
S  #error  "                [MUST be  1   Variables included in OS_TCB for profiling]        "
N#endif
N
N
N
N#ifndef    OS_PROBE_TASK
S  #error  "OS_PROBE_TASK                  not #define'd in 'app_cfg.h'                      "
S  #error  "                [MUST be  0  Task created to calculate CPU usage for each task]  "
S  #error  "                [     ||  1  No task created                                  ]  "
S
S#elif    ((OS_PROBE_TASK != 0 ) && \
S          (OS_PROBE_TASK != 1))
X#elif    ((1 != 0 ) &&           (1 != 1))
S  #error  "OS_PROBE_TASK            illegally #define'd in 'app_cfg.h'                      "
S  #error  "                [MUST be  0  Task created to calculate CPU usage for each task]  "
S  #error  "                [     ||  1  No task created                                  ]  "
S
N#elif     (OS_PROBE_TASK == 1)
X#elif     (1 == 1)
N
N#ifndef    OS_PROBE_TASK_PRIO
S  #error  "OS_PROBE_TASK_PRIO             not #define'd in 'app_cfg.h'                      "
S  #error  "                [This will be the priority for the uC/OS-II Plug-in Task]        "
N#endif
N
N#ifndef    OS_PROBE_TASK_STK_SIZE
S  #error  "OS_PROBE_TASK_STK_SIZE         not #define'd in 'app_cfg.h'                      "
S  #error  "                [This will be the stack size for the uC/OS-II Plug-in Task]      "
N#endif
N
N#endif
N
N
N
N#ifndef    OS_PROBE_HOOKS_EN
S  #error  "OS_PROBE_HOOKS_EN              not #define'd in 'app_cfg.h'                      "
S  #error  "                [MUST be  0  uC/OS-II Plug-in hooks code     included]           "
S  #error  "                [     ||  1  uC/OS-II Plug-in hooks code NOT included]           "
S
S#elif    ((OS_PROBE_HOOKS_EN != 0 ) && \
S          (OS_PROBE_HOOKS_EN != 1))
X#elif    ((1 != 0 ) &&           (1 != 1))
S  #error  "OS_PROBE_HOOKS_EN        illegally #define'd in 'app_cfg.h'                      "
S  #error  "                [MUST be  0  uC/OS-II Plug-in hooks code     included]           "
S  #error  "                [     ||  1  uC/OS-II Plug-in hooks code NOT included]           "
S
N#elif     (OS_PROBE_HOOKS_EN == 1)
X#elif     (1 == 1)
N
N#ifndef    OS_PROBE_TMR_32_BITS
S  #error  "OS_PROBE_TMR_32_BITS           not #define'd in 'app_cfg.h'                      "
S  #error  "                [MUST be  1   Timer is 32-bit timer]                             "
S  #error  "                [     ||  0   Timer is 16-bit timer]                             "
S
S#elif    ((OS_PROBE_TMR_32_BITS != 0 ) && \
S          (OS_PROBE_TMR_32_BITS != 1))
X#elif    ((0 != 0 ) &&           (0 != 1))
S  #error  "OS_PROBE_TMR_32_BITS     illegally #define'd in 'app_cfg.h'"
S  #error  "                [MUST be  1   Timer is 32-bit timer]                             "
S  #error  "                [     ||  0   Timer is 16-bit timer]                             "
N#endif
N
N#endif
N
N
N
N
N/*
N*********************************************************************************************************
N*                                              MODULE END
N*
N* Note(s) : See 'MODULE  Note #1'.
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of PROBE_OS module include (see Note #1).        */
L 75 "..\BSP\bsp.h" 2
N#endif
N
N/*
N*********************************************************************************************************
N*                                                 DEFINES
N*********************************************************************************************************
N*/
N
N#define  BSP_JOYSTICK_NONE                       DEF_BIT_NONE
N#define  BSP_JOYSTICK_UP                         DEF_BIT_00
N#define  BSP_JOYSTICK_DOWN                       DEF_BIT_01
N#define  BSP_JOYSTICK_LEFT                       DEF_BIT_02
N#define  BSP_JOYSTICK_RIGHT                      DEF_BIT_03
N#define  BSP_JOYSTICK_CENTER                     DEF_BIT_04
N
N#define  BSP_PB_ID_KEY                                     1
N#define  BSP_PB_ID_WAKEUP                                  2
N#define  BSP_PB_ID_TAMPER                                  3
N
N/*
N*********************************************************************************************************
N*                                               INT DEFINES
N*********************************************************************************************************
N*/
N
N#define  BSP_INT_ID_WWDG                                   0    /* Window WatchDog Interrupt                            */
N#define  BSP_INT_ID_PVD                                    1    /* PVD through EXTI Line detection Interrupt            */
N#define  BSP_INT_ID_TAMPER                                 2    /* Tamper Interrupt                                     */
N#define  BSP_INT_ID_RTC                                    3    /* RTC global Interrupt                                 */
N#define  BSP_INT_ID_FLASH                                  4    /* FLASH global Interrupt                               */
N#define  BSP_INT_ID_RCC                                    5    /* RCC global Interrupt                                 */
N#define  BSP_INT_ID_EXTI0                                  6    /* EXTI Line0 Interrupt                                 */
N#define  BSP_INT_ID_EXTI1                                  7    /* EXTI Line1 Interrupt                                 */
N#define  BSP_INT_ID_EXTI2                                  8    /* EXTI Line2 Interrupt                                 */
N#define  BSP_INT_ID_EXTI3                                  9    /* EXTI Line3 Interrupt                                 */
N#define  BSP_INT_ID_EXTI4                                 10    /* EXTI Line4 Interrupt                                 */
N#define  BSP_INT_ID_DMA1_CH1                              11    /* DMA1 Channel 1 global Interrupt                      */
N#define  BSP_INT_ID_DMA1_CH2                              12    /* DMA1 Channel 2 global Interrupt                      */
N#define  BSP_INT_ID_DMA1_CH3                              13    /* DMA1 Channel 3 global Interrupt                      */
N#define  BSP_INT_ID_DMA1_CH4                              14    /* DMA1 Channel 4 global Interrupt                      */
N#define  BSP_INT_ID_DMA1_CH5                              15    /* DMA1 Channel 5 global Interrupt                      */
N#define  BSP_INT_ID_DMA1_CH6                              16    /* DMA1 Channel 6 global Interrupt                      */
N#define  BSP_INT_ID_DMA1_CH7                              17    /* DMA1 Channel 7 global Interrupt                      */
N#define  BSP_INT_ID_ADC1_2                                18    /* ADC1 et ADC2 global Interrupt                        */
N#define  BSP_INT_ID_USB_HP_CAN_TX                         19    /* USB High Priority or CAN TX Interrupts               */
N#define  BSP_INT_ID_USB_LP_CAN_RX0                        20    /* USB Low Priority or CAN RX0 Interrupts               */
N#define  BSP_INT_ID_CAN_RX1                               21    /* CAN RX1 Interrupt                                    */
N#define  BSP_INT_ID_CAN_SCE                               22    /* CAN SCE Interrupt                                    */
N#define  BSP_INT_ID_EXTI9_5                               23    /* External Line[9:5] Interrupts                        */
N#define  BSP_INT_ID_TIM1_BRK                              24    /* TIM1 Break Interrupt                                 */
N#define  BSP_INT_ID_TIM1_UP                               25    /* TIM1 Update Interrupt                                */
N#define  BSP_INT_ID_TIM1_TRG_COM                          26    /* TIM1 Trigger and Commutation Interrupt               */
N#define  BSP_INT_ID_TIM1_CC                               27    /* TIM1 Capture Compare Interrupt                       */
N#define  BSP_INT_ID_TIM2                                  28    /* TIM2 global Interrupt                                */
N#define  BSP_INT_ID_TIM3                                  29    /* TIM3 global Interrupt                                */
N#define  BSP_INT_ID_TIM4                                  30    /* TIM4 global Interrupt                                */
N#define  BSP_INT_ID_I2C1_EV                               31    /* I2C1 Event Interrupt                                 */
N#define  BSP_INT_ID_I2C1_ER                               32    /* I2C1 Error Interrupt                                 */
N#define  BSP_INT_ID_I2C2_EV                               33    /* I2C2 Event Interrupt                                 */
N#define  BSP_INT_ID_I2C2_ER                               34    /* I2C2 Error Interrupt                                 */
N#define  BSP_INT_ID_SPI1                                  35    /* SPI1 global Interrupt                                */
N#define  BSP_INT_ID_SPI2                                  36    /* SPI2 global Interrupt                                */
N#define  BSP_INT_ID_USART1                                37    /* USART1 global Interrupt                              */
N#define  BSP_INT_ID_USART2                                38    /* USART2 global Interrupt                              */
N#define  BSP_INT_ID_USART3                                39    /* USART3 global Interrupt                              */
N#define  BSP_INT_ID_EXTI15_10                             40    /* External Line[15:10] Interrupts                      */
N#define  BSP_INT_ID_RTCAlarm                              41    /* RTC Alarm through EXTI Line Interrupt                */
N#define  BSP_INT_ID_USBWakeUp                             42    /* USB WakeUp from suspend through EXTI Line Interrupt  */
N#define  BSP_INT_ID_TIM8_BRK                              43    /* TIM8 Break Interrupt                                 */
N#define  BSP_INT_ID_TIM8_UP                               44    /* TIM8 Update Interrupt                                */
N#define  BSP_INT_ID_TIM8_TRG_COM                          45    /* TIM8 Trigger and Commutation Interrupt               */
N#define  BSP_INT_ID_TIM8_CC                               46    /* TIM8 Capture Compare Interrupt                       */
N#define  BSP_INT_ID_ADC3                                  47    /* ADC3 global Interrupt                                */
N#define  BSP_INT_ID_FSMC                                  48    /* FSMC global Interrupt                                */
N#define  BSP_INT_ID_SDIO                                  49    /* SDIO global Interrupt                                */
N#define  BSP_INT_ID_TIM5                                  50    /* TIM5 global Interrupt                                */
N#define  BSP_INT_ID_SPI3                                  51    /* SPI3 global Interrupt                                */
N#define  BSP_INT_ID_UART4                                 52    /* UART4 global Interrupt                               */
N#define  BSP_INT_ID_UART5                                 53    /* UART5 global Interrupt                               */
N#define  BSP_INT_ID_TIM6                                  54    /* TIM6 global Interrupt                                */
N#define  BSP_INT_ID_TIM7                                  55    /* TIM7 global Interrupt                                */
N#define  BSP_INT_ID_DMA2_CH1                              56    /* DMA2 Channel 1 global Interrupt                      */
N#define  BSP_INT_ID_DMA2_CH2                              57    /* DMA2 Channel 2 global Interrupt                      */
N#define  BSP_INT_ID_DMA2_CH3                              58    /* DMA2 Channel 3 global Interrupt                      */
N#define  BSP_INT_ID_DMA2_CH4_5                            59    /* DMA2 Channel 4 and DMA2 Channel 5 global Interrupt   */
N
N/*
N*********************************************************************************************************
N*                                             PERIPH DEFINES
N*********************************************************************************************************
N*/
N
N#define  BSP_PERIPH_ID_DMA1                                0
N#define  BSP_PERIPH_ID_DMA2                                1
N#define  BSP_PERIPH_ID_SRAM                                2
N#define  BSP_PERIPH_ID_FLITF                               4
N#define  BSP_PERIPH_ID_CRC                                 6
N#define  BSP_PERIPH_ID_FSMC                                8
N#define  BSP_PERIPH_ID_SDIO                               10
N
N#define  BSP_PERIPH_ID_AFIO                               32
N#define  BSP_PERIPH_ID_IOPA                               34
N#define  BSP_PERIPH_ID_IOPB                               35
N#define  BSP_PERIPH_ID_IOPC                               36
N#define  BSP_PERIPH_ID_IOPD                               37
N#define  BSP_PERIPH_ID_IOPE                               38
N#define  BSP_PERIPH_ID_IOPF                               39
N#define  BSP_PERIPH_ID_IOPG                               40
N#define  BSP_PERIPH_ID_ADC1                               41
N#define  BSP_PERIPH_ID_ADC2                               42
N#define  BSP_PERIPH_ID_TIM1                               43
N#define  BSP_PERIPH_ID_SPI1                               44
N#define  BSP_PERIPH_ID_TIM8                               45
N#define  BSP_PERIPH_ID_USART1                             46
N#define  BSP_PERIPH_ID_ADC3                               47
N
N#define  BSP_PERIPH_ID_TIM2                               64
N#define  BSP_PERIPH_ID_TIM3                               65
N#define  BSP_PERIPH_ID_TIM4                               66
N#define  BSP_PERIPH_ID_TIM5                               67
N#define  BSP_PERIPH_ID_TIM6                               68
N#define  BSP_PERIPH_ID_TIM7                               69
N#define  BSP_PERIPH_ID_WWDG                               75
N#define  BSP_PERIPH_ID_SPI2                               78
N#define  BSP_PERIPH_ID_SPI3                               79
N#define  BSP_PERIPH_ID_USART2                             81
N#define  BSP_PERIPH_ID_USART3                             82
N#define  BSP_PERIPH_ID_USART4                             83
N#define  BSP_PERIPH_ID_USART5                             84
N#define  BSP_PERIPH_ID_I2C1                               85
N#define  BSP_PERIPH_ID_I2C2                               86
N#define  BSP_PERIPH_ID_USB                                87
N#define  BSP_PERIPH_ID_CAN                                89
N#define  BSP_PERIPH_ID_BKP                                91
N#define  BSP_PERIPH_ID_PWR                                92
N#define  BSP_PERIPH_ID_DAC                                93
N
N/*
N*********************************************************************************************************
N*                                               DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                                 MACRO'S
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                           FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
Nvoid         BSP_Init                    (void);
N
Nvoid         BSP_IntDisAll               (void);
N
NCPU_INT32U   BSP_CPU_ClkFreq             (void);
N
N/*
N*********************************************************************************************************
N*                                           INTERRUPT SERVICES
N*********************************************************************************************************
N*/
N
Nvoid         BSP_IntInit                 (void);
N
Nvoid         BSP_IntEn                   (CPU_DATA       int_id);
N
Nvoid         BSP_IntDis                  (CPU_DATA       int_id);
N
Nvoid         BSP_IntClr                  (CPU_DATA       int_id);
N
Nvoid         BSP_IntVectSet              (CPU_DATA       int_id,
N                                          CPU_FNCT_VOID  isr);
N
Nvoid         BSP_IntPrioSet              (CPU_DATA       int_id,
N                                          CPU_INT08U     prio);
N
Nvoid         BSP_IntHandlerWWDG          (void);
Nvoid         BSP_IntHandlerPVD           (void);
Nvoid         BSP_IntHandlerTAMPER        (void);
Nvoid         BSP_IntHandlerRTC           (void);
Nvoid         BSP_IntHandlerFLASH         (void);
Nvoid         BSP_IntHandlerRCC           (void);
Nvoid         BSP_IntHandlerEXTI0         (void);
Nvoid         BSP_IntHandlerEXTI1         (void);
Nvoid         BSP_IntHandlerEXTI2         (void);
Nvoid         BSP_IntHandlerEXTI3         (void);
Nvoid         BSP_IntHandlerEXTI4         (void);
Nvoid         BSP_IntHandlerDMA1_CH1      (void);
Nvoid         BSP_IntHandlerDMA1_CH2      (void);
Nvoid         BSP_IntHandlerDMA1_CH3      (void);
Nvoid         BSP_IntHandlerDMA1_CH4      (void);
Nvoid         BSP_IntHandlerDMA1_CH5      (void);
N
Nvoid         BSP_IntHandlerDMA1_CH6      (void);
Nvoid         BSP_IntHandlerDMA1_CH7      (void);
Nvoid         BSP_IntHandlerADC1_2        (void);
Nvoid         BSP_IntHandlerUSB_HP_CAN_TX (void);
Nvoid         BSP_IntHandlerUSB_LP_CAN_RX0(void);
Nvoid         BSP_IntHandlerCAN_RX1       (void);
Nvoid         BSP_IntHandlerCAN_SCE       (void);
Nvoid         BSP_IntHandlerEXTI9_5       (void);
Nvoid         BSP_IntHandlerTIM1_BRK      (void);
Nvoid         BSP_IntHandlerTIM1_UP       (void);
Nvoid         BSP_IntHandlerTIM1_TRG_COM  (void);
Nvoid         BSP_IntHandlerTIM1_CC       (void);
Nvoid         BSP_IntHandlerTIM2          (void);
Nvoid         BSP_IntHandlerTIM3          (void);
Nvoid         BSP_IntHandlerTIM4          (void);
Nvoid         BSP_IntHandlerI2C1_EV       (void);
N
Nvoid         BSP_IntHandlerI2C1_ER       (void);
Nvoid         BSP_IntHandlerI2C2_EV       (void);
Nvoid         BSP_IntHandlerI2C2_ER       (void);
Nvoid         BSP_IntHandlerSPI1          (void);
Nvoid         BSP_IntHandlerSPI2          (void);
Nvoid         BSP_IntHandlerUSART1        (void);
Nvoid         BSP_IntHandlerUSART2        (void);
Nvoid         BSP_IntHandlerUSART3        (void);
Nvoid         BSP_IntHandlerEXTI15_10     (void);
Nvoid         BSP_IntHandlerRTCAlarm      (void);
Nvoid         BSP_IntHandlerUSBWakeUp     (void);
N
N/*
N*********************************************************************************************************
N*                                     PERIPHERAL POWER/CLOCK SERVICES
N*********************************************************************************************************
N*/
N
NCPU_INT32U   BSP_PeriphClkFreqGet        (CPU_DATA       pwr_clk_id);
N
Nvoid         BSP_PeriphEn                (CPU_DATA       pwr_clk_id);
N
Nvoid         BSP_PeriphDis               (CPU_DATA       pwr_clk_id);
N
N/*
N*********************************************************************************************************
N*                                              LED SERVICES
N*********************************************************************************************************
N*/
N
Nvoid         BSP_LED_On                  (CPU_INT08U     led);
N
Nvoid         BSP_LED_Off                 (CPU_INT08U     led);
N
Nvoid         BSP_LED_Toggle              (CPU_INT08U     led);
N
N/*
N*********************************************************************************************************
N*                                               PB SERVICES
N*********************************************************************************************************
N*/
N
NCPU_BOOLEAN  BSP_PB_GetStatus            (CPU_INT08U     pb);
N
N/*
N*********************************************************************************************************
N*                                              ADC SERVICES
N*********************************************************************************************************
N*/
N
NCPU_INT16U   BSP_ADC_GetStatus           (CPU_INT08U     led);
N
N/*
N*********************************************************************************************************
N*                                           JOYSTICK SERVICES
N*********************************************************************************************************
N*/
N
NCPU_INT32U   BSP_Joystick_GetStatus      (void);
N
N/*
N*********************************************************************************************************
N*                                               MODULE END
N*********************************************************************************************************
N*/
N
N#endif                                                          /* End of module include.                               */
L 37 "..\BSP\bsp_periph.c" 2
N
N
N/*
N*********************************************************************************************************
N*                                            LOCAL DEFINES
N*********************************************************************************************************
N*/
N
N#define  BSP_PERIPH_REG_RCC_BASE                 0x40021000
N#define  BSP_PERIPH_REG_RCC_CFGR            (*(volatile  CPU_INT32U *)(BSP_PERIPH_REG_RCC_BASE + 0x004))
N#define  BSP_PERIPH_REG_RCC_AHBENR          (*(volatile  CPU_INT32U *)(BSP_PERIPH_REG_RCC_BASE + 0x014))
N#define  BSP_PERIPH_REG_RCC_APB2ENR         (*(volatile  CPU_INT32U *)(BSP_PERIPH_REG_RCC_BASE + 0x018))
N#define  BSP_PERIPH_REG_RCC_APB1ENR         (*(volatile  CPU_INT32U *)(BSP_PERIPH_REG_RCC_BASE + 0x01C))
N
N
N/*
N*********************************************************************************************************
N*                                           LOCAL CONSTANTS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                          LOCAL DATA TYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                            LOCAL TABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                       LOCAL GLOBAL VARIABLES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                      LOCAL FUNCTION PROTOTYPES
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                     LOCAL CONFIGURATION ERRORS
N*********************************************************************************************************
N*/
N
N
N/*
N*********************************************************************************************************
N*                                         BSP_PeriphClkFreqGet()
N*
N* Description : Get clock frequency of a peripheral.
N*
N* Argument(s) : pwr_clk_id      Power/clock ID.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
NCPU_INT32U  BSP_PeriphClkFreqGet (CPU_DATA  pwr_clk_id)
N{
N    CPU_INT32U  clk_freq;
N    CPU_INT32U  clk_div;
N
N
N    clk_freq = BSP_CPU_ClkFreq();
N
N    switch (pwr_clk_id) {
N        case BSP_PERIPH_ID_DMA1:
X        case 0:
N        case BSP_PERIPH_ID_DMA2:
X        case 1:
N        case BSP_PERIPH_ID_SRAM:
X        case 2:
N        case BSP_PERIPH_ID_FLITF:
X        case 4:
N        case BSP_PERIPH_ID_CRC:
X        case 6:
N        case BSP_PERIPH_ID_FSMC:
X        case 8:
N        case BSP_PERIPH_ID_SDIO:
X        case 10:
N             return (clk_freq);
N
N        case BSP_PERIPH_ID_AFIO:
X        case 32:
N        case BSP_PERIPH_ID_IOPA:
X        case 34:
N        case BSP_PERIPH_ID_IOPB:
X        case 35:
N        case BSP_PERIPH_ID_IOPC:
X        case 36:
N        case BSP_PERIPH_ID_IOPD:
X        case 37:
N        case BSP_PERIPH_ID_IOPE:
X        case 38:
N        case BSP_PERIPH_ID_IOPF:
X        case 39:
N        case BSP_PERIPH_ID_IOPG:
X        case 40:
N        case BSP_PERIPH_ID_ADC1:
X        case 41:
N        case BSP_PERIPH_ID_ADC2:
X        case 42:
N        case BSP_PERIPH_ID_TIM1:
X        case 43:
N        case BSP_PERIPH_ID_SPI1:
X        case 44:
N        case BSP_PERIPH_ID_TIM8:
X        case 45:
N        case BSP_PERIPH_ID_USART1:
X        case 46:
N        case BSP_PERIPH_ID_ADC3:
X        case 47:
N             clk_div = (BSP_PERIPH_REG_RCC_CFGR & 0x00003800) >> 11;
X             clk_div = ((*(volatile CPU_INT32U *)(0x40021000 + 0x004)) & 0x00003800) >> 11;
N             if (clk_div < 4) {
N                 return (clk_freq);
N             }
N             clk_div   = (clk_div - 3) << 1;
N             clk_freq /= clk_div;
N             return (clk_freq);
N
N        case BSP_PERIPH_ID_TIM2:
X        case 64:
N        case BSP_PERIPH_ID_TIM3:
X        case 65:
N        case BSP_PERIPH_ID_TIM4:
X        case 66:
N        case BSP_PERIPH_ID_TIM5:
X        case 67:
N        case BSP_PERIPH_ID_TIM6:
X        case 68:
N        case BSP_PERIPH_ID_TIM7:
X        case 69:
N        case BSP_PERIPH_ID_WWDG:
X        case 75:
N        case BSP_PERIPH_ID_SPI2:
X        case 78:
N        case BSP_PERIPH_ID_SPI3:
X        case 79:
N        case BSP_PERIPH_ID_USART2:
X        case 81:
N        case BSP_PERIPH_ID_USART3:
X        case 82:
N        case BSP_PERIPH_ID_USART4:
X        case 83:
N        case BSP_PERIPH_ID_USART5:
X        case 84:
N        case BSP_PERIPH_ID_I2C1:
X        case 85:
N        case BSP_PERIPH_ID_I2C2:
X        case 86:
N        case BSP_PERIPH_ID_USB:
X        case 87:
N        case BSP_PERIPH_ID_CAN:
X        case 89:
N        case BSP_PERIPH_ID_BKP:
X        case 91:
N        case BSP_PERIPH_ID_PWR:
X        case 92:
N        case BSP_PERIPH_ID_DAC:
X        case 93:
N             clk_div = (BSP_PERIPH_REG_RCC_CFGR & 0x00000700) >> 8;
X             clk_div = ((*(volatile CPU_INT32U *)(0x40021000 + 0x004)) & 0x00000700) >> 8;
N             if (clk_div < 4) {
N                 return (clk_freq);
N             }
N             clk_div   = (clk_div - 3) << 1;
N             clk_freq /= clk_div;
N             return (clk_freq);
N    }
N
N    return ((CPU_INT32U)0);
N}
N
N
N/*
N*********************************************************************************************************
N*                                             BSP_PeriphEn()
N*
N* Description : Enable clock for peripheral.
N*
N* Argument(s) : pwr_clk_id      Power/clock ID.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
Nvoid  BSP_PeriphEn (CPU_DATA  pwr_clk_id)
N{
N    switch (pwr_clk_id) {
N        case BSP_PERIPH_ID_DMA1:
X        case 0:
N        case BSP_PERIPH_ID_DMA2:
X        case 1:
N        case BSP_PERIPH_ID_SRAM:
X        case 2:
N        case BSP_PERIPH_ID_FLITF:
X        case 4:
N        case BSP_PERIPH_ID_CRC:
X        case 6:
N        case BSP_PERIPH_ID_FSMC:
X        case 8:
N        case BSP_PERIPH_ID_SDIO:
X        case 10:
N             BSP_PERIPH_REG_RCC_AHBENR |= DEF_BIT(pwr_clk_id);
X             (*(volatile CPU_INT32U *)(0x40021000 + 0x014)) |= (1u << (pwr_clk_id));
N             break;
N
N        case BSP_PERIPH_ID_AFIO:
X        case 32:
N        case BSP_PERIPH_ID_IOPA:
X        case 34:
N        case BSP_PERIPH_ID_IOPB:
X        case 35:
N        case BSP_PERIPH_ID_IOPC:
X        case 36:
N        case BSP_PERIPH_ID_IOPD:
X        case 37:
N        case BSP_PERIPH_ID_IOPE:
X        case 38:
N        case BSP_PERIPH_ID_IOPF:
X        case 39:
N        case BSP_PERIPH_ID_IOPG:
X        case 40:
N        case BSP_PERIPH_ID_ADC1:
X        case 41:
N        case BSP_PERIPH_ID_ADC2:
X        case 42:
N        case BSP_PERIPH_ID_TIM1:
X        case 43:
N        case BSP_PERIPH_ID_SPI1:
X        case 44:
N        case BSP_PERIPH_ID_TIM8:
X        case 45:
N        case BSP_PERIPH_ID_USART1:
X        case 46:
N        case BSP_PERIPH_ID_ADC3:
X        case 47:
N             BSP_PERIPH_REG_RCC_APB2ENR |= DEF_BIT(pwr_clk_id - 32);
X             (*(volatile CPU_INT32U *)(0x40021000 + 0x018)) |= (1u << (pwr_clk_id - 32));
N             break;
N
N        case BSP_PERIPH_ID_TIM2:
X        case 64:
N        case BSP_PERIPH_ID_TIM3:
X        case 65:
N        case BSP_PERIPH_ID_TIM4:
X        case 66:
N        case BSP_PERIPH_ID_TIM5:
X        case 67:
N        case BSP_PERIPH_ID_TIM6:
X        case 68:
N        case BSP_PERIPH_ID_TIM7:
X        case 69:
N        case BSP_PERIPH_ID_WWDG:
X        case 75:
N        case BSP_PERIPH_ID_SPI2:
X        case 78:
N        case BSP_PERIPH_ID_SPI3:
X        case 79:
N        case BSP_PERIPH_ID_USART2:
X        case 81:
N        case BSP_PERIPH_ID_USART3:
X        case 82:
N        case BSP_PERIPH_ID_USART4:
X        case 83:
N        case BSP_PERIPH_ID_USART5:
X        case 84:
N        case BSP_PERIPH_ID_I2C1:
X        case 85:
N        case BSP_PERIPH_ID_I2C2:
X        case 86:
N        case BSP_PERIPH_ID_USB:
X        case 87:
N        case BSP_PERIPH_ID_CAN:
X        case 89:
N        case BSP_PERIPH_ID_BKP:
X        case 91:
N        case BSP_PERIPH_ID_PWR:
X        case 92:
N        case BSP_PERIPH_ID_DAC:
X        case 93:
N             BSP_PERIPH_REG_RCC_APB1ENR |= DEF_BIT(pwr_clk_id - 64);
X             (*(volatile CPU_INT32U *)(0x40021000 + 0x01C)) |= (1u << (pwr_clk_id - 64));
N             break;
N    }
N}
N
N
N/*
N*********************************************************************************************************
N*                                             BSP_PeriphDis()
N*
N* Description : Disable clock for peripheral.
N*
N* Argument(s) : pwr_clk_id      Power/clock ID.
N*
N* Return(s)   : none.
N*
N* Caller(s)   : Application.
N*
N* Note(s)     : none.
N*********************************************************************************************************
N*/
N
Nvoid  BSP_PeriphDis (CPU_DATA  pwr_clk_id)
N{
N    switch (pwr_clk_id) {
N        case BSP_PERIPH_ID_DMA1:
X        case 0:
N        case BSP_PERIPH_ID_DMA2:
X        case 1:
N        case BSP_PERIPH_ID_SRAM:
X        case 2:
N        case BSP_PERIPH_ID_FLITF:
X        case 4:
N        case BSP_PERIPH_ID_CRC:
X        case 6:
N        case BSP_PERIPH_ID_FSMC:
X        case 8:
N        case BSP_PERIPH_ID_SDIO:
X        case 10:
N             BSP_PERIPH_REG_RCC_AHBENR &= ~DEF_BIT(pwr_clk_id);
X             (*(volatile CPU_INT32U *)(0x40021000 + 0x014)) &= ~(1u << (pwr_clk_id));
N             break;
N
N        case BSP_PERIPH_ID_AFIO:
X        case 32:
N        case BSP_PERIPH_ID_IOPA:
X        case 34:
N        case BSP_PERIPH_ID_IOPB:
X        case 35:
N        case BSP_PERIPH_ID_IOPC:
X        case 36:
N        case BSP_PERIPH_ID_IOPD:
X        case 37:
N        case BSP_PERIPH_ID_IOPE:
X        case 38:
N        case BSP_PERIPH_ID_IOPF:
X        case 39:
N        case BSP_PERIPH_ID_IOPG:
X        case 40:
N        case BSP_PERIPH_ID_ADC1:
X        case 41:
N        case BSP_PERIPH_ID_ADC2:
X        case 42:
N        case BSP_PERIPH_ID_TIM1:
X        case 43:
N        case BSP_PERIPH_ID_SPI1:
X        case 44:
N        case BSP_PERIPH_ID_TIM8:
X        case 45:
N        case BSP_PERIPH_ID_USART1:
X        case 46:
N        case BSP_PERIPH_ID_ADC3:
X        case 47:
N             BSP_PERIPH_REG_RCC_APB2ENR &= ~DEF_BIT(pwr_clk_id - 32);
X             (*(volatile CPU_INT32U *)(0x40021000 + 0x018)) &= ~(1u << (pwr_clk_id - 32));
N             break;
N
N        case BSP_PERIPH_ID_TIM2:
X        case 64:
N        case BSP_PERIPH_ID_TIM3:
X        case 65:
N        case BSP_PERIPH_ID_TIM4:
X        case 66:
N        case BSP_PERIPH_ID_TIM5:
X        case 67:
N        case BSP_PERIPH_ID_TIM6:
X        case 68:
N        case BSP_PERIPH_ID_TIM7:
X        case 69:
N        case BSP_PERIPH_ID_WWDG:
X        case 75:
N        case BSP_PERIPH_ID_SPI2:
X        case 78:
N        case BSP_PERIPH_ID_SPI3:
X        case 79:
N        case BSP_PERIPH_ID_USART2:
X        case 81:
N        case BSP_PERIPH_ID_USART3:
X        case 82:
N        case BSP_PERIPH_ID_USART4:
X        case 83:
N        case BSP_PERIPH_ID_USART5:
X        case 84:
N        case BSP_PERIPH_ID_I2C1:
X        case 85:
N        case BSP_PERIPH_ID_I2C2:
X        case 86:
N        case BSP_PERIPH_ID_USB:
X        case 87:
N        case BSP_PERIPH_ID_CAN:
X        case 89:
N        case BSP_PERIPH_ID_BKP:
X        case 91:
N        case BSP_PERIPH_ID_PWR:
X        case 92:
N        case BSP_PERIPH_ID_DAC:
X        case 93:
N             BSP_PERIPH_REG_RCC_APB1ENR &= ~DEF_BIT(pwr_clk_id - 64);
X             (*(volatile CPU_INT32U *)(0x40021000 + 0x01C)) &= ~(1u << (pwr_clk_id - 64));
N             break;
N    }
N}
