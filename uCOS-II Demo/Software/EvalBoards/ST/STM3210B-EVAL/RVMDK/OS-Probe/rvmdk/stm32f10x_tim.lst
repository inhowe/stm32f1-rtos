L 1 "..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_tim.c"
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_tim.c
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file provides all the TIM firmware functions.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_tim.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_tim.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_tim.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the 
N*                      TIM firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TIM_H
N#define __STM32F10x_TIM_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_map.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_map.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the peripheral register's definitions
N*                      and memory mapping.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_MAP_H
N#define __STM32F10x_MAP_H
N
N#ifndef EXT
N  #define EXT extern
N#endif /* EXT */
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_conf.h"
L 1 ".\stm32f10x_conf.h" 1
N/******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
N* File Name          : stm32f10x_conf.h
N* Author             : MCD Application Team
N* Date First Issued  : 05/21/2007
N* Description        : Library configuration file.
N********************************************************************************
N* History:
N* 05/21/2007: V0.1
N********************************************************************************
N* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CONF_H
N#define __STM32F10x_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_type.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_type.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the common data types used for the
N*                      STM32F10x firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TYPE_H
N#define __STM32F10x_TYPE_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
Ntypedef signed long  s32;
Ntypedef signed short s16;
Ntypedef signed char  s8;
N
Ntypedef signed long  const sc32;  /* Read Only */
Ntypedef signed short const sc16;  /* Read Only */
Ntypedef signed char  const sc8;   /* Read Only */
N
Ntypedef volatile signed long  vs32;
Ntypedef volatile signed short vs16;
Ntypedef volatile signed char  vs8;
N
Ntypedef volatile signed long  const vsc32;  /* Read Only */
Ntypedef volatile signed short const vsc16;  /* Read Only */
Ntypedef volatile signed char  const vsc8;   /* Read Only */
N
Ntypedef unsigned long  u32;
Ntypedef unsigned short u16;
Ntypedef unsigned char  u8;
N
Ntypedef unsigned long  const uc32;  /* Read Only */
Ntypedef unsigned short const uc16;  /* Read Only */
Ntypedef unsigned char  const uc8;   /* Read Only */
N
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
Ntypedef volatile unsigned char  vu8;
N
Ntypedef volatile unsigned long  const vuc32;  /* Read Only */
Ntypedef volatile unsigned short const vuc16;  /* Read Only */
Ntypedef volatile unsigned char  const vuc8;   /* Read Only */
N
Ntypedef enum {FALSE = 0, TRUE = !FALSE} bool;
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N#define U8_MAX     ((u8)255)
N#define S8_MAX     ((s8)127)
N#define S8_MIN     ((s8)-128)
N#define U16_MAX    ((u16)65535u)
N#define S16_MAX    ((s16)32767)
N#define S16_MIN    ((s16)-32768)
N#define U32_MAX    ((u32)4294967295uL)
N#define S32_MAX    ((s32)2147483647)
N#define S32_MIN    ((s32)-2147483648)
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_TYPE_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 24 ".\stm32f10x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
N   the "assert" macro in the firmware library code (see "Exported macro" section below) */
N//#define DEBUG
N
N/* Comment the line below to disable the specific peripheral inclusion */
N/************************************* ADC ************************************/
N#define _ADC
N#define _ADC1
N#define _ADC2
N
N/************************************* BKP ************************************/
N#define _BKP
N
N/************************************* CAN ************************************/
N//#define _CAN
N
N/************************************* DMA ************************************/
N//#define _DMA
N//#define _DMA_Channel1
N//#define _DMA_Channel2
N//#define _DMA_Channel3
N//#define _DMA_Channel4
N//#define _DMA_Channel5
N//#define _DMA_Channel6
N//#define _DMA_Channel7
N
N/************************************* EXTI ***********************************/
N#define _EXTI
N
N/************************************* FLASH and Option Bytes *****************/
N#define _FLASH
N/* Uncomment the line below to enable FLASH program/erase/protections functions,
N   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
N   are enabled */
N//#define _FLASH_PROG
N
N/************************************* GPIO ***********************************/
N#define _GPIO
N#define _GPIOA
N#define _GPIOB
N#define _GPIOC
N#define _GPIOD
N#define _GPIOE
N#define _AFIO
N
N/************************************* I2C ************************************/
N#define _I2C
N#define _I2C1
N//#define _I2C2
N
N/************************************* IWDG ***********************************/
N//#define _IWDG
N
N/************************************* NVIC ***********************************/
N#define _NVIC
N
N/************************************* PWR ************************************/
N#define _PWR
N
N/************************************* RCC ************************************/
N#define _RCC
N
N/************************************* RTC ************************************/
N#define _RTC
N
N/************************************* SPI ************************************/
N#define _SPI
N#define _SPI1
N#define _SPI2
N
N/************************************* SysTick ********************************/
N#define _SysTick
N
N/************************************* TIM1 ***********************************/
N#define _TIM1
N
N/************************************* TIM ************************************/
N#define _TIM
N#define _TIM2
N//#define _TIM3
N#define _TIM4
N
N/************************************* USART **********************************/
N#define _USART
N#define _USART1
N#define _USART2
N#define _USART3
N
N/************************************* WWDG ***********************************/
N//#define _WWDG
N
N/* In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application */
N#define HSE_Value    ((u32)8000000) /* Value of the External oscillator in Hz*/
N
N/* Exported macro ------------------------------------------------------------*/
N#undef assert
N#ifdef  DEBUG
S/*******************************************************************************
S* Macro Name     : assert
S* Description    : The assert macro is used for function's parameters check.
S*                  It is used only if the library is compiled in DEBUG mode.
S* Input          : - expr: If expr is false, it calls assert_failed function
S*                    which reports the name of the source file and the source
S*                    line number of the call that failed.
S*                    If expr is true, it returns no value.
S* Return         : None
S*******************************************************************************/
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(u8* file, u32 line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* DEBUG */
N
N#endif /* __STM32F10x_CONF_H */
N
N/******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
L 29 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_map.h" 2
N#include "stm32f10x_type.h"
N#include "cortexm3_macro.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\cortexm3_macro.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : cortexm3_macro.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : Header file for cortexm3_macro.s.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CORTEXM3_MACRO_H
N#define __CORTEXM3_MACRO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid __WFI(void);
Nvoid __WFE(void);
Nvoid __SEV(void);
Nvoid __ISB(void);
Nvoid __DSB(void);
Nvoid __DMB(void);
Nvoid __SVC(void);
Nu32 __MRS_CONTROL(void);
Nvoid __MSR_CONTROL(u32 Control);
Nu32 __MRS_PSP(void);
Nvoid __MSR_PSP(u32 TopOfProcessStack);
Nu32 __MRS_MSP(void);
Nvoid __MSR_MSP(u32 TopOfMainStack);
Nvoid __RESETPRIMASK(void);
Nvoid __SETPRIMASK(void);
Nu32 __READ_PRIMASK(void);
Nvoid __RESETFAULTMASK(void);
Nvoid __SETFAULTMASK(void);
Nu32 __READ_FAULTMASK(void);
Nvoid __BASEPRICONFIG(u32 NewPriority);
Nu32 __GetBASEPRI(void);
Nu16 __REV_HalfWord(u16 Data);
Nu32 __REV_Word(u32 Data);
N
N#endif /* __CORTEXM3_MACRO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 31 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_map.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/******************************************************************************/
N/*                         Peripheral registers structures                    */
N/******************************************************************************/
N
N/*------------------------ Analog to Digital Converter -----------------------*/
Ntypedef struct
N{
N  vu32 SR;
N  vu32 CR1;
N  vu32 CR2;
N  vu32 SMPR1;
N  vu32 SMPR2;
N  vu32 JOFR1;
N  vu32 JOFR2;
N  vu32 JOFR3;
N  vu32 JOFR4;
N  vu32 HTR;
N  vu32 LTR;
N  vu32 SQR1;
N  vu32 SQR2;
N  vu32 SQR3;
N  vu32 JSQR;
N  vu32 JDR1;
N  vu32 JDR2;
N  vu32 JDR3;
N  vu32 JDR4;
N  vu32 DR;
N} ADC_TypeDef;
N
N/*------------------------ Backup Registers ----------------------------------*/
Ntypedef struct
N{
N  u32  RESERVED0;
N  vu16 DR1;
N  u16  RESERVED1;
N  vu16 DR2;
N  u16  RESERVED2;
N  vu16 DR3;
N  u16  RESERVED3;
N  vu16 DR4;
N  u16  RESERVED4;
N  vu16 DR5;
N  u16  RESERVED5;
N  vu16 DR6;
N  u16  RESERVED6;
N  vu16 DR7;
N  u16  RESERVED7;
N  vu16 DR8;
N  u16  RESERVED8;
N  vu16 DR9;
N  u16  RESERVED9;
N  vu16 DR10;
N  u16  RESERVED10; 
N  vu16 RTCCR;
N  u16  RESERVED11;
N  vu16 CR;
N  u16  RESERVED12;
N  vu16 CSR;
N  u16  RESERVED13[5];
N  vu16 DR11;
N  u16  RESERVED14;
N  vu16 DR12;
N  u16  RESERVED15;
N  vu16 DR13;
N  u16  RESERVED16;
N  vu16 DR14;
N  u16  RESERVED17;
N  vu16 DR15;
N  u16  RESERVED18;
N  vu16 DR16;
N  u16  RESERVED19;
N  vu16 DR17;
N  u16  RESERVED20;
N  vu16 DR18;
N  u16  RESERVED21;
N  vu16 DR19;
N  u16  RESERVED22;
N  vu16 DR20;
N  u16  RESERVED23;
N  vu16 DR21;
N  u16  RESERVED24;
N  vu16 DR22;
N  u16  RESERVED25;
N  vu16 DR23;
N  u16  RESERVED26;
N  vu16 DR24;
N  u16  RESERVED27;
N  vu16 DR25;
N  u16  RESERVED28;
N  vu16 DR26;
N  u16  RESERVED29;
N  vu16 DR27;
N  u16  RESERVED30;
N  vu16 DR28;
N  u16  RESERVED31;
N  vu16 DR29;
N  u16  RESERVED32;
N  vu16 DR30;
N  u16  RESERVED33; 
N  vu16 DR31;
N  u16  RESERVED34;
N  vu16 DR32;
N  u16  RESERVED35;
N  vu16 DR33;
N  u16  RESERVED36;
N  vu16 DR34;
N  u16  RESERVED37;
N  vu16 DR35;
N  u16  RESERVED38;
N  vu16 DR36;
N  u16  RESERVED39;
N  vu16 DR37;
N  u16  RESERVED40;
N  vu16 DR38;
N  u16  RESERVED41;
N  vu16 DR39;
N  u16  RESERVED42;
N  vu16 DR40;
N  u16  RESERVED43;
N  vu16 DR41;
N  u16  RESERVED44;
N  vu16 DR42;
N  u16  RESERVED45;    
N} BKP_TypeDef;
N
N/*------------------------ Controller Area Network ---------------------------*/
Ntypedef struct
N{
N  vu32 TIR;
N  vu32 TDTR;
N  vu32 TDLR;
N  vu32 TDHR;
N} CAN_TxMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 RIR;
N  vu32 RDTR;
N  vu32 RDLR;
N  vu32 RDHR;
N} CAN_FIFOMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 FR1;
N  vu32 FR2;
N} CAN_FilterRegister_TypeDef;
N
Ntypedef struct
N{
N  vu32 MCR;
N  vu32 MSR;
N  vu32 TSR;
N  vu32 RF0R;
N  vu32 RF1R;
N  vu32 IER;
N  vu32 ESR;
N  vu32 BTR;
N  u32  RESERVED0[88];
N  CAN_TxMailBox_TypeDef sTxMailBox[3];
N  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
N  u32  RESERVED1[12];
N  vu32 FMR;
N  vu32 FM1R;
N  u32  RESERVED2;
N  vu32 FS1R;
N  u32  RESERVED3;
N  vu32 FFA1R;
N  u32  RESERVED4;
N  vu32 FA1R;
N  u32  RESERVED5[8];
N  CAN_FilterRegister_TypeDef sFilterRegister[14];
N} CAN_TypeDef;
N
N/*------------------------ CRC calculation unit ------------------------------*/
Ntypedef struct
N{
N  vu32 DR;
N  vu8  IDR;
N  u8   RESERVED0;
N  u16  RESERVED1;
N  vu32 CR;
N} CRC_TypeDef;
N
N
N/*------------------------ Digital to Analog Converter -----------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 SWTRIGR;
N  vu32 DHR12R1;
N  vu32 DHR12L1;
N  vu32 DHR8R1;
N  vu32 DHR12R2;
N  vu32 DHR12L2;
N  vu32 DHR8R2;
N  vu32 DHR12RD;
N  vu32 DHR12LD;
N  vu32 DHR8RD;
N  vu32 DOR1;
N  vu32 DOR2;
N} DAC_TypeDef;
N
N/*------------------------ Debug MCU -----------------------------------------*/
Ntypedef struct
N{
N  vu32 IDCODE;
N  vu32 CR;	
N}DBGMCU_TypeDef;
N
N/*------------------------ DMA Controller ------------------------------------*/
Ntypedef struct
N{
N  vu32 CCR;
N  vu32 CNDTR;
N  vu32 CPAR;
N  vu32 CMAR;
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  vu32 ISR;
N  vu32 IFCR;
N} DMA_TypeDef;
N
N/*------------------------ External Interrupt/Event Controller ---------------*/
Ntypedef struct
N{
N  vu32 IMR;
N  vu32 EMR;
N  vu32 RTSR;
N  vu32 FTSR;
N  vu32 SWIER;
N  vu32 PR;
N} EXTI_TypeDef;
N
N/*------------------------ FLASH and Option Bytes Registers ------------------*/
Ntypedef struct
N{
N  vu32 ACR;
N  vu32 KEYR;
N  vu32 OPTKEYR;
N  vu32 SR;
N  vu32 CR;
N  vu32 AR;
N  vu32 RESERVED;
N  vu32 OBR;
N  vu32 WRPR;
N} FLASH_TypeDef;
N
Ntypedef struct
N{
N  vu16 RDP;
N  vu16 USER;
N  vu16 Data0;
N  vu16 Data1;
N  vu16 WRP0;
N  vu16 WRP1;
N  vu16 WRP2;
N  vu16 WRP3;
N} OB_TypeDef;
N
N/*------------------------ Flexible Static Memory Controller -----------------*/
Ntypedef struct
N{
N  vu32 BTCR[8];   
N} FSMC_Bank1_TypeDef; 
N
Ntypedef struct
N{
N  vu32 BWTR[7];
N} FSMC_Bank1E_TypeDef;
N
Ntypedef struct
N{
N  vu32 PCR2;
N  vu32 SR2;
N  vu32 PMEM2;
N  vu32 PATT2;
N  u32  RESERVED0;   
N  vu32 ECCR2; 
N} FSMC_Bank2_TypeDef;  
N
Ntypedef struct
N{
N  vu32 PCR3;
N  vu32 SR3;
N  vu32 PMEM3;
N  vu32 PATT3;
N  u32  RESERVED0;   
N  vu32 ECCR3; 
N} FSMC_Bank3_TypeDef; 
N
Ntypedef struct
N{
N  vu32 PCR4;
N  vu32 SR4;
N  vu32 PMEM4;
N  vu32 PATT4;
N  vu32 PIO4; 
N} FSMC_Bank4_TypeDef; 
N
N/*------------------------ General Purpose and Alternate Function IO ---------*/
Ntypedef struct
N{
N  vu32 CRL;
N  vu32 CRH;
N  vu32 IDR;
N  vu32 ODR;
N  vu32 BSRR;
N  vu32 BRR;
N  vu32 LCKR;
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  vu32 EVCR;
N  vu32 MAPR;
N  vu32 EXTICR[4];
N} AFIO_TypeDef;
N
N/*------------------------ Inter-integrated Circuit Interface ----------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 OAR1;
N  u16  RESERVED2;
N  vu16 OAR2;
N  u16  RESERVED3;
N  vu16 DR;
N  u16  RESERVED4;
N  vu16 SR1;
N  u16  RESERVED5;
N  vu16 SR2;
N  u16  RESERVED6;
N  vu16 CCR;
N  u16  RESERVED7;
N  vu16 TRISE;
N  u16  RESERVED8;
N} I2C_TypeDef;
N
N/*------------------------ Independent WATCHDOG ------------------------------*/
Ntypedef struct
N{
N  vu32 KR;
N  vu32 PR;
N  vu32 RLR;
N  vu32 SR;
N} IWDG_TypeDef;
N
N/*------------------------ Nested Vectored Interrupt Controller --------------*/
Ntypedef struct
N{
N  vu32 ISER[2];
N  u32  RESERVED0[30];
N  vu32 ICER[2];
N  u32  RSERVED1[30];
N  vu32 ISPR[2];
N  u32  RESERVED2[30];
N  vu32 ICPR[2];
N  u32  RESERVED3[30];
N  vu32 IABR[2];
N  u32  RESERVED4[62];
N  vu32 IPR[15];
N} NVIC_TypeDef;
N
Ntypedef struct
N{
N  vuc32 CPUID;
N  vu32 ICSR;
N  vu32 VTOR;
N  vu32 AIRCR;
N  vu32 SCR;
N  vu32 CCR;
N  vu32 SHPR[3];
N  vu32 SHCSR;
N  vu32 CFSR;
N  vu32 HFSR;
N  vu32 DFSR;
N  vu32 MMFAR;
N  vu32 BFAR;
N  vu32 AFSR;
N} SCB_TypeDef;
N
N/*------------------------ Power Control -------------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CSR;
N} PWR_TypeDef;
N
N/*------------------------ Reset and Clock Control ---------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFGR;
N  vu32 CIR;
N  vu32 APB2RSTR;
N  vu32 APB1RSTR;
N  vu32 AHBENR;
N  vu32 APB2ENR;
N  vu32 APB1ENR;
N  vu32 BDCR;
N  vu32 CSR;
N} RCC_TypeDef;
N
N/*------------------------ Real-Time Clock -----------------------------------*/
Ntypedef struct
N{
N  vu16 CRH;
N  u16  RESERVED0;
N  vu16 CRL;
N  u16  RESERVED1;
N  vu16 PRLH;
N  u16  RESERVED2;
N  vu16 PRLL;
N  u16  RESERVED3;
N  vu16 DIVH;
N  u16  RESERVED4;
N  vu16 DIVL;
N  u16  RESERVED5;
N  vu16 CNTH;
N  u16  RESERVED6;
N  vu16 CNTL;
N  u16  RESERVED7;
N  vu16 ALRH;
N  u16  RESERVED8;
N  vu16 ALRL;
N  u16  RESERVED9;
N} RTC_TypeDef;
N
N/*------------------------ SD host Interface ---------------------------------*/
Ntypedef struct
N{
N  vu32 POWER;
N  vu32 CLKCR;
N  vu32 ARG;
N  vu32 CMD;
N  vuc32 RESPCMD;
N  vuc32 RESP1;
N  vuc32 RESP2;
N  vuc32 RESP3;
N  vuc32 RESP4;
N  vu32 DTIMER;
N  vu32 DLEN;
N  vu32 DCTRL;
N  vuc32 DCOUNT;
N  vuc32 STA;
N  vu32 ICR;
N  vu32 MASK;
N  u32  RESERVED0[2];
N  vuc32 FIFOCNT;
N  u32  RESERVED1[13];
N  vu32 FIFO;
N} SDIO_TypeDef;
N
N/*------------------------ Serial Peripheral Interface -----------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SR;
N  u16  RESERVED2;
N  vu16 DR;
N  u16  RESERVED3;
N  vu16 CRCPR;
N  u16  RESERVED4;
N  vu16 RXCRCR;
N  u16  RESERVED5;
N  vu16 TXCRCR;
N  u16  RESERVED6;
N  vu16 I2SCFGR;
N  u16  RESERVED7;
N  vu16 I2SPR;
N  u16  RESERVED8;  
N} SPI_TypeDef;
N
N/*------------------------ SystemTick ----------------------------------------*/
Ntypedef struct
N{
N  vu32 CTRL;
N  vu32 LOAD;
N  vu32 VAL;
N  vuc32 CALIB;
N} SysTick_TypeDef;
N
N/*------------------------ TIM -----------------------------------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SMCR;
N  u16  RESERVED2;
N  vu16 DIER;
N  u16  RESERVED3;
N  vu16 SR;
N  u16  RESERVED4;
N  vu16 EGR;
N  u16  RESERVED5;
N  vu16 CCMR1;
N  u16  RESERVED6;
N  vu16 CCMR2;
N  u16  RESERVED7;
N  vu16 CCER;
N  u16  RESERVED8;
N  vu16 CNT;
N  u16  RESERVED9;
N  vu16 PSC;
N  u16  RESERVED10;
N  vu16 ARR;
N  u16  RESERVED11;
N  vu16 RCR;
N  u16  RESERVED12;
N  vu16 CCR1;
N  u16  RESERVED13;
N  vu16 CCR2;
N  u16  RESERVED14;
N  vu16 CCR3;
N  u16  RESERVED15;
N  vu16 CCR4;
N  u16  RESERVED16;
N  vu16 BDTR;
N  u16  RESERVED17;
N  vu16 DCR;
N  u16  RESERVED18;
N  vu16 DMAR;
N  u16  RESERVED19;
N} TIM_TypeDef;
N
N/*----------------- Universal Synchronous Asynchronous Receiver Transmitter --*/
Ntypedef struct
N{
N  vu16 SR;
N  u16  RESERVED0;
N  vu16 DR;
N  u16  RESERVED1;
N  vu16 BRR;
N  u16  RESERVED2;
N  vu16 CR1;
N  u16  RESERVED3;
N  vu16 CR2;
N  u16  RESERVED4;
N  vu16 CR3;
N  u16  RESERVED5;
N  vu16 GTPR;
N  u16  RESERVED6;
N} USART_TypeDef;
N
N/*------------------------ Window WATCHDOG -----------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFR;
N  vu32 SR;
N} WWDG_TypeDef;
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Peripheral and SRAM base address in the alias region */
N#define PERIPH_BB_BASE        ((u32)0x42000000)
N#define SRAM_BB_BASE          ((u32)0x22000000)
N
N/* Peripheral and SRAM base address in the bit-band region */
N#define SRAM_BASE             ((u32)0x20000000)
N#define PERIPH_BASE           ((u32)0x40000000)
N
N/* FSMC registers base address */
N#define FSMC_R_BASE           ((u32)0xA0000000)
N
N/* Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN_BASE              (APB1PERIPH_BASE + 0x6400)
N#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N
N#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
N#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
N#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
N#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
N#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
N#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
N
N#define SDIO_BASE             (PERIPH_BASE + 0x18000)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N
N/* Flash registers base address */
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000)
N/* Flash Option Bytes base address */
N#define OB_BASE               ((u32)0x1FFFF800)
N
N/* FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE          ((u32)0xE0042000)
N
N/* System Control Space memory map */
N#define SCS_BASE              ((u32)0xE000E000)
N
N#define SysTick_BASE          (SCS_BASE + 0x0010)
N#define NVIC_BASE             (SCS_BASE + 0x0100)
N#define SCB_BASE              (SCS_BASE + 0x0D00)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/*------------------------ Non Debug Mode ------------------------------------*/
N#ifndef DEBUG
N#ifdef _TIM2
N  #define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#endif /*_TIM2 */
N
N#ifdef _TIM3
S  #define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#endif /*_TIM3 */
N
N#ifdef _TIM4
N  #define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#endif /*_TIM4 */
N
N#ifdef _TIM5
S  #define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#endif /*_TIM5 */
N
N#ifdef _TIM6
S  #define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#endif /*_TIM6 */
N
N#ifdef _TIM7
S  #define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#endif /*_TIM7 */
N
N#ifdef _RTC
N  #define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#endif /*_RTC */
N
N#ifdef _WWDG
S  #define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#endif /*_WWDG */
N
N#ifdef _IWDG
S  #define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#endif /*_IWDG */
N
N#ifdef _SPI2
N  #define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#endif /*_SPI2 */
N
N#ifdef _SPI3
S  #define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#endif /*_SPI3 */
N
N#ifdef _USART2
N  #define USART2              ((USART_TypeDef *) USART2_BASE)
N#endif /*_USART2 */
N
N#ifdef _USART3
N  #define USART3              ((USART_TypeDef *) USART3_BASE)
N#endif /*_USART3 */
N
N#ifdef _UART4
S  #define UART4              ((USART_TypeDef *) UART4_BASE)
N#endif /*_UART4 */
N
N#ifdef _UART5
S  #define UART5              ((USART_TypeDef *) UART5_BASE)
N#endif /*_USART5 */
N
N#ifdef _I2C1
N  #define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#endif /*_I2C1 */
N
N#ifdef _I2C2
S  #define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#endif /*_I2C2 */
N
N#ifdef _CAN
S  #define CAN                 ((CAN_TypeDef *) CAN_BASE)
N#endif /*_CAN */
N
N#ifdef _BKP
N  #define BKP                 ((BKP_TypeDef *) BKP_BASE)
N#endif /*_BKP */
N
N#ifdef _PWR
N  #define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#endif /*_PWR */
N
N#ifdef _DAC
S  #define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#endif /*_DAC */
N
N#ifdef _AFIO
N  #define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
N#endif /*_AFIO */
N
N#ifdef _EXTI
N  #define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#endif /*_EXTI */
N
N#ifdef _GPIOA
N  #define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#endif /*_GPIOA */
N
N#ifdef _GPIOB
N  #define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#endif /*_GPIOB */
N
N#ifdef _GPIOC
N  #define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#endif /*_GPIOC */
N
N#ifdef _GPIOD
N  #define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#endif /*_GPIOD */
N
N#ifdef _GPIOE
N  #define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#endif /*_GPIOE */
N
N#ifdef _GPIOF
S  #define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#endif /*_GPIOF */
N
N#ifdef _GPIOG
S  #define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#endif /*_GPIOG */
N
N#ifdef _ADC1
N  #define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#endif /*_ADC1 */
N
N#ifdef _ADC2
N  #define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#endif /*_ADC2 */
N
N#ifdef _TIM1
N  #define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#endif /*_TIM1 */
N
N#ifdef _SPI1
N  #define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#endif /*_SPI1 */
N
N#ifdef _TIM8
S  #define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#endif /*_TIM8 */
N
N#ifdef _USART1
N  #define USART1              ((USART_TypeDef *) USART1_BASE)
N#endif /*_USART1 */
N
N#ifdef _ADC3
S  #define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#endif /*_ADC3 */
N
N#ifdef _SDIO
S  #define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#endif /*_SDIO */
N
N#ifdef _DMA
S  #define DMA1                ((DMA_TypeDef *) DMA1_BASE)
S  #define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#endif /*_DMA */
N
N#ifdef _DMA1_Channel1
S  #define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#endif /*_DMA1_Channel1 */
N
N#ifdef _DMA1_Channel2
S  #define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#endif /*_DMA1_Channel2 */
N
N#ifdef _DMA1_Channel3
S  #define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#endif /*_DMA1_Channel3 */
N
N#ifdef _DMA1_Channel4
S  #define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#endif /*_DMA1_Channel4 */
N
N#ifdef _DMA1_Channel5
S  #define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#endif /*_DMA1_Channel5 */
N
N#ifdef _DMA1_Channel6
S  #define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#endif /*_DMA1_Channel6 */
N
N#ifdef _DMA1_Channel7
S  #define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#endif /*_DMA1_Channel7 */
N
N#ifdef _DMA2_Channel1
S  #define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#endif /*_DMA2_Channel1 */
N
N#ifdef _DMA2_Channel2
S  #define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#endif /*_DMA2_Channel2 */
N
N#ifdef _DMA2_Channel3
S  #define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#endif /*_DMA2_Channel3 */
N
N#ifdef _DMA2_Channel4
S  #define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#endif /*_DMA2_Channel4 */
N
N#ifdef _DMA2_Channel5
S  #define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#endif /*_DMA2_Channel5 */
N
N#ifdef _RCC
N  #define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#endif /*_RCC */
N
N#ifdef _CRC
S  #define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#endif /*_CRC */
N
N#ifdef _FLASH
N  #define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N  #define OB                  ((OB_TypeDef *) OB_BASE) 
N#endif /*_FLASH */
N
N#ifdef _FSMC
S  #define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
S  #define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
S  #define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
S  #define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
S  #define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#endif /*_FSMC */
N
N#ifdef _DBGMCU
S  #define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#endif /*_DBGMCU */
N
N#ifdef _SysTick
N  #define SysTick             ((SysTick_TypeDef *) SysTick_BASE)
N#endif /*_SysTick */
N
N#ifdef _NVIC
N  #define NVIC                ((NVIC_TypeDef *) NVIC_BASE)
N  #define SCB                 ((SCB_TypeDef *) SCB_BASE)  
N#endif /*_NVIC */
N
N/*------------------------ Debug Mode ----------------------------------------*/
N#else   /* DEBUG */
S#ifdef _TIM2
S  EXT TIM_TypeDef             *TIM2;
S#endif /*_TIM2 */
S
S#ifdef _TIM3
S  EXT TIM_TypeDef             *TIM3;
S#endif /*_TIM3 */
S
S#ifdef _TIM4
S  EXT TIM_TypeDef             *TIM4;
S#endif /*_TIM4 */
S
S#ifdef _TIM5
S  EXT TIM_TypeDef             *TIM5;
S#endif /*_TIM5 */
S
S#ifdef _TIM6
S  EXT TIM_TypeDef             *TIM6;
S#endif /*_TIM6 */
S
S#ifdef _TIM7
S  EXT TIM_TypeDef             *TIM7;
S#endif /*_TIM7 */
S
S#ifdef _RTC
S  EXT RTC_TypeDef             *RTC;
S#endif /*_RTC */
S
S#ifdef _WWDG
S  EXT WWDG_TypeDef            *WWDG;
S#endif /*_WWDG */
S
S#ifdef _IWDG
S  EXT IWDG_TypeDef            *IWDG;
S#endif /*_IWDG */
S
S#ifdef _SPI2
S  EXT SPI_TypeDef             *SPI2;
S#endif /*_SPI2 */
S
S#ifdef _SPI3
S  EXT SPI_TypeDef             *SPI3;
S#endif /*_SPI3 */
S
S#ifdef _USART2
S  EXT USART_TypeDef           *USART2;
S#endif /*_USART2 */
S
S#ifdef _USART3
S  EXT USART_TypeDef           *USART3;
S#endif /*_USART3 */
S
S#ifdef _UART4
S  EXT USART_TypeDef           *UART4;
S#endif /*_UART4 */
S
S#ifdef _UART5
S  EXT USART_TypeDef           *UART5;
S#endif /*_UART5 */
S
S#ifdef _I2C1
S  EXT I2C_TypeDef             *I2C1;
S#endif /*_I2C1 */
S
S#ifdef _I2C2
S  EXT I2C_TypeDef             *I2C2;
S#endif /*_I2C2 */
S
S#ifdef _CAN
S  EXT CAN_TypeDef             *CAN;
S#endif /*_CAN */
S
S#ifdef _BKP
S  EXT BKP_TypeDef             *BKP;
S#endif /*_BKP */
S
S#ifdef _PWR
S  EXT PWR_TypeDef             *PWR;
S#endif /*_PWR */
S
S#ifdef _DAC
S  EXT DAC_TypeDef             *DAC;
S#endif /*_DAC */
S
S#ifdef _AFIO
S  EXT AFIO_TypeDef            *AFIO;
S#endif /*_AFIO */
S
S#ifdef _EXTI
S  EXT EXTI_TypeDef            *EXTI;
S#endif /*_EXTI */
S
S#ifdef _GPIOA
S  EXT GPIO_TypeDef            *GPIOA;
S#endif /*_GPIOA */
S
S#ifdef _GPIOB
S  EXT GPIO_TypeDef            *GPIOB;
S#endif /*_GPIOB */
S
S#ifdef _GPIOC
S  EXT GPIO_TypeDef            *GPIOC;
S#endif /*_GPIOC */
S
S#ifdef _GPIOD
S  EXT GPIO_TypeDef            *GPIOD;
S#endif /*_GPIOD */
S
S#ifdef _GPIOE
S  EXT GPIO_TypeDef            *GPIOE;
S#endif /*_GPIOE */
S
S#ifdef _GPIOF
S  EXT GPIO_TypeDef            *GPIOF;
S#endif /*_GPIOF */
S
S#ifdef _GPIOG
S  EXT GPIO_TypeDef            *GPIOG;
S#endif /*_GPIOG */
S
S#ifdef _ADC1
S  EXT ADC_TypeDef             *ADC1;
S#endif /*_ADC1 */
S
S#ifdef _ADC2
S  EXT ADC_TypeDef             *ADC2;
S#endif /*_ADC2 */
S
S#ifdef _TIM1
S  EXT TIM_TypeDef             *TIM1;
S#endif /*_TIM1 */
S
S#ifdef _SPI1
S  EXT SPI_TypeDef             *SPI1;
S#endif /*_SPI1 */
S
S#ifdef _TIM8
S  EXT TIM_TypeDef             *TIM8;
S#endif /*_TIM8 */
S
S#ifdef _USART1
S  EXT USART_TypeDef           *USART1;
S#endif /*_USART1 */
S
S#ifdef _ADC3
S  EXT ADC_TypeDef             *ADC3;
S#endif /*_ADC3 */
S
S#ifdef _SDIO
S  EXT SDIO_TypeDef            *SDIO;
S#endif /*_SDIO */
S
S#ifdef _DMA
S  EXT DMA_TypeDef             *DMA1;
S  EXT DMA_TypeDef             *DMA2;
S#endif /*_DMA */
S
S#ifdef _DMA1_Channel1
S  EXT DMA_Channel_TypeDef     *DMA1_Channel1;
S#endif /*_DMA1_Channel1 */
S
S#ifdef _DMA1_Channel2
S  EXT DMA_Channel_TypeDef     *DMA1_Channel2;
S#endif /*_DMA1_Channel2 */
S
S#ifdef _DMA1_Channel3
S  EXT DMA_Channel_TypeDef     *DMA1_Channel3;
S#endif /*_DMA1_Channel3 */
S
S#ifdef _DMA1_Channel4
S  EXT DMA_Channel_TypeDef     *DMA1_Channel4;
S#endif /*_DMA1_Channel4 */
S
S#ifdef _DMA1_Channel5
S  EXT DMA_Channel_TypeDef     *DMA1_Channel5;
S#endif /*_DMA1_Channel5 */
S
S#ifdef _DMA1_Channel6
S  EXT DMA_Channel_TypeDef     *DMA1_Channel6;
S#endif /*_DMA1_Channel6 */
S
S#ifdef _DMA1_Channel7
S  EXT DMA_Channel_TypeDef     *DMA1_Channel7;
S#endif /*_DMA1_Channel7 */
S
S#ifdef _DMA2_Channel1
S  EXT DMA_Channel_TypeDef     *DMA2_Channel1;
S#endif /*_DMA2_Channel1 */
S
S#ifdef _DMA2_Channel2
S  EXT DMA_Channel_TypeDef     *DMA2_Channel2;
S#endif /*_DMA2_Channel2 */
S
S#ifdef _DMA2_Channel3
S  EXT DMA_Channel_TypeDef     *DMA2_Channel3;
S#endif /*_DMA2_Channel3 */
S
S#ifdef _DMA2_Channel4
S  EXT DMA_Channel_TypeDef     *DMA2_Channel4;
S#endif /*_DMA2_Channel4 */
S
S#ifdef _DMA2_Channel5
S  EXT DMA_Channel_TypeDef     *DMA2_Channel5;
S#endif /*_DMA2_Channel5 */
S
S#ifdef _RCC
S  EXT RCC_TypeDef             *RCC;
S#endif /*_RCC */
S
S#ifdef _CRC
S  EXT CRC_TypeDef             *CRC;
S#endif /*_CRC */
S
S#ifdef _FLASH
S  EXT FLASH_TypeDef            *FLASH;
S  EXT OB_TypeDef               *OB;  
S#endif /*_FLASH */
S
S#ifdef _FSMC
S  EXT FSMC_Bank1_TypeDef      *FSMC_Bank1;
S  EXT FSMC_Bank1E_TypeDef     *FSMC_Bank1E;
S  EXT FSMC_Bank2_TypeDef      *FSMC_Bank2;
S  EXT FSMC_Bank3_TypeDef      *FSMC_Bank3;
S  EXT FSMC_Bank4_TypeDef      *FSMC_Bank4;
S#endif /*_FSMC */
S
S#ifdef _DBGMCU
S  EXT DBGMCU_TypeDef          *DBGMCU;
S#endif /*_DBGMCU */
S
S#ifdef _SysTick
S  EXT SysTick_TypeDef         *SysTick;
S#endif /*_SysTick */
S
S#ifdef _NVIC
S  EXT NVIC_TypeDef            *NVIC;
S  EXT SCB_TypeDef             *SCB;
S#endif /*_NVIC */
S
N#endif  /* DEBUG */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_MAP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 25 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_tim.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N
N/* TIM Time Base Init structure definition */
Ntypedef struct
N{
N  u16 TIM_Prescaler;
N  u16 TIM_CounterMode;
N  u16 TIM_Period;
N  u16 TIM_ClockDivision;
N  u8 TIM_RepetitionCounter;
N} TIM_TimeBaseInitTypeDef;
N
N/* TIM Output Compare Init structure definition */
Ntypedef struct
N{
N  u16 TIM_OCMode;
N  u16 TIM_OutputState;
N  u16 TIM_OutputNState;
N  u16 TIM_Pulse;
N  u16 TIM_OCPolarity;
N  u16 TIM_OCNPolarity;
N  u16 TIM_OCIdleState;
N  u16 TIM_OCNIdleState;
N} TIM_OCInitTypeDef;
N
N/* TIM Input Capture Init structure definition */
Ntypedef struct
N{
N  u16 TIM_Channel;
N  u16 TIM_ICPolarity;
N  u16 TIM_ICSelection;
N  u16 TIM_ICPrescaler;
N  u16 TIM_ICFilter;
N} TIM_ICInitTypeDef;
N
N/* BDTR structure definition */
Ntypedef struct
N{
N  u16 TIM_OSSRState;
N  u16 TIM_OSSIState;
N  u16 TIM_LOCKLevel; 
N  u16 TIM_DeadTime;
N  u16 TIM_Break;
N  u16 TIM_BreakPolarity;
N  u16 TIM_AutomaticOutput;
N} TIM_BDTRInitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/                             
N
N#define IS_TIM_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM2_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM4_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM5_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM6_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM7_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM2_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM4_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM5_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM6_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM7_BASE) ||                                    ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N#define IS_TIM_18_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                  ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_18_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                   ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N#define IS_TIM_123458_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM2_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM4_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM5_BASE) || \
N                                      ((*(u32*)&(PERIPH)) == TIM8_BASE))
X#define IS_TIM_123458_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == TIM1_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM2_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM4_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM5_BASE) ||                                       ((*(u32*)&(PERIPH)) == TIM8_BASE))
N
N/* TIM Output Compare and PWM modes -----------------------------------------*/
N#define TIM_OCMode_Timing                  ((u16)0x0000)
N#define TIM_OCMode_Active                  ((u16)0x0010)
N#define TIM_OCMode_Inactive                ((u16)0x0020)
N#define TIM_OCMode_Toggle                  ((u16)0x0030)
N#define TIM_OCMode_PWM1                    ((u16)0x0060)
N#define TIM_OCMode_PWM2                    ((u16)0x0070)
N
N#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                              ((MODE) == TIM_OCMode_Active) || \
N                              ((MODE) == TIM_OCMode_Inactive) || \
N                              ((MODE) == TIM_OCMode_Toggle)|| \
N                              ((MODE) == TIM_OCMode_PWM1) || \
N                              ((MODE) == TIM_OCMode_PWM2))
X#define IS_TIM_OC_MODE(MODE) (((MODE) == TIM_OCMode_Timing) ||                               ((MODE) == TIM_OCMode_Active) ||                               ((MODE) == TIM_OCMode_Inactive) ||                               ((MODE) == TIM_OCMode_Toggle)||                               ((MODE) == TIM_OCMode_PWM1) ||                               ((MODE) == TIM_OCMode_PWM2))
N
N#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) || \
N                          ((MODE) == TIM_OCMode_Active) || \
N                          ((MODE) == TIM_OCMode_Inactive) || \
N                          ((MODE) == TIM_OCMode_Toggle)|| \
N                          ((MODE) == TIM_OCMode_PWM1) || \
N                          ((MODE) == TIM_OCMode_PWM2) ||	\
N                          ((MODE) == TIM_ForcedAction_Active) || \
N                          ((MODE) == TIM_ForcedAction_InActive))
X#define IS_TIM_OCM(MODE) (((MODE) == TIM_OCMode_Timing) ||                           ((MODE) == TIM_OCMode_Active) ||                           ((MODE) == TIM_OCMode_Inactive) ||                           ((MODE) == TIM_OCMode_Toggle)||                           ((MODE) == TIM_OCMode_PWM1) ||                           ((MODE) == TIM_OCMode_PWM2) ||	                          ((MODE) == TIM_ForcedAction_Active) ||                           ((MODE) == TIM_ForcedAction_InActive))
N/* TIM One Pulse Mode -------------------------------------------------------*/
N#define TIM_OPMode_Single                  ((u16)0x0008)
N#define TIM_OPMode_Repetitive              ((u16)0x0000)
N
N#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) || \
N                               ((MODE) == TIM_OPMode_Repetitive))
X#define IS_TIM_OPM_MODE(MODE) (((MODE) == TIM_OPMode_Single) ||                                ((MODE) == TIM_OPMode_Repetitive))
N
N/* TIM Channel -------------------------------------------------------------*/
N#define TIM_Channel_1                      ((u16)0x0000)
N#define TIM_Channel_2                      ((u16)0x0004)
N#define TIM_Channel_3                      ((u16)0x0008)
N#define TIM_Channel_4                      ((u16)0x000C)
N
N#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                 ((CHANNEL) == TIM_Channel_2) || \
N                                 ((CHANNEL) == TIM_Channel_3) || \
N                                 ((CHANNEL) == TIM_Channel_4))
X#define IS_TIM_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                  ((CHANNEL) == TIM_Channel_2) ||                                  ((CHANNEL) == TIM_Channel_3) ||                                  ((CHANNEL) == TIM_Channel_4))
N
N#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                      ((CHANNEL) == TIM_Channel_2))
X#define IS_TIM_PWMI_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                       ((CHANNEL) == TIM_Channel_2))
N
N#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) || \
N                                               ((CHANNEL) == TIM_Channel_2) || \
N                                               ((CHANNEL) == TIM_Channel_3))
X#define IS_TIM_COMPLEMENTARY_CHANNEL(CHANNEL) (((CHANNEL) == TIM_Channel_1) ||                                                ((CHANNEL) == TIM_Channel_2) ||                                                ((CHANNEL) == TIM_Channel_3))
N/* TIM Clock Division CKD --------------------------------------------------*/
N#define TIM_CKD_DIV1                       ((u16)0x0000)
N#define TIM_CKD_DIV2                       ((u16)0x0100)
N#define TIM_CKD_DIV4                       ((u16)0x0200)
N
N#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) || \
N                             ((DIV) == TIM_CKD_DIV2) || \
N                             ((DIV) == TIM_CKD_DIV4))
X#define IS_TIM_CKD_DIV(DIV) (((DIV) == TIM_CKD_DIV1) ||                              ((DIV) == TIM_CKD_DIV2) ||                              ((DIV) == TIM_CKD_DIV4))
N
N/* TIM Counter Mode --------------------------------------------------------*/
N#define TIM_CounterMode_Up                 ((u16)0x0000)
N#define TIM_CounterMode_Down               ((u16)0x0010)
N#define TIM_CounterMode_CenterAligned1     ((u16)0x0020)
N#define TIM_CounterMode_CenterAligned2     ((u16)0x0040)
N#define TIM_CounterMode_CenterAligned3     ((u16)0x0060)
N
N#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||  \
N                                   ((MODE) == TIM_CounterMode_Down) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned1) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned2) || \
N                                   ((MODE) == TIM_CounterMode_CenterAligned3))
X#define IS_TIM_COUNTER_MODE(MODE) (((MODE) == TIM_CounterMode_Up) ||                                     ((MODE) == TIM_CounterMode_Down) ||                                    ((MODE) == TIM_CounterMode_CenterAligned1) ||                                    ((MODE) == TIM_CounterMode_CenterAligned2) ||                                    ((MODE) == TIM_CounterMode_CenterAligned3))
N
N/* TIM Output Compare Polarity ---------------------------------------------*/
N#define TIM_OCPolarity_High                ((u16)0x0000)
N#define TIM_OCPolarity_Low                 ((u16)0x0002)
N
N#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) || \
N                                      ((POLARITY) == TIM_OCPolarity_Low))
X#define IS_TIM_OC_POLARITY(POLARITY) (((POLARITY) == TIM_OCPolarity_High) ||                                       ((POLARITY) == TIM_OCPolarity_Low))
N
N/* TIM Output Compare N Polarity -------------------------------------------*/
N#define TIM_OCNPolarity_High               ((u16)0x0000)
N#define TIM_OCNPolarity_Low                ((u16)0x0008)
N
N#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) || \
N                                       ((POLARITY) == TIM_OCNPolarity_Low))
X#define IS_TIM_OCN_POLARITY(POLARITY) (((POLARITY) == TIM_OCNPolarity_High) ||                                        ((POLARITY) == TIM_OCNPolarity_Low))
N
N/* TIM Output Compare states -----------------------------------------------*/
N#define TIM_OutputState_Disable            ((u16)0x0000)
N#define TIM_OutputState_Enable             ((u16)0x0001)
N
N#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) || \
N                                    ((STATE) == TIM_OutputState_Enable))
X#define IS_TIM_OUTPUT_STATE(STATE) (((STATE) == TIM_OutputState_Disable) ||                                     ((STATE) == TIM_OutputState_Enable))
N
N/* TIM Output Compare N States ---------------------------------------------*/
N#define TIM_OutputNState_Disable           ((u16)0x0000)
N#define TIM_OutputNState_Enable            ((u16)0x0004)
N
N#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) || \
N                                     ((STATE) == TIM_OutputNState_Enable))
X#define IS_TIM_OUTPUTN_STATE(STATE) (((STATE) == TIM_OutputNState_Disable) ||                                      ((STATE) == TIM_OutputNState_Enable))
N
N/* TIM Capture Compare States -----------------------------------------------*/
N#define TIM_CCx_Enable                      ((u16)0x0001)
N#define TIM_CCx_Disable                     ((u16)0x0000)
N
N#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) || \
N                         ((CCX) == TIM_CCx_Disable))
X#define IS_TIM_CCX(CCX) (((CCX) == TIM_CCx_Enable) ||                          ((CCX) == TIM_CCx_Disable))
N
N/* TIM Capture Compare N States --------------------------------------------*/
N#define TIM_CCxN_Enable                     ((u16)0x0004)
N#define TIM_CCxN_Disable                    ((u16)0x0000)                                     
N
N#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) || \
N                           ((CCXN) == TIM_CCxN_Disable))
X#define IS_TIM_CCXN(CCXN) (((CCXN) == TIM_CCxN_Enable) ||                            ((CCXN) == TIM_CCxN_Disable))
N
N/* Break Input enable/disable -----------------------------------------------*/
N#define TIM_Break_Enable                   ((u16)0x1000)
N#define TIM_Break_Disable                  ((u16)0x0000)
N
N#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) || \
N                                   ((STATE) == TIM_Break_Disable))
X#define IS_TIM_BREAK_STATE(STATE) (((STATE) == TIM_Break_Enable) ||                                    ((STATE) == TIM_Break_Disable))
N
N/* Break Polarity -----------------------------------------------------------*/
N#define TIM_BreakPolarity_Low              ((u16)0x0000)
N#define TIM_BreakPolarity_High             ((u16)0x2000)
N
N#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) || \
N                                         ((POLARITY) == TIM_BreakPolarity_High))
X#define IS_TIM_BREAK_POLARITY(POLARITY) (((POLARITY) == TIM_BreakPolarity_Low) ||                                          ((POLARITY) == TIM_BreakPolarity_High))
N
N/* TIM AOE Bit Set/Reset ---------------------------------------------------*/
N#define TIM_AutomaticOutput_Enable         ((u16)0x4000)
N#define TIM_AutomaticOutput_Disable        ((u16)0x0000)
N
N#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) || \
N                                              ((STATE) == TIM_AutomaticOutput_Disable))
X#define IS_TIM_AUTOMATIC_OUTPUT_STATE(STATE) (((STATE) == TIM_AutomaticOutput_Enable) ||                                               ((STATE) == TIM_AutomaticOutput_Disable))
N/* Lock levels --------------------------------------------------------------*/
N#define TIM_LOCKLevel_OFF                  ((u16)0x0000)
N#define TIM_LOCKLevel_1                    ((u16)0x0100)
N#define TIM_LOCKLevel_2                    ((u16)0x0200)
N#define TIM_LOCKLevel_3                    ((u16)0x0300)
N
N#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) || \
N                                  ((LEVEL) == TIM_LOCKLevel_1) || \
N                                  ((LEVEL) == TIM_LOCKLevel_2) || \
N                                  ((LEVEL) == TIM_LOCKLevel_3))
X#define IS_TIM_LOCK_LEVEL(LEVEL) (((LEVEL) == TIM_LOCKLevel_OFF) ||                                   ((LEVEL) == TIM_LOCKLevel_1) ||                                   ((LEVEL) == TIM_LOCKLevel_2) ||                                   ((LEVEL) == TIM_LOCKLevel_3))
N
N/* OSSI: Off-State Selection for Idle mode states ---------------------------*/
N#define TIM_OSSIState_Enable               ((u16)0x0400)
N#define TIM_OSSIState_Disable              ((u16)0x0000)
N
N#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) || \
N                                  ((STATE) == TIM_OSSIState_Disable))
X#define IS_TIM_OSSI_STATE(STATE) (((STATE) == TIM_OSSIState_Enable) ||                                   ((STATE) == TIM_OSSIState_Disable))
N
N/* OSSR: Off-State Selection for Run mode states ----------------------------*/
N#define TIM_OSSRState_Enable               ((u16)0x0800)
N#define TIM_OSSRState_Disable              ((u16)0x0000)
N
N#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) || \
N                                  ((STATE) == TIM_OSSRState_Disable))
X#define IS_TIM_OSSR_STATE(STATE) (((STATE) == TIM_OSSRState_Enable) ||                                   ((STATE) == TIM_OSSRState_Disable))
N
N/* TIM Output Compare Idle State -------------------------------------------*/
N#define TIM_OCIdleState_Set                ((u16)0x0100)
N#define TIM_OCIdleState_Reset              ((u16)0x0000)
N
N#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) || \
N                                    ((STATE) == TIM_OCIdleState_Reset))
X#define IS_TIM_OCIDLE_STATE(STATE) (((STATE) == TIM_OCIdleState_Set) ||                                     ((STATE) == TIM_OCIdleState_Reset))
N
N/* TIM Output Compare N Idle State -----------------------------------------*/
N#define TIM_OCNIdleState_Set               ((u16)0x0200)
N#define TIM_OCNIdleState_Reset             ((u16)0x0000)
N
N#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) || \
N                                     ((STATE) == TIM_OCNIdleState_Reset))
X#define IS_TIM_OCNIDLE_STATE(STATE) (((STATE) == TIM_OCNIdleState_Set) ||                                      ((STATE) == TIM_OCNIdleState_Reset))
N
N/* TIM Input Capture Polarity ----------------------------------------------*/
N#define  TIM_ICPolarity_Rising             ((u16)0x0000)
N#define  TIM_ICPolarity_Falling            ((u16)0x0002)
N
N#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) || \
N                                      ((POLARITY) == TIM_ICPolarity_Falling))
X#define IS_TIM_IC_POLARITY(POLARITY) (((POLARITY) == TIM_ICPolarity_Rising) ||                                       ((POLARITY) == TIM_ICPolarity_Falling))
N
N/* TIM Input Capture Selection ---------------------------------------------*/
N#define TIM_ICSelection_DirectTI           ((u16)0x0001)
N#define TIM_ICSelection_IndirectTI         ((u16)0x0002)
N#define TIM_ICSelection_TRC                ((u16)0x0003)
N
N#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_IndirectTI) || \
N                                        ((SELECTION) == TIM_ICSelection_TRC))
X#define IS_TIM_IC_SELECTION(SELECTION) (((SELECTION) == TIM_ICSelection_DirectTI) ||                                         ((SELECTION) == TIM_ICSelection_IndirectTI) ||                                         ((SELECTION) == TIM_ICSelection_TRC))
N
N/* TIM Input Capture Prescaler ---------------------------------------------*/
N#define TIM_ICPSC_DIV1                     ((u16)0x0000)
N#define TIM_ICPSC_DIV2                     ((u16)0x0004)
N#define TIM_ICPSC_DIV4                     ((u16)0x0008)
N#define TIM_ICPSC_DIV8                     ((u16)0x000C)
N
N#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV2) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV4) || \
N                                        ((PRESCALER) == TIM_ICPSC_DIV8))                                          
X#define IS_TIM_IC_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ICPSC_DIV1) ||                                         ((PRESCALER) == TIM_ICPSC_DIV2) ||                                         ((PRESCALER) == TIM_ICPSC_DIV4) ||                                         ((PRESCALER) == TIM_ICPSC_DIV8))                                          
N
N/* TIM interrupt sources ---------------------------------------------------*/
N#define TIM_IT_Update                      ((u16)0x0001)
N#define TIM_IT_CC1                         ((u16)0x0002)
N#define TIM_IT_CC2                         ((u16)0x0004)
N#define TIM_IT_CC3                         ((u16)0x0008)
N#define TIM_IT_CC4                         ((u16)0x0010)
N#define TIM_IT_COM                         ((u16)0x0020)
N#define TIM_IT_Trigger                     ((u16)0x0040)
N#define TIM_IT_Break                       ((u16)0x0080)
N
N#define IS_TIM_IT(IT) ((((IT) & (u16)0xFF00) == 0x0000) && ((IT) != 0x0000))
N
N#define IS_TIM_PERIPH_IT(PERIPH, TIM_IT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFFA0) == 0x0000) && ((TIM_IT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFF00) == 0x0000) && ((TIM_IT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((TIM_IT) & (u16)0xFFFE) == 0x0000) && ((TIM_IT) != 0x0000)))
X#define IS_TIM_PERIPH_IT(PERIPH, TIM_IT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((TIM_IT) & (u16)0xFFA0) == 0x0000) && ((TIM_IT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((TIM_IT) & (u16)0xFF00) == 0x0000) && ((TIM_IT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((TIM_IT) & (u16)0xFFFE) == 0x0000) && ((TIM_IT) != 0x0000)))
N
N#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) || \
N                           ((IT) == TIM_IT_CC1) || \
N                           ((IT) == TIM_IT_CC2) || \
N                           ((IT) == TIM_IT_CC3) || \
N                           ((IT) == TIM_IT_CC4) || \
N                           ((IT) == TIM_IT_COM) || \
N                           ((IT) == TIM_IT_Trigger) || \
N                           ((IT) == TIM_IT_Break))
X#define IS_TIM_GET_IT(IT) (((IT) == TIM_IT_Update) ||                            ((IT) == TIM_IT_CC1) ||                            ((IT) == TIM_IT_CC2) ||                            ((IT) == TIM_IT_CC3) ||                            ((IT) == TIM_IT_CC4) ||                            ((IT) == TIM_IT_COM) ||                            ((IT) == TIM_IT_Trigger) ||                            ((IT) == TIM_IT_Break))
N
N/* TIM DMA Base address ----------------------------------------------------*/
N#define TIM_DMABase_CR1                    ((u16)0x0000)
N#define TIM_DMABase_CR2                    ((u16)0x0001)
N#define TIM_DMABase_SMCR                   ((u16)0x0002)
N#define TIM_DMABase_DIER                   ((u16)0x0003)
N#define TIM_DMABase_SR                     ((u16)0x0004)
N#define TIM_DMABase_EGR                    ((u16)0x0005)
N#define TIM_DMABase_CCMR1                  ((u16)0x0006)
N#define TIM_DMABase_CCMR2                  ((u16)0x0007)
N#define TIM_DMABase_CCER                   ((u16)0x0008)
N#define TIM_DMABase_CNT                    ((u16)0x0009)
N#define TIM_DMABase_PSC                    ((u16)0x000A)
N#define TIM_DMABase_ARR                    ((u16)0x000B)
N#define TIM_DMABase_RCR                    ((u16)0x000C)
N#define TIM_DMABase_CCR1                   ((u16)0x000D)
N#define TIM_DMABase_CCR2                   ((u16)0x000E)
N#define TIM_DMABase_CCR3                   ((u16)0x000F)
N#define TIM_DMABase_CCR4                   ((u16)0x0010)
N#define TIM_DMABase_BDTR                   ((u16)0x0011)
N#define TIM_DMABase_DCR                    ((u16)0x0012)
N
N#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) || \
N                               ((BASE) == TIM_DMABase_CR2) || \
N                               ((BASE) == TIM_DMABase_SMCR) || \
N                               ((BASE) == TIM_DMABase_DIER) || \
N                               ((BASE) == TIM_DMABase_SR) || \
N                               ((BASE) == TIM_DMABase_EGR) || \
N                               ((BASE) == TIM_DMABase_CCMR1) || \
N                               ((BASE) == TIM_DMABase_CCMR2) || \
N                               ((BASE) == TIM_DMABase_CCER) || \
N                               ((BASE) == TIM_DMABase_CNT) || \
N                               ((BASE) == TIM_DMABase_PSC) || \
N                               ((BASE) == TIM_DMABase_ARR) || \
N                               ((BASE) == TIM_DMABase_RCR) || \
N                               ((BASE) == TIM_DMABase_CCR1) || \
N                               ((BASE) == TIM_DMABase_CCR2) || \
N                               ((BASE) == TIM_DMABase_CCR3) || \
N                               ((BASE) == TIM_DMABase_CCR4) || \
N                               ((BASE) == TIM_DMABase_BDTR) || \
N                               ((BASE) == TIM_DMABase_DCR))
X#define IS_TIM_DMA_BASE(BASE) (((BASE) == TIM_DMABase_CR1) ||                                ((BASE) == TIM_DMABase_CR2) ||                                ((BASE) == TIM_DMABase_SMCR) ||                                ((BASE) == TIM_DMABase_DIER) ||                                ((BASE) == TIM_DMABase_SR) ||                                ((BASE) == TIM_DMABase_EGR) ||                                ((BASE) == TIM_DMABase_CCMR1) ||                                ((BASE) == TIM_DMABase_CCMR2) ||                                ((BASE) == TIM_DMABase_CCER) ||                                ((BASE) == TIM_DMABase_CNT) ||                                ((BASE) == TIM_DMABase_PSC) ||                                ((BASE) == TIM_DMABase_ARR) ||                                ((BASE) == TIM_DMABase_RCR) ||                                ((BASE) == TIM_DMABase_CCR1) ||                                ((BASE) == TIM_DMABase_CCR2) ||                                ((BASE) == TIM_DMABase_CCR3) ||                                ((BASE) == TIM_DMABase_CCR4) ||                                ((BASE) == TIM_DMABase_BDTR) ||                                ((BASE) == TIM_DMABase_DCR))
N
N/* TIM DMA Burst Length ----------------------------------------------------*/
N#define TIM_DMABurstLength_1Byte           ((u16)0x0000)
N#define TIM_DMABurstLength_2Bytes          ((u16)0x0100)
N#define TIM_DMABurstLength_3Bytes          ((u16)0x0200)
N#define TIM_DMABurstLength_4Bytes          ((u16)0x0300)
N#define TIM_DMABurstLength_5Bytes          ((u16)0x0400)
N#define TIM_DMABurstLength_6Bytes          ((u16)0x0500)
N#define TIM_DMABurstLength_7Bytes          ((u16)0x0600)
N#define TIM_DMABurstLength_8Bytes          ((u16)0x0700)
N#define TIM_DMABurstLength_9Bytes          ((u16)0x0800)
N#define TIM_DMABurstLength_10Bytes         ((u16)0x0900)
N#define TIM_DMABurstLength_11Bytes         ((u16)0x0A00)
N#define TIM_DMABurstLength_12Bytes         ((u16)0x0B00)
N#define TIM_DMABurstLength_13Bytes         ((u16)0x0C00)
N#define TIM_DMABurstLength_14Bytes         ((u16)0x0D00)
N#define TIM_DMABurstLength_15Bytes         ((u16)0x0E00)
N#define TIM_DMABurstLength_16Bytes         ((u16)0x0F00)
N#define TIM_DMABurstLength_17Bytes         ((u16)0x1000)
N#define TIM_DMABurstLength_18Bytes         ((u16)0x1100)
N
N#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Byte) || \
N                                   ((LENGTH) == TIM_DMABurstLength_2Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_3Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_4Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_5Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_6Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_7Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_8Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_9Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_10Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_11Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_12Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_13Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_14Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_15Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_16Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_17Bytes) || \
N                                   ((LENGTH) == TIM_DMABurstLength_18Bytes))
X#define IS_TIM_DMA_LENGTH(LENGTH) (((LENGTH) == TIM_DMABurstLength_1Byte) ||                                    ((LENGTH) == TIM_DMABurstLength_2Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_3Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_4Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_5Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_6Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_7Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_8Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_9Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_10Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_11Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_12Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_13Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_14Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_15Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_16Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_17Bytes) ||                                    ((LENGTH) == TIM_DMABurstLength_18Bytes))
N
N/* TIM DMA sources ---------------------------------------------------------*/
N#define TIM_DMA_Update                     ((u16)0x0100)
N#define TIM_DMA_CC1                        ((u16)0x0200)
N#define TIM_DMA_CC2                        ((u16)0x0400)
N#define TIM_DMA_CC3                        ((u16)0x0800)
N#define TIM_DMA_CC4                        ((u16)0x1000)
N#define TIM_DMA_COM                        ((u16)0x2000)
N#define TIM_DMA_Trigger                    ((u16)0x4000)
N
N#define IS_TIM_DMA_SOURCE(SOURCE) ((((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))
N
N#define IS_TIM_PERIPH_DMA(PERIPH, SOURCE) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((SOURCE) & (u16)0xA0FF) == 0x0000) && ((SOURCE) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((SOURCE) & (u16)0xFEFF) == 0x0000) && ((SOURCE) != 0x0000)))
X#define IS_TIM_PERIPH_DMA(PERIPH, SOURCE) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((SOURCE) & (u16)0xA0FF) == 0x0000) && ((SOURCE) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((SOURCE) & (u16)0x80FF) == 0x0000) && ((SOURCE) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((SOURCE) & (u16)0xFEFF) == 0x0000) && ((SOURCE) != 0x0000)))
N
N/* TIM External Trigger Prescaler ------------------------------------------*/
N#define TIM_ExtTRGPSC_OFF                  ((u16)0x0000)
N#define TIM_ExtTRGPSC_DIV2                 ((u16)0x1000)
N#define TIM_ExtTRGPSC_DIV4                 ((u16)0x2000)
N#define TIM_ExtTRGPSC_DIV8                 ((u16)0x3000)
N
N#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV2) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV4) || \
N                                         ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
X#define IS_TIM_EXT_PRESCALER(PRESCALER) (((PRESCALER) == TIM_ExtTRGPSC_OFF) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV2) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV4) ||                                          ((PRESCALER) == TIM_ExtTRGPSC_DIV8))
N
N/* TIM Internal Trigger Selection ------------------------------------------*/
N#define TIM_TS_ITR0                        ((u16)0x0000)
N#define TIM_TS_ITR1                        ((u16)0x0010)
N#define TIM_TS_ITR2                        ((u16)0x0020)
N#define TIM_TS_ITR3                        ((u16)0x0030)
N#define TIM_TS_TI1F_ED                     ((u16)0x0040)
N#define TIM_TS_TI1FP1                      ((u16)0x0050)
N#define TIM_TS_TI2FP2                      ((u16)0x0060)
N#define TIM_TS_ETRF                        ((u16)0x0070)
N
N#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                             ((SELECTION) == TIM_TS_ITR1) || \
N                                             ((SELECTION) == TIM_TS_ITR2) || \
N                                             ((SELECTION) == TIM_TS_ITR3) || \
N                                             ((SELECTION) == TIM_TS_TI1F_ED) || \
N                                             ((SELECTION) == TIM_TS_TI1FP1) || \
N                                             ((SELECTION) == TIM_TS_TI2FP2) || \
N                                             ((SELECTION) == TIM_TS_ETRF))
X#define IS_TIM_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                              ((SELECTION) == TIM_TS_ITR1) ||                                              ((SELECTION) == TIM_TS_ITR2) ||                                              ((SELECTION) == TIM_TS_ITR3) ||                                              ((SELECTION) == TIM_TS_TI1F_ED) ||                                              ((SELECTION) == TIM_TS_TI1FP1) ||                                              ((SELECTION) == TIM_TS_TI2FP2) ||                                              ((SELECTION) == TIM_TS_ETRF))
N
N#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) || \
N                                                      ((SELECTION) == TIM_TS_ITR1) || \
N                                                      ((SELECTION) == TIM_TS_ITR2) || \
N                                                      ((SELECTION) == TIM_TS_ITR3))
X#define IS_TIM_INTERNAL_TRIGGER_SELECTION(SELECTION) (((SELECTION) == TIM_TS_ITR0) ||                                                       ((SELECTION) == TIM_TS_ITR1) ||                                                       ((SELECTION) == TIM_TS_ITR2) ||                                                       ((SELECTION) == TIM_TS_ITR3))
N
N/* TIM TIx External Clock Source -------------------------------------------*/
N#define TIM_TIxExternalCLK1Source_TI1      ((u16)0x0050)
N#define TIM_TIxExternalCLK1Source_TI2      ((u16)0x0060)
N#define TIM_TIxExternalCLK1Source_TI1ED    ((u16)0x0040)
N
N#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) || \
N                                      ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
X#define IS_TIM_TIXCLK_SOURCE(SOURCE) (((SOURCE) == TIM_TIxExternalCLK1Source_TI1) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI2) ||                                       ((SOURCE) == TIM_TIxExternalCLK1Source_TI1ED))
N
N/* TIM External Trigger Polarity -------------------------------------------*/
N#define TIM_ExtTRGPolarity_Inverted        ((u16)0x8000)
N#define TIM_ExtTRGPolarity_NonInverted     ((u16)0x0000)
N
N#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) || \
N                                       ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
X#define IS_TIM_EXT_POLARITY(POLARITY) (((POLARITY) == TIM_ExtTRGPolarity_Inverted) ||                                        ((POLARITY) == TIM_ExtTRGPolarity_NonInverted))
N
N/* TIM Prescaler Reload Mode -----------------------------------------------*/
N#define TIM_PSCReloadMode_Update           ((u16)0x0000)
N#define TIM_PSCReloadMode_Immediate        ((u16)0x0001)
N
N#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) || \
N                                         ((RELOAD) == TIM_PSCReloadMode_Immediate))
X#define IS_TIM_PRESCALER_RELOAD(RELOAD) (((RELOAD) == TIM_PSCReloadMode_Update) ||                                          ((RELOAD) == TIM_PSCReloadMode_Immediate))
N
N/* TIM Forced Action -------------------------------------------------------*/
N#define TIM_ForcedAction_Active            ((u16)0x0050)
N#define TIM_ForcedAction_InActive          ((u16)0x0040)
N
N#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) || \
N                                      ((ACTION) == TIM_ForcedAction_InActive))
X#define IS_TIM_FORCED_ACTION(ACTION) (((ACTION) == TIM_ForcedAction_Active) ||                                       ((ACTION) == TIM_ForcedAction_InActive))
N
N/* TIM Encoder Mode --------------------------------------------------------*/ 
N#define TIM_EncoderMode_TI1                ((u16)0x0001)
N#define TIM_EncoderMode_TI2                ((u16)0x0002)
N#define TIM_EncoderMode_TI12               ((u16)0x0003)
N
N#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) || \
N                                   ((MODE) == TIM_EncoderMode_TI2) || \
N                                   ((MODE) == TIM_EncoderMode_TI12))
X#define IS_TIM_ENCODER_MODE(MODE) (((MODE) == TIM_EncoderMode_TI1) ||                                    ((MODE) == TIM_EncoderMode_TI2) ||                                    ((MODE) == TIM_EncoderMode_TI12))
N
N/* TIM Event Source --------------------------------------------------------*/
N#define TIM_EventSource_Update             ((u16)0x0001)
N#define TIM_EventSource_CC1                ((u16)0x0002)
N#define TIM_EventSource_CC2                ((u16)0x0004)
N#define TIM_EventSource_CC3                ((u16)0x0008)
N#define TIM_EventSource_CC4                ((u16)0x0010)
N#define TIM_EventSource_COM                ((u16)0x0020)
N#define TIM_EventSource_Trigger            ((u16)0x0040)
N#define TIM_EventSource_Break              ((u16)0x0080)
N
N#define IS_TIM_EVENT_SOURCE(SOURCE) ((((SOURCE) & (u16)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))
N
N#define IS_TIM_PERIPH_EVENT(PERIPH, EVENT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((EVENT) & (u16)0xFFA0) == 0x0000) && ((EVENT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((EVENT) & (u16)0xFF00) == 0x0000) && ((EVENT) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((EVENT) & (u16)0xFFFE) == 0x0000) && ((EVENT) != 0x0000)))
X#define IS_TIM_PERIPH_EVENT(PERIPH, EVENT) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((EVENT) & (u16)0xFFA0) == 0x0000) && ((EVENT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((EVENT) & (u16)0xFF00) == 0x0000) && ((EVENT) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((EVENT) & (u16)0xFFFE) == 0x0000) && ((EVENT) != 0x0000)))
N
N/* TIM Update Source --------------------------------------------------------*/
N#define TIM_UpdateSource_Global            ((u16)0x0000)
N#define TIM_UpdateSource_Regular           ((u16)0x0001)
N
N#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) || \
N                                      ((SOURCE) == TIM_UpdateSource_Regular))
X#define IS_TIM_UPDATE_SOURCE(SOURCE) (((SOURCE) == TIM_UpdateSource_Global) ||                                       ((SOURCE) == TIM_UpdateSource_Regular))
N
N/* TIM Ouput Compare Preload State ------------------------------------------*/
N#define TIM_OCPreload_Enable               ((u16)0x0008)
N#define TIM_OCPreload_Disable              ((u16)0x0000)
N
N#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) || \
N                                       ((STATE) == TIM_OCPreload_Disable))
X#define IS_TIM_OCPRELOAD_STATE(STATE) (((STATE) == TIM_OCPreload_Enable) ||                                        ((STATE) == TIM_OCPreload_Disable))
N
N/* TIM Ouput Compare Fast State ---------------------------------------------*/
N#define TIM_OCFast_Enable                  ((u16)0x0004)
N#define TIM_OCFast_Disable                 ((u16)0x0000)
N
N#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) || \
N                                    ((STATE) == TIM_OCFast_Disable))
X#define IS_TIM_OCFAST_STATE(STATE) (((STATE) == TIM_OCFast_Enable) ||                                     ((STATE) == TIM_OCFast_Disable))
N                                     
N/* TIM Ouput Compare Clear State --------------------------------------------*/
N#define TIM_OCClear_Enable                 ((u16)0x0080)
N#define TIM_OCClear_Disable                ((u16)0x0000)
N
N#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) || \
N                                     ((STATE) == TIM_OCClear_Disable))                                     
X#define IS_TIM_OCCLEAR_STATE(STATE) (((STATE) == TIM_OCClear_Enable) ||                                      ((STATE) == TIM_OCClear_Disable))                                     
N
N/* TIM Trigger Output Source ------------------------------------------------*/ 
N#define TIM_TRGOSource_Reset               ((u16)0x0000)
N#define TIM_TRGOSource_Enable              ((u16)0x0010)
N#define TIM_TRGOSource_Update              ((u16)0x0020)
N#define TIM_TRGOSource_OC1                 ((u16)0x0030)
N#define TIM_TRGOSource_OC1Ref              ((u16)0x0040)
N#define TIM_TRGOSource_OC2Ref              ((u16)0x0050)
N#define TIM_TRGOSource_OC3Ref              ((u16)0x0060)
N#define TIM_TRGOSource_OC4Ref              ((u16)0x0070)
N
N#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) || \
N                                    ((SOURCE) == TIM_TRGOSource_Enable) || \
N                                    ((SOURCE) == TIM_TRGOSource_Update) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC1Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC2Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC3Ref) || \
N                                    ((SOURCE) == TIM_TRGOSource_OC4Ref))
X#define IS_TIM_TRGO_SOURCE(SOURCE) (((SOURCE) == TIM_TRGOSource_Reset) ||                                     ((SOURCE) == TIM_TRGOSource_Enable) ||                                     ((SOURCE) == TIM_TRGOSource_Update) ||                                     ((SOURCE) == TIM_TRGOSource_OC1) ||                                     ((SOURCE) == TIM_TRGOSource_OC1Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC2Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC3Ref) ||                                     ((SOURCE) == TIM_TRGOSource_OC4Ref))
N
N#define IS_TIM_PERIPH_TRGO(PERIPH, TRGO)  (((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Reset)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Enable)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_Update)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC1)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC1Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC2Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC3Ref)) ||\
N                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||\
N                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))|| \
N                                           (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) && \
N                                           ((TRGO) == TIM_TRGOSource_OC4Ref)))
X#define IS_TIM_PERIPH_TRGO(PERIPH, TRGO)  (((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Reset)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Enable)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM6_BASE))||(((*(u32*)&(PERIPH)) == TIM7_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_Update)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC1)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC1Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC2Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC3Ref)) ||                                           ((((*(u32*)&(PERIPH)) == TIM2_BASE)||(((*(u32*)&(PERIPH)) == TIM1_BASE))||                                           (((*(u32*)&(PERIPH)) == TIM3_BASE))||(((*(u32*)&(PERIPH)) == TIM4_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM5_BASE))||(((*(u32*)&(PERIPH)) == TIM8_BASE))) &&                                            ((TRGO) == TIM_TRGOSource_OC4Ref)))
N
N/* TIM Slave Mode ----------------------------------------------------------*/
N#define TIM_SlaveMode_Reset                ((u16)0x0004)
N#define TIM_SlaveMode_Gated                ((u16)0x0005)
N#define TIM_SlaveMode_Trigger              ((u16)0x0006)
N#define TIM_SlaveMode_External1            ((u16)0x0007)
N
N#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) || \
N                                 ((MODE) == TIM_SlaveMode_Gated) || \
N                                 ((MODE) == TIM_SlaveMode_Trigger) || \
N                                 ((MODE) == TIM_SlaveMode_External1))
X#define IS_TIM_SLAVE_MODE(MODE) (((MODE) == TIM_SlaveMode_Reset) ||                                  ((MODE) == TIM_SlaveMode_Gated) ||                                  ((MODE) == TIM_SlaveMode_Trigger) ||                                  ((MODE) == TIM_SlaveMode_External1))
N
N/* TIM Master Slave Mode ---------------------------------------------------*/
N#define TIM_MasterSlaveMode_Enable         ((u16)0x0080)
N#define TIM_MasterSlaveMode_Disable        ((u16)0x0000)
N
N#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) || \
N                                 ((STATE) == TIM_MasterSlaveMode_Disable))
X#define IS_TIM_MSM_STATE(STATE) (((STATE) == TIM_MasterSlaveMode_Enable) ||                                  ((STATE) == TIM_MasterSlaveMode_Disable))
N
N/* TIM Flags ---------------------------------------------------------------*/
N#define TIM_FLAG_Update                    ((u16)0x0001)
N#define TIM_FLAG_CC1                       ((u16)0x0002)
N#define TIM_FLAG_CC2                       ((u16)0x0004)
N#define TIM_FLAG_CC3                       ((u16)0x0008)
N#define TIM_FLAG_CC4                       ((u16)0x0010)
N#define TIM_FLAG_COM                       ((u16)0x0020)
N#define TIM_FLAG_Trigger                   ((u16)0x0040)
N#define TIM_FLAG_Break                     ((u16)0x0080)
N#define TIM_FLAG_CC1OF                     ((u16)0x0200)
N#define TIM_FLAG_CC2OF                     ((u16)0x0400)
N#define TIM_FLAG_CC3OF                     ((u16)0x0800)
N#define TIM_FLAG_CC4OF                     ((u16)0x1000)
N
N#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) || \
N                               ((FLAG) == TIM_FLAG_CC1) || \
N                               ((FLAG) == TIM_FLAG_CC2) || \
N                               ((FLAG) == TIM_FLAG_CC3) || \
N                               ((FLAG) == TIM_FLAG_CC4) || \
N                               ((FLAG) == TIM_FLAG_COM) || \
N                               ((FLAG) == TIM_FLAG_Trigger) || \
N                               ((FLAG) == TIM_FLAG_Break) || \
N                               ((FLAG) == TIM_FLAG_CC1OF) || \
N                               ((FLAG) == TIM_FLAG_CC2OF) || \
N                               ((FLAG) == TIM_FLAG_CC3OF) || \
N                               ((FLAG) == TIM_FLAG_CC4OF))
X#define IS_TIM_GET_FLAG(FLAG) (((FLAG) == TIM_FLAG_Update) ||                                ((FLAG) == TIM_FLAG_CC1) ||                                ((FLAG) == TIM_FLAG_CC2) ||                                ((FLAG) == TIM_FLAG_CC3) ||                                ((FLAG) == TIM_FLAG_CC4) ||                                ((FLAG) == TIM_FLAG_COM) ||                                ((FLAG) == TIM_FLAG_Trigger) ||                                ((FLAG) == TIM_FLAG_Break) ||                                ((FLAG) == TIM_FLAG_CC1OF) ||                                ((FLAG) == TIM_FLAG_CC2OF) ||                                ((FLAG) == TIM_FLAG_CC3OF) ||                                ((FLAG) == TIM_FLAG_CC4OF))
N
N#define IS_TIM_CLEAR_FLAG(PERIPH, TIM_FLAG) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||\
N                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xE1A0) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||\
N                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&& \
N                                            (((TIM_FLAG) & (u16)0xFFFE) == 0x0000) && ((TIM_FLAG) != 0x0000)))
X#define IS_TIM_CLEAR_FLAG(PERIPH, TIM_FLAG) ((((((*(u32*)&(PERIPH)) == TIM2_BASE) || (((*(u32*)&(PERIPH)) == TIM3_BASE))||                                            (((*(u32*)&(PERIPH)) == TIM4_BASE)) || (((*(u32*)&(PERIPH)) == TIM5_BASE))))&&                                             (((TIM_FLAG) & (u16)0xE1A0) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM1_BASE) || (((*(u32*)&(PERIPH)) == TIM8_BASE))))&&                                             (((TIM_FLAG) & (u16)0xE100) == 0x0000) && ((TIM_FLAG) != 0x0000)) ||                                            (((((*(u32*)&(PERIPH)) == TIM6_BASE) || (((*(u32*)&(PERIPH)) == TIM7_BASE))))&&                                             (((TIM_FLAG) & (u16)0xFFFE) == 0x0000) && ((TIM_FLAG) != 0x0000)))
N
N#define IS_TIM_PERIPH_FLAG(PERIPH, TIM_FLAG)  (((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||\
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_CC1) || ((TIM_FLAG) == TIM_FLAG_CC2) ||\
N                                                 ((TIM_FLAG) == TIM_FLAG_CC3) || ((TIM_FLAG) == TIM_FLAG_CC4) || \
N                                                 ((TIM_FLAG) == TIM_FLAG_Trigger))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||\
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE)|| ((*(u32*)&(PERIPH))==TIM8_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM7_BASE) || ((*(u32*)&(PERIPH))==TIM6_BASE)) && \
N                                                 (((TIM_FLAG) == TIM_FLAG_Update))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH)) == TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_COM) || ((TIM_FLAG) == TIM_FLAG_Break))) ||\
N                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) || \
N                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) || \
N                                                 ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&\
N                                                 (((TIM_FLAG) == TIM_FLAG_CC1OF) || ((TIM_FLAG) == TIM_FLAG_CC2OF) ||\
N                                                 ((TIM_FLAG) == TIM_FLAG_CC3OF) || ((TIM_FLAG) == TIM_FLAG_CC4OF))))             
X#define IS_TIM_PERIPH_FLAG(PERIPH, TIM_FLAG)  (((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                 ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_CC1) || ((TIM_FLAG) == TIM_FLAG_CC2) ||                                                 ((TIM_FLAG) == TIM_FLAG_CC3) || ((TIM_FLAG) == TIM_FLAG_CC4) ||                                                  ((TIM_FLAG) == TIM_FLAG_Trigger))) ||                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                  ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                 ((*(u32*)&(PERIPH))==TIM1_BASE)|| ((*(u32*)&(PERIPH))==TIM8_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM7_BASE) || ((*(u32*)&(PERIPH))==TIM6_BASE)) &&                                                  (((TIM_FLAG) == TIM_FLAG_Update))) ||                                                 ((((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH)) == TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_COM) || ((TIM_FLAG) == TIM_FLAG_Break))) ||                                                 ((((*(u32*)&(PERIPH))==TIM2_BASE) || ((*(u32*)&(PERIPH)) == TIM3_BASE) ||                                                  ((*(u32*)&(PERIPH)) == TIM4_BASE) || ((*(u32*)&(PERIPH))==TIM5_BASE) ||                                                  ((*(u32*)&(PERIPH))==TIM1_BASE) || ((*(u32*)&(PERIPH))==TIM8_BASE)) &&                                                 (((TIM_FLAG) == TIM_FLAG_CC1OF) || ((TIM_FLAG) == TIM_FLAG_CC2OF) ||                                                 ((TIM_FLAG) == TIM_FLAG_CC3OF) || ((TIM_FLAG) == TIM_FLAG_CC4OF))))             
N                                                                                            
N/* TIM Input Capture Filer Value ---------------------------------------------*/
N#define IS_TIM_IC_FILTER(ICFILTER) ((ICFILTER) <= 0xF) 
N
N/* TIM External Trigger Filter -----------------------------------------------*/
N#define IS_TIM_EXT_FILTER(EXTFILTER) ((EXTFILTER) <= 0xF)                              
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions --------------------------------------------------------*/
N
Nvoid TIM_DeInit(TIM_TypeDef* TIMx);
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct);
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct);
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct);
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct);
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct);
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState);
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource);
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength);
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState);
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx);
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource);
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
N                                u16 TIM_ICPolarity, u16 ICFilter);                                
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
N                             u16 ExtTRGFilter);
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
N                             u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter);
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
N                   u16 ExtTRGFilter);
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode);
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode);
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource);
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
N                                u16 TIM_IC1Polarity, u16 TIM_IC2Polarity);
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction);
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload);
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast);
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear);
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity);
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity);
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx);
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN);
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode);
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource);
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState);
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode);
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource);
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode);
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode);
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter);
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload);
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1);
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2);
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3);
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4);
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC);
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD);
Nu16 TIM_GetCapture1(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture2(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture3(TIM_TypeDef* TIMx);
Nu16 TIM_GetCapture4(TIM_TypeDef* TIMx);
Nu16 TIM_GetCounter(TIM_TypeDef* TIMx);
Nu16 TIM_GetPrescaler(TIM_TypeDef* TIMx);
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG);
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG);
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT);
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT);
N                                                                                                             
N#endif /*__STM32F10x_TIM_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
N
N
N
N
N
N
N
N
L 20 "..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_tim.c" 2
N#include "stm32f10x_rcc.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_rcc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_rcc.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      RCC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RCC_H
N#define __STM32F10x_RCC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
Ntypedef struct
N{
N  u32 SYSCLK_Frequency;
N  u32 HCLK_Frequency;
N  u32 PCLK1_Frequency;
N  u32 PCLK2_Frequency;
N  u32 ADCCLK_Frequency;
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* HSE configuration */
N#define RCC_HSE_OFF                      ((u32)0x00000000)
N#define RCC_HSE_ON                       ((u32)0x00010000)
N#define RCC_HSE_Bypass                   ((u32)0x00040000)
N
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/* PLL entry clock source */
N#define RCC_PLLSource_HSI_Div2           ((u32)0x00000000)
N#define RCC_PLLSource_HSE_Div1           ((u32)0x00010000)
N#define RCC_PLLSource_HSE_Div2           ((u32)0x00030000)
N
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div1) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div2))
N
N/* PLL multiplication factor */
N#define RCC_PLLMul_2                     ((u32)0x00000000)
N#define RCC_PLLMul_3                     ((u32)0x00040000)
N#define RCC_PLLMul_4                     ((u32)0x00080000)
N#define RCC_PLLMul_5                     ((u32)0x000C0000)
N#define RCC_PLLMul_6                     ((u32)0x00100000)
N#define RCC_PLLMul_7                     ((u32)0x00140000)
N#define RCC_PLLMul_8                     ((u32)0x00180000)
N#define RCC_PLLMul_9                     ((u32)0x001C0000)
N#define RCC_PLLMul_10                    ((u32)0x00200000)
N#define RCC_PLLMul_11                    ((u32)0x00240000)
N#define RCC_PLLMul_12                    ((u32)0x00280000)
N#define RCC_PLLMul_13                    ((u32)0x002C0000)
N#define RCC_PLLMul_14                    ((u32)0x00300000)
N#define RCC_PLLMul_15                    ((u32)0x00340000)
N#define RCC_PLLMul_16                    ((u32)0x00380000)
N
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
N
N/* System clock source */
N#define RCC_SYSCLKSource_HSI             ((u32)0x00000000)
N#define RCC_SYSCLKSource_HSE             ((u32)0x00000001)
N#define RCC_SYSCLKSource_PLLCLK          ((u32)0x00000002)
N
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N
N/* AHB clock source */
N#define RCC_SYSCLK_Div1                  ((u32)0x00000000)
N#define RCC_SYSCLK_Div2                  ((u32)0x00000080)
N#define RCC_SYSCLK_Div4                  ((u32)0x00000090)
N#define RCC_SYSCLK_Div8                  ((u32)0x000000A0)
N#define RCC_SYSCLK_Div16                 ((u32)0x000000B0)
N#define RCC_SYSCLK_Div64                 ((u32)0x000000C0)
N#define RCC_SYSCLK_Div128                ((u32)0x000000D0)
N#define RCC_SYSCLK_Div256                ((u32)0x000000E0)
N#define RCC_SYSCLK_Div512                ((u32)0x000000F0)
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N
N/* APB1/APB2 clock source */
N#define RCC_HCLK_Div1                    ((u32)0x00000000)
N#define RCC_HCLK_Div2                    ((u32)0x00000400)
N#define RCC_HCLK_Div4                    ((u32)0x00000500)
N#define RCC_HCLK_Div8                    ((u32)0x00000600)
N#define RCC_HCLK_Div16                   ((u32)0x00000700)
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N
N/* RCC Interrupt source */
N#define RCC_IT_LSIRDY                    ((u8)0x01)
N#define RCC_IT_LSERDY                    ((u8)0x02)
N#define RCC_IT_HSIRDY                    ((u8)0x04)
N#define RCC_IT_HSERDY                    ((u8)0x08)
N#define RCC_IT_PLLRDY                    ((u8)0x10)
N#define RCC_IT_CSS                       ((u8)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (u8)0xE0) == 0x00) && ((IT) != 0x00))
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
N#define IS_RCC_CLEAR_IT(IT) ((((IT) & (u8)0x60) == 0x00) && ((IT) != 0x00))
N
N/* USB clock source */
N#define RCC_USBCLKSource_PLLCLK_1Div5    ((u8)0x00)
N#define RCC_USBCLKSource_PLLCLK_Div1     ((u8)0x01)
N
N#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
N                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
X#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) ||                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
N
N/* ADC clock source */
N#define RCC_PCLK2_Div2                   ((u32)0x00000000)
N#define RCC_PCLK2_Div4                   ((u32)0x00004000)
N#define RCC_PCLK2_Div6                   ((u32)0x00008000)
N#define RCC_PCLK2_Div8                   ((u32)0x0000C000)
N
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
N                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) ||                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
N
N/* LSE configuration */
N#define RCC_LSE_OFF                      ((u8)0x00)
N#define RCC_LSE_ON                       ((u8)0x01)
N#define RCC_LSE_Bypass                   ((u8)0x04)
N
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N
N/* RTC clock source */
N#define RCC_RTCCLKSource_LSE             ((u32)0x00000100)
N#define RCC_RTCCLKSource_LSI             ((u32)0x00000200)
N#define RCC_RTCCLKSource_HSE_Div128      ((u32)0x00000300)
N
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
N
N/* AHB peripheral */
N#define RCC_AHBPeriph_DMA1               ((u32)0x00000001)
N#define RCC_AHBPeriph_DMA2               ((u32)0x00000002)
N#define RCC_AHBPeriph_SRAM               ((u32)0x00000004)
N#define RCC_AHBPeriph_FLITF              ((u32)0x00000010)
N#define RCC_AHBPeriph_CRC                ((u32)0x00000040)
N#define RCC_AHBPeriph_FSMC               ((u32)0x00000100)
N#define RCC_AHBPeriph_SDIO               ((u32)0x00000400)
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB2 peripheral */
N#define RCC_APB2Periph_AFIO              ((u32)0x00000001)
N#define RCC_APB2Periph_GPIOA             ((u32)0x00000004)
N#define RCC_APB2Periph_GPIOB             ((u32)0x00000008)
N#define RCC_APB2Periph_GPIOC             ((u32)0x00000010)
N#define RCC_APB2Periph_GPIOD             ((u32)0x00000020)
N#define RCC_APB2Periph_GPIOE             ((u32)0x00000040)
N#define RCC_APB2Periph_GPIOF             ((u32)0x00000080)
N#define RCC_APB2Periph_GPIOG             ((u32)0x00000100)
N#define RCC_APB2Periph_ADC1              ((u32)0x00000200)
N#define RCC_APB2Periph_ADC2              ((u32)0x00000400)
N#define RCC_APB2Periph_TIM1              ((u32)0x00000800)
N#define RCC_APB2Periph_SPI1              ((u32)0x00001000)
N#define RCC_APB2Periph_TIM8              ((u32)0x00002000)
N#define RCC_APB2Periph_USART1            ((u32)0x00004000)
N#define RCC_APB2Periph_ADC3              ((u32)0x00008000)
N#define RCC_APB2Periph_ALL               ((u32)0x0000FFFD)
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFF0002) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB1 peripheral */
N#define RCC_APB1Periph_TIM2              ((u32)0x00000001)
N#define RCC_APB1Periph_TIM3              ((u32)0x00000002)
N#define RCC_APB1Periph_TIM4              ((u32)0x00000004)
N#define RCC_APB1Periph_TIM5              ((u32)0x00000008)
N#define RCC_APB1Periph_TIM6              ((u32)0x00000010)
N#define RCC_APB1Periph_TIM7              ((u32)0x00000020)
N#define RCC_APB1Periph_WWDG              ((u32)0x00000800)
N#define RCC_APB1Periph_SPI2              ((u32)0x00004000)
N#define RCC_APB1Periph_SPI3              ((u32)0x00008000)
N#define RCC_APB1Periph_USART2            ((u32)0x00020000)
N#define RCC_APB1Periph_USART3            ((u32)0x00040000)
N#define RCC_APB1Periph_UART4             ((u32)0x00080000)
N#define RCC_APB1Periph_UART5             ((u32)0x00100000)
N#define RCC_APB1Periph_I2C1              ((u32)0x00200000)
N#define RCC_APB1Periph_I2C2              ((u32)0x00400000)
N#define RCC_APB1Periph_USB               ((u32)0x00800000)
N#define RCC_APB1Periph_CAN               ((u32)0x02000000)
N#define RCC_APB1Periph_BKP               ((u32)0x08000000)
N#define RCC_APB1Periph_PWR               ((u32)0x10000000)
N#define RCC_APB1Periph_DAC               ((u32)0x20000000)
N#define RCC_APB1Periph_ALL               ((u32)0x3AFEC83F)
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0xC50137C0) == 0x00) && ((PERIPH) != 0x00))
N
N/* Clock source to output on MCO pin */
N#define RCC_MCO_NoClock                  ((u8)0x00)
N#define RCC_MCO_SYSCLK                   ((u8)0x04)
N#define RCC_MCO_HSI                      ((u8)0x05)
N#define RCC_MCO_HSE                      ((u8)0x06)
N#define RCC_MCO_PLLCLK_Div2              ((u8)0x07)
N
N#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
N                         ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
N                         ((MCO) == RCC_MCO_PLLCLK_Div2))
X#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) ||                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) ||                          ((MCO) == RCC_MCO_PLLCLK_Div2))
N
N/* RCC Flag */
N#define RCC_FLAG_HSIRDY                  ((u8)0x20)
N#define RCC_FLAG_HSERDY                  ((u8)0x31)
N#define RCC_FLAG_PLLRDY                  ((u8)0x39)
N#define RCC_FLAG_LSERDY                  ((u8)0x41)
N#define RCC_FLAG_LSIRDY                  ((u8)0x61)
N#define RCC_FLAG_PINRST                  ((u8)0x7A)
N#define RCC_FLAG_PORRST                  ((u8)0x7B)
N#define RCC_FLAG_SFTRST                  ((u8)0x7C)
N#define RCC_FLAG_IWDGRST                 ((u8)0x7D)
N#define RCC_FLAG_WWDGRST                 ((u8)0x7E)
N#define RCC_FLAG_LPWRRST                 ((u8)0x7F)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
N                           ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
N                           ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
N                           ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
N                           ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
N                           ((FLAG) == RCC_FLAG_LPWRRST))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) ||                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) ||                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)||                            ((FLAG) == RCC_FLAG_LPWRRST))
N
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid RCC_DeInit(void);
Nvoid RCC_HSEConfig(u32 RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_SYSCLKConfig(u32 RCC_SYSCLKSource);
Nu8 RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(u32 RCC_SYSCLK);
Nvoid RCC_PCLK1Config(u32 RCC_HCLK);
Nvoid RCC_PCLK2Config(u32 RCC_HCLK);
Nvoid RCC_ITConfig(u8 RCC_IT, FunctionalState NewState);
Nvoid RCC_USBCLKConfig(u32 RCC_USBCLKSource);
Nvoid RCC_ADCCLKConfig(u32 RCC_PCLK2);
Nvoid RCC_LSEConfig(u8 RCC_LSE);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_RTCCLKConfig(u32 RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
Nvoid RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_MCOConfig(u8 RCC_MCO);
NFlagStatus RCC_GetFlagStatus(u8 RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(u8 RCC_IT);
Nvoid RCC_ClearITPendingBit(u8 RCC_IT);
N
N#endif /* __STM32F10x_RCC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 21 "..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_tim.c" 2
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N/* ---------------------- TIM registers bit mask ------------------------ */
N#define CR1_CEN_Set                 ((u16)0x0001)
N#define CR1_CEN_Reset               ((u16)0x03FE)
N#define CR1_UDIS_Set                ((u16)0x0002)
N#define CR1_UDIS_Reset              ((u16)0x03FD)
N#define CR1_URS_Set                 ((u16)0x0004)
N#define CR1_URS_Reset               ((u16)0x03FB)
N#define CR1_OPM_Reset               ((u16)0x03F7)
N#define CR1_CounterMode_Mask        ((u16)0x038F)
N#define CR1_ARPE_Set                ((u16)0x0080)
N#define CR1_ARPE_Reset              ((u16)0x037F)
N#define CR1_CKD_Mask                ((u16)0x00FF)
N
N#define CR2_CCPC_Set                ((u16)0x0001)
N#define CR2_CCPC_Reset              ((u16)0xFFFE)
N#define CR2_CCUS_Set                ((u16)0x0004)
N#define CR2_CCUS_Reset              ((u16)0xFFFB)
N#define CR2_CCDS_Set                ((u16)0x0008)
N#define CR2_CCDS_Reset              ((u16)0xFFF7)
N#define CR2_MMS_Mask                ((u16)0xFF8F)
N#define CR2_TI1S_Set                ((u16)0x0080)
N#define CR2_TI1S_Reset              ((u16)0xFF7F)
N#define CR2_OIS1_Reset              ((u16)0x7EFF)
N#define CR2_OIS1N_Reset             ((u16)0x7DFF)
N#define CR2_OIS2_Reset              ((u16)0x7BFF)
N#define CR2_OIS2N_Reset             ((u16)0x77FF)
N#define CR2_OIS3_Reset              ((u16)0x6FFF)
N#define CR2_OIS3N_Reset             ((u16)0x5FFF)
N#define CR2_OIS4_Reset              ((u16)0x3FFF)
N
N#define SMCR_SMS_Mask               ((u16)0xFFF8)
N#define SMCR_ETR_Mask               ((u16)0x00FF)
N#define SMCR_TS_Mask                ((u16)0xFF8F)
N#define SMCR_MSM_Reset              ((u16)0xFF7F)
N#define SMCR_ECE_Set                ((u16)0x4000)
N
N#define CCMR_CC13S_Mask             ((u16)0xFFFC)
N#define CCMR_CC24S_Mask             ((u16)0xFCFF)
N#define CCMR_TI13Direct_Set         ((u16)0x0001)
N#define CCMR_TI24Direct_Set         ((u16)0x0100)
N#define CCMR_OC13FE_Reset           ((u16)0xFFFB)
N#define CCMR_OC24FE_Reset           ((u16)0xFBFF)
N#define CCMR_OC13PE_Reset           ((u16)0xFFF7)
N#define CCMR_OC24PE_Reset           ((u16)0xF7FF)
N#define CCMR_OC13M_Mask             ((u16)0xFF8F)
N#define CCMR_OC24M_Mask             ((u16)0x8FFF) 
N
N#define CCMR_OC13CE_Reset           ((u16)0xFF7F)
N#define CCMR_OC24CE_Reset           ((u16)0x7FFF)
N
N#define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
N#define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
N#define CCMR_IC13F_Mask             ((u16)0xFF0F)
N#define CCMR_IC24F_Mask             ((u16)0x0FFF)
N
N#define CCMR_Offset                 ((u16)0x0018)
N#define CCER_CCE_Set                ((u16)0x0001)
N#define	CCER_CCNE_Set               ((u16)0x0004)
N
N#define CCER_CC1P_Reset             ((u16)0xFFFD)
N#define CCER_CC2P_Reset             ((u16)0xFFDF)
N#define CCER_CC3P_Reset             ((u16)0xFDFF)
N#define CCER_CC4P_Reset             ((u16)0xDFFF)
N
N#define CCER_CC1NP_Reset            ((u16)0xFFF7)
N#define CCER_CC2NP_Reset            ((u16)0xFF7F)
N#define CCER_CC3NP_Reset            ((u16)0xF7FF)
N
N#define CCER_CC1E_Set               ((u16)0x0001)
N#define CCER_CC1E_Reset             ((u16)0xFFFE)
N
N#define CCER_CC1NE_Reset            ((u16)0xFFFB)
N
N#define CCER_CC2E_Set               ((u16)0x0010)
N#define CCER_CC2E_Reset             ((u16)0xFFEF)
N
N#define CCER_CC2NE_Reset            ((u16)0xFFBF)
N
N#define CCER_CC3E_Set               ((u16)0x0100)
N#define CCER_CC3E_Reset             ((u16)0xFEFF)
N
N#define CCER_CC3NE_Reset            ((u16)0xFBFF)
N
N#define CCER_CC4E_Set               ((u16)0x1000)
N#define CCER_CC4E_Reset             ((u16)0xEFFF)
N
N#define BDTR_MOE_Set                ((u16)0x8000)
N#define BDTR_MOE_Reset              ((u16)0x7FFF)
N
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
Nstatic void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
N                       u16 TIM_ICFilter);
Nstatic void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
N                       u16 TIM_ICFilter);
Nstatic void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
N                       u16 TIM_ICFilter);
Nstatic void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
N                       u16 TIM_ICFilter);
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N/*******************************************************************************
N* Function Name  : TIM_DeInit
N* Description    : Deinitializes the TIMx peripheral registers to their default
N*                  reset values.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_DeInit(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
X  ((void)0); 
N 
N  switch (*(u32*)&TIMx)
N  {
N    case TIM1_BASE:
X    case ((((u32)0x40000000) + 0x10000) + 0x2C00):
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
X      RCC_APB2PeriphResetCmd(((u32)0x00000800), ENABLE);
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
X      RCC_APB2PeriphResetCmd(((u32)0x00000800), DISABLE);  
N      break; 
N      
N    case TIM2_BASE:
X    case (((u32)0x40000000) + 0x0000):
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000001), ENABLE);
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000001), DISABLE);
N      break;
N 
N    case TIM3_BASE:
X    case (((u32)0x40000000) + 0x0400):
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000002), ENABLE);
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000002), DISABLE);
N      break;
N 
N    case TIM4_BASE:
X    case (((u32)0x40000000) + 0x0800):
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000004), ENABLE);
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000004), DISABLE);
N      break;
N      
N    case TIM5_BASE:
X    case (((u32)0x40000000) + 0x0C00):
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000008), ENABLE);
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000008), DISABLE);
N      break;
N      
N    case TIM6_BASE:
X    case (((u32)0x40000000) + 0x1000):
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000010), ENABLE);
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000010), DISABLE);
N      break;
N      
N    case TIM7_BASE:
X    case (((u32)0x40000000) + 0x1400):
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000020), ENABLE);
N      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
X      RCC_APB1PeriphResetCmd(((u32)0x00000020), DISABLE);
N      break;
N      
N    case TIM8_BASE:
X    case ((((u32)0x40000000) + 0x10000) + 0x3400):
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
X      RCC_APB2PeriphResetCmd(((u32)0x00002000), ENABLE);
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
X      RCC_APB2PeriphResetCmd(((u32)0x00002000), DISABLE);  
N      break; 
N      
N    default:
N      break;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_TimeBaseInit
N* Description    : Initializes the TIMx Time Base Unit peripheral according to 
N*                  the specified parameters in the TIM_TimeBaseInitStruct.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
N*                   structure that contains the configuration information for
N*                   the specified TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
X  ((void)0);
N  assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
X  ((void)0);
N
N  /* Select the Counter Mode and set the clock division */
N  TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
X  TIMx->CR1 &= ((u16)0x00FF) & ((u16)0x038F);
N  TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
N                TIM_TimeBaseInitStruct->TIM_CounterMode;
N  /* Set the Autoreload value */
N  TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
N
N  /* Set the Prescaler value */
N  TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
N
N  /* Generate an update event to reload the Prescaler value immediatly */
N  TIMx->EGR = TIM_PSCReloadMode_Immediate;
X  TIMx->EGR = ((u16)0x0001);
N    
N  if (((*(u32*)&TIMx) == TIM1_BASE) || ((*(u32*)&TIMx) == TIM8_BASE))  
X  if (((*(u32*)&TIMx) == ((((u32)0x40000000) + 0x10000) + 0x2C00)) || ((*(u32*)&TIMx) == ((((u32)0x40000000) + 0x10000) + 0x3400)))  
N  {
N    /* Set the Repetition Counter value */
N    TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
N  }        
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC1Init
N* Description    : Initializes the TIMx Channel1 according to the specified
N*                  parameters in the TIM_OCInitStruct.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
N*                    that contains the configuration information for the specified
N*                    TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
X  ((void)0);
N  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
X  ((void)0);   
N
N  /* Disable the Channel 1: Reset the CC1E Bit */
N  TIMx->CCER &= CCER_CC1E_Reset;
X  TIMx->CCER &= ((u16)0xFFFE);
N  
N  /* Get the TIMx CCER register value */
N  tmpccer = TIMx->CCER;
N
N  /* Get the TIMx CR2 register value */
N  tmpcr2 =  TIMx->CR2;
N  
N  /* Get the TIMx CCMR1 register value */
N  tmpccmrx = TIMx->CCMR1;
N    
N  /* Reset the Output Compare Mode Bits */
N  tmpccmrx &= CCMR_OC13M_Mask;
X  tmpccmrx &= ((u16)0xFF8F);
N  
N  /* Select the Output Compare Mode */
N  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
N  
N  /* Reset the Output Polarity level */
N  tmpccer &= CCER_CC1P_Reset;
X  tmpccer &= ((u16)0xFFFD);
N
N  /* Set the Output Compare Polarity */
N  tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
N  
N  /* Set the Output State */
N  tmpccer |= TIM_OCInitStruct->TIM_OutputState;
N  
N  /* Set the Capture Compare Register value */
N  TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
N  
N  if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
X  if((*(u32*)&TIMx == ((((u32)0x40000000) + 0x10000) + 0x2C00)) || (*(u32*)&TIMx == ((((u32)0x40000000) + 0x10000) + 0x3400)))
N  {
N    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
X    ((void)0);
N    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
X    ((void)0);
N    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
X    ((void)0);
N    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
X    ((void)0);
N    
N    /* Reset the Output N Polarity level */
N    tmpccer &= CCER_CC1NP_Reset;
X    tmpccer &= ((u16)0xFFF7);
N
N    /* Set the Output N Polarity */
N    tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
N
N    /* Reset the Output N State */
N    tmpccer &= CCER_CC1NE_Reset;
X    tmpccer &= ((u16)0xFFFB);
N    
N    /* Set the Output N State */
N    tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
N
N    /* Reset the Ouput Compare and Output Compare N IDLE State */
N    tmpcr2 &= CR2_OIS1_Reset;
X    tmpcr2 &= ((u16)0x7EFF);
N    tmpcr2 &= CR2_OIS1N_Reset;
X    tmpcr2 &= ((u16)0x7DFF);
N
N    /* Set the Output Idle state */
N    tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
N
N    /* Set the Output N Idle state */
N    tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
N  }
N  /* Write to TIMx CR2 */
N  TIMx->CR2 = tmpcr2;
N  
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmrx;
N  
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC2Init
N* Description    : Initializes the TIMx Channel2 according to the specified
N*                  parameters in the TIM_OCInitStruct.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
N*                    that contains the configuration information for the specified
N*                    TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
X  ((void)0);
N  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
X  ((void)0);   
N
N  /* Disable the Channel 2: Reset the CC2E Bit */
N  TIMx->CCER &= CCER_CC2E_Reset;
X  TIMx->CCER &= ((u16)0xFFEF);
N  
N  /* Get the TIMx CCER register value */  
N  tmpccer = TIMx->CCER;
N
N  /* Get the TIMx CR2 register value */
N  tmpcr2 =  TIMx->CR2;
N  
N  /* Get the TIMx CCMR1 register value */
N  tmpccmrx = TIMx->CCMR1;
N    
N  /* Reset the Output Compare Mode Bits */
N  tmpccmrx &= CCMR_OC24M_Mask;
X  tmpccmrx &= ((u16)0x8FFF);
N  
N  /* Select the Output Compare Mode */
N  tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
N  
N  /* Reset the Output Polarity level */
N  tmpccer &= CCER_CC2P_Reset;
X  tmpccer &= ((u16)0xFFDF);
N
N  /* Set the Output Compare Polarity */
N  tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 4);
N  
N  /* Set the Output State */
N  tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 4);
N  
N  /* Set the Capture Compare Register value */
N  TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
N  
N  if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
X  if((*(u32*)&TIMx == ((((u32)0x40000000) + 0x10000) + 0x2C00)) || (*(u32*)&TIMx == ((((u32)0x40000000) + 0x10000) + 0x3400)))
N  {
N    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
X    ((void)0);
N    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
X    ((void)0);
N    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
X    ((void)0);
N    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
X    ((void)0);
N    
N    /* Reset the Output N Polarity level */
N    tmpccer &= CCER_CC2NP_Reset;
X    tmpccer &= ((u16)0xFF7F);
N
N    /* Set the Output N Polarity */
N    tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
N
N    /* Reset the Output N State */
N    tmpccer &= CCER_CC2NE_Reset;
X    tmpccer &= ((u16)0xFFBF);
N    
N    /* Set the Output N State */
N    tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 4);
N
N    /* Reset the Ouput Compare and Output Compare N IDLE State */
N    tmpcr2 &= CR2_OIS2_Reset;
X    tmpcr2 &= ((u16)0x7BFF);
N    tmpcr2 &= CR2_OIS2N_Reset;
X    tmpcr2 &= ((u16)0x77FF);
N
N    /* Set the Output Idle state */
N    tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 2);
N
N    /* Set the Output N Idle state */
N    tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
N  }
N
N  /* Write to TIMx CR2 */
N  TIMx->CR2 = tmpcr2;
N  
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmrx;
N  
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC3Init
N* Description    : Initializes the TIMx Channel3 according to the specified
N*                  parameters in the TIM_OCInitStruct.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
N*                    that contains the configuration information for the specified
N*                    TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
X  ((void)0);
N  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
X  ((void)0);   
N
N  /* Disable the Channel 2: Reset the CC2E Bit */
N  TIMx->CCER &= CCER_CC3E_Reset;
X  TIMx->CCER &= ((u16)0xFEFF);
N  
N  /* Get the TIMx CCER register value */
N  tmpccer = TIMx->CCER;
N
N  /* Get the TIMx CR2 register value */
N  tmpcr2 =  TIMx->CR2;
N  
N  /* Get the TIMx CCMR2 register value */
N  tmpccmrx = TIMx->CCMR2;
N    
N  /* Reset the Output Compare Mode Bits */
N  tmpccmrx &= CCMR_OC13M_Mask;
X  tmpccmrx &= ((u16)0xFF8F);
N  
N  /* Select the Output Compare Mode */
N  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
N  
N  /* Reset the Output Polarity level */
N  tmpccer &= CCER_CC3P_Reset;
X  tmpccer &= ((u16)0xFDFF);
N
N  /* Set the Output Compare Polarity */
N  tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 8);
N  
N  /* Set the Output State */
N  tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 8);
N  
N  /* Set the Capture Compare Register value */
N  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
N  
N  if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
X  if((*(u32*)&TIMx == ((((u32)0x40000000) + 0x10000) + 0x2C00)) || (*(u32*)&TIMx == ((((u32)0x40000000) + 0x10000) + 0x3400)))
N  {
N    assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
X    ((void)0);
N    assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
X    ((void)0);
N    assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
X    ((void)0);
N    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
X    ((void)0);
N    
N    /* Reset the Output N Polarity level */
N    tmpccer &= CCER_CC3NP_Reset;
X    tmpccer &= ((u16)0xF7FF);
N
N    /* Set the Output N Polarity */
N    tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
N
N    /* Reset the Output N State */
N    tmpccer &= CCER_CC3NE_Reset;
X    tmpccer &= ((u16)0xFBFF);
N    
N    /* Set the Output N State */
N    tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputNState << 8);
N
N    /* Reset the Ouput Compare and Output Compare N IDLE State */
N    tmpcr2 &= CR2_OIS3_Reset;
X    tmpcr2 &= ((u16)0x6FFF);
N    tmpcr2 &= CR2_OIS3N_Reset;
X    tmpcr2 &= ((u16)0x5FFF);
N
N    /* Set the Output Idle state */
N    tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 4);
N
N    /* Set the Output N Idle state */
N    tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
N  }
N
N  /* Write to TIMx CR2 */
N  TIMx->CR2 = tmpcr2;
N  
N  /* Write to TIMx CCMR2 */
N  TIMx->CCMR2 = tmpccmrx;
N  
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC4Init
N* Description    : Initializes the TIMx Channel4 according to the specified
N*                  parameters in the TIM_OCInitStruct.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
N*                    that contains the configuration information for the specified
N*                    TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  u16 tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
N   
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
X  ((void)0); 
N  assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
X  ((void)0);
N  assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
X  ((void)0);   
N
N  /* Disable the Channel 2: Reset the CC4E Bit */
N  TIMx->CCER &= CCER_CC4E_Reset;
X  TIMx->CCER &= ((u16)0xEFFF);
N  
N  /* Get the TIMx CCER register value */
N  tmpccer = TIMx->CCER;
N
N  /* Get the TIMx CR2 register value */
N  tmpcr2 =  TIMx->CR2;
N  
N  /* Get the TIMx CCMR2 register value */
N  tmpccmrx = TIMx->CCMR2;
N    
N  /* Reset the Output Compare Mode Bits */
N  tmpccmrx &= CCMR_OC24M_Mask;
X  tmpccmrx &= ((u16)0x8FFF);
N  
N  /* Select the Output Compare Mode */
N  tmpccmrx |= (u16)(TIM_OCInitStruct->TIM_OCMode << 8);
N  
N  /* Reset the Output Polarity level */
N  tmpccer &= CCER_CC4P_Reset;
X  tmpccer &= ((u16)0xDFFF);
N
N  /* Set the Output Compare Polarity */
N  tmpccer |= (u16)(TIM_OCInitStruct->TIM_OCPolarity << 12);
N  
N  /* Set the Output State */
N  tmpccer |= (u16)(TIM_OCInitStruct->TIM_OutputState << 12);
N  
N  /* Set the Capture Compare Register value */
N  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
N  
N  if((*(u32*)&TIMx == TIM1_BASE) || (*(u32*)&TIMx == TIM8_BASE))
X  if((*(u32*)&TIMx == ((((u32)0x40000000) + 0x10000) + 0x2C00)) || (*(u32*)&TIMx == ((((u32)0x40000000) + 0x10000) + 0x3400)))
N  {
N    assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
X    ((void)0);
N
N    /* Reset the Ouput Compare IDLE State */
N    tmpcr2 &= CR2_OIS4_Reset;
X    tmpcr2 &= ((u16)0x3FFF);
N
N    /* Set the Output Idle state */
N    tmpcr2 |= (u16)(TIM_OCInitStruct->TIM_OCIdleState << 6);
N  }
N
N  /* Write to TIMx CR2 */
N  TIMx->CR2 = tmpcr2;
N  
N  /* Write to TIMx CCMR2 */  
N  TIMx->CCMR2 = tmpccmrx;
N  
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ICInit
N* Description    : Initializes the TIM peripheral according to the specified
N*                  parameters in the TIM_ICInitStruct.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
N*                    that contains the configuration information for the specified
N*                    TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
X  ((void)0);
N  assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
X  ((void)0);
N  assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
X  ((void)0);
N  assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
X  ((void)0);
N  
N  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
X  if (TIM_ICInitStruct->TIM_Channel == ((u16)0x0000))
N  {
N    /* TI1 Configuration */
N    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
N               TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
X  else if (TIM_ICInitStruct->TIM_Channel == ((u16)0x0004))
N  {
N    /* TI2 Configuration */
N    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
N               TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N  else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
X  else if (TIM_ICInitStruct->TIM_Channel == ((u16)0x0008))
N  {
N    /* TI3 Configuration */
N    TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
N               TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N  else
N  {
N    /* TI4 Configuration */
N    TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
N               TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_PWMIConfig
N* Description    : Configures the TIM peripheral according to the specified
N*                  parameters in the TIM_ICInitStruct to measure an external PWM
N*                  signal.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
N*                    that contains the configuration information for the specified
N*                    TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
N{
N  u16 icoppositepolarity = TIM_ICPolarity_Rising;
X  u16 icoppositepolarity = ((u16)0x0000);
N  u16 icoppositeselection = TIM_ICSelection_DirectTI;
X  u16 icoppositeselection = ((u16)0x0001);
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Select the Opposite Input Polarity */
N  if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
X  if (TIM_ICInitStruct->TIM_ICPolarity == ((u16)0x0000))
N  {
N    icoppositepolarity = TIM_ICPolarity_Falling;
X    icoppositepolarity = ((u16)0x0002);
N  }
N  else
N  {
N    icoppositepolarity = TIM_ICPolarity_Rising;
X    icoppositepolarity = ((u16)0x0000);
N  }
N
N  /* Select the Opposite Input */
N  if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
X  if (TIM_ICInitStruct->TIM_ICSelection == ((u16)0x0001))
N  {
N    icoppositeselection = TIM_ICSelection_IndirectTI;
X    icoppositeselection = ((u16)0x0002);
N  }
N  else
N  {
N    icoppositeselection = TIM_ICSelection_DirectTI;
X    icoppositeselection = ((u16)0x0001);
N  }
N
N  if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
X  if (TIM_ICInitStruct->TIM_Channel == ((u16)0x0000))
N  {
N    /* TI1 Configuration */
N    TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N
N    /* TI2 Configuration */
N    TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N  else
N  { 
N    /* TI2 Configuration */
N    TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
N               TIM_ICInitStruct->TIM_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N
N    /* TI1 Configuration */
N    TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
N
N    /* Set the Input Capture Prescaler value */
N    TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_BDTRConfig
N* Description    : Configures the: Break feature, dead time, Lock level, the OSSI,
N*                  the OSSR State and the AOE(automatic output enable).
N* Input          :- TIMx: where x can be  1 or 8 to select the TIM 
N*                 - TIM_BDTRInitStruct: pointer to a TIM_BDTRInitTypeDef
N*                    structure that contains the BDTR Register configuration
N*                    information for the TIM peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_18_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
X  ((void)0);
N  assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
X  ((void)0);
N  assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
X  ((void)0);
N  assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
X  ((void)0);
N  assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
X  ((void)0);
N  assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
X  ((void)0);
N
N  /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
N     the OSSI State, the dead time value and the Automatic Output Enable Bit */
N
N  TIMx->BDTR = (u32)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
N             TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
N             TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
N             TIM_BDTRInitStruct->TIM_AutomaticOutput;
N
N}
N
N/*******************************************************************************
N* Function Name  : TIM_TimeBaseStructInit
N* Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
N* Input          : - TIM_TimeBaseInitStruct : pointer to a TIM_TimeBaseInitTypeDef
N*                    structure which will be initialized.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
N{
N  /* Set the default configuration */
N  TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
N  TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
N  TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
X  TIM_TimeBaseInitStruct->TIM_ClockDivision = ((u16)0x0000);
N  TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
X  TIM_TimeBaseInitStruct->TIM_CounterMode = ((u16)0x0000);
N  TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OCStructInit
N* Description    : Fills each TIM_OCInitStruct member with its default value.
N* Input          : - TIM_OCInitStruct : pointer to a TIM_OCInitTypeDef structure
N*                    which will be initialized.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
N{
N  /* Set the default configuration */
N  TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
X  TIM_OCInitStruct->TIM_OCMode = ((u16)0x0000);
N  TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
X  TIM_OCInitStruct->TIM_OutputState = ((u16)0x0000);
N  TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
X  TIM_OCInitStruct->TIM_OutputNState = ((u16)0x0000);
N  TIM_OCInitStruct->TIM_Pulse = 0x0000;
N  TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
X  TIM_OCInitStruct->TIM_OCPolarity = ((u16)0x0000);
N  TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
X  TIM_OCInitStruct->TIM_OCNPolarity = ((u16)0x0000);
N  TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
X  TIM_OCInitStruct->TIM_OCIdleState = ((u16)0x0000);
N  TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
X  TIM_OCInitStruct->TIM_OCNIdleState = ((u16)0x0000);
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ICStructInit
N* Description    : Fills each TIM_ICInitStruct member with its default value.
N* Input          : - TIM_ICInitStruct : pointer to a TIM_ICInitTypeDef structure
N*                    which will be initialized.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
N{
N  /* Set the default configuration */
N  TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
X  TIM_ICInitStruct->TIM_Channel = ((u16)0x0000);
N  TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
X  TIM_ICInitStruct->TIM_ICPolarity = ((u16)0x0000);
N  TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
X  TIM_ICInitStruct->TIM_ICSelection = ((u16)0x0001);
N  TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
X  TIM_ICInitStruct->TIM_ICPrescaler = ((u16)0x0000);
N  TIM_ICInitStruct->TIM_ICFilter = 0x00;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_BDTRStructInit
N* Description    : Fills each TIM_BDTRInitStruct member with its default value.
N* Input          : - TIM_BDTRInitStruct : pointer to a TIM_BDTRInitTypeDef
N*                    structure which will be initialized.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
N{
N  /* Set the default configuration */
N  TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
X  TIM_BDTRInitStruct->TIM_OSSRState = ((u16)0x0000);
N  TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
X  TIM_BDTRInitStruct->TIM_OSSIState = ((u16)0x0000);
N  TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
X  TIM_BDTRInitStruct->TIM_LOCKLevel = ((u16)0x0000);
N  TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
N  TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
X  TIM_BDTRInitStruct->TIM_Break = ((u16)0x0000);
N  TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
X  TIM_BDTRInitStruct->TIM_BreakPolarity = ((u16)0x0000);
N  TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
X  TIM_BDTRInitStruct->TIM_AutomaticOutput = ((u16)0x0000);
N}
N
N/*******************************************************************************
N* Function Name  : TIM_Cmd
N* Description    : Enables or disables the specified TIM peripheral.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
N*                  - NewState: new state of the TIMx peripheral.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Enable the TIM Counter */
N    TIMx->CR1 |= CR1_CEN_Set;
X    TIMx->CR1 |= ((u16)0x0001);
N  }
N  else
N  {
N    /* Disable the TIM Counter */
N    TIMx->CR1 &= CR1_CEN_Reset;
X    TIMx->CR1 &= ((u16)0x03FE);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_CtrlPWMOutputs
N* Description    : Enables or disables the TIM peripheral Main Outputs.
N* Input          :- TIMx: where x can be 1 or 8 to select the TIMx peripheral.
N*                 - NewState: new state of the TIM peripheral Main Outputs.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_18_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the TIM Main Output */
N    TIMx->BDTR |= BDTR_MOE_Set;
X    TIMx->BDTR |= ((u16)0x8000);
N  }
N  else
N  {
N    /* Disable the TIM Main Output */
N    TIMx->BDTR &= BDTR_MOE_Reset;
X    TIMx->BDTR &= ((u16)0x7FFF);
N  }  
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ITConfig
N* Description    : Enables or disables the specified TIM interrupts.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIMx peripheral.
N*                  - TIM_IT: specifies the TIM interrupts sources to be enabled
N*                    or disabled.
N*                    This parameter can be any combination of the following values:
N*                       - TIM_IT_Update: TIM update Interrupt source
N*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
N*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
N*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
N*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
N*                       - TIM_IT_COM: TIM Commutation Interrupt source
N*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
N*                       - TIM_IT_Break: TIM Break Interrupt source
N*                  - NewState: new state of the TIM interrupts.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, FunctionalState NewState)
N{  
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IT(TIM_IT));
X  ((void)0);
N  assert_param(IS_TIM_PERIPH_IT((TIMx), (TIM_IT)));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Enable the Interrupt sources */
N    TIMx->DIER |= TIM_IT;
N  }
N  else
N  {
N    /* Disable the Interrupt sources */
N    TIMx->DIER &= (u16)~TIM_IT;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_GenerateEvent
N* Description    : Configures the TIMx event to be generate by software.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - TIM_EventSource: specifies the event source.
N*                    This parameter can be one or more of the following values:	   
N*                       - TIM_EventSource_Update: Timer update Event source
N*                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
N*                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
N*                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
N*                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
N*                       - TIM_EventSource_Trigger: Timer Trigger Event source
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
N{ 
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
X  ((void)0);
N  assert_param(IS_TIM_PERIPH_EVENT((TIMx), (TIM_EventSource)));
X  ((void)0);
N
N  /* Set the event sources */
N  TIMx->EGR = TIM_EventSource;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_DMAConfig
N* Description    : Configures the TIMxs DMA interface.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_DMABase: DMA Base address.
N*                    This parameter can be one of the following values:
N*                       - TIM_DMABase_CR, TIM_DMABase_CR2, TIM_DMABase_SMCR,
N*                         TIM_DMABase_DIER, TIM1_DMABase_SR, TIM_DMABase_EGR,
N*                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
N*                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
N*                         TIM_DMABase_RCR, TIM_DMABase_CCR1, TIM_DMABase_CCR2,
N*                         TIM_DMABase_CCR3, TIM_DMABase_CCR4, TIM_DMABase_BDTR,
N*                         TIM_DMABase_DCR.
N*                   - TIM_DMABurstLength: DMA Burst length.
N*                     This parameter can be one value between:
N*                     TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
X  ((void)0);
N  assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
X  ((void)0);
N
N  /* Set the DMA Base and the DMA Burst Length */
N  TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_DMACmd
N* Description    : Enables or disables the TIMxs DMA Requests.
N* Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral. 
N*                  - TIM_DMASources: specifies the DMA Request sources.
N*                    This parameter can be any combination of the following values:
N*                       - TIM_DMA_Update: TIM update Interrupt source
N*                       - TIM_DMA_CC1: TIM Capture Compare 1 DMA source
N*                       - TIM_DMA_CC2: TIM Capture Compare 2 DMA source
N*                       - TIM_DMA_CC3: TIM Capture Compare 3 DMA source
N*                       - TIM_DMA_CC4: TIM Capture Compare 4 DMA source
N*                       - TIM_DMA_COM: TIM Commutation DMA source
N*                       - TIM_DMA_Trigger: TIM Trigger DMA source
N*                  - NewState: new state of the DMA Request sources.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, FunctionalState NewState)
N{ 
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
X  ((void)0);
N  assert_param(IS_TIM_PERIPH_DMA(TIMx, TIM_DMASource));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  
N  if (NewState != DISABLE)
N  {
N    /* Enable the DMA sources */
N    TIMx->DIER |= TIM_DMASource; 
N  }
N  else
N  {
N    /* Disable the DMA sources */
N    TIMx->DIER &= (u16)~TIM_DMASource;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_InternalClockConfig
N* Description    : Configures the TIMx interrnal Clock
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_InternalClockConfig(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Disable slave mode to clock the prescaler directly with the internal clock */
N  TIMx->SMCR &=  SMCR_SMS_Mask;
X  TIMx->SMCR &=  ((u16)0xFFF8);
N}
N/*******************************************************************************
N* Function Name  : TIM_ITRxExternalClockConfig
N* Description    : Configures the TIMx Internal Trigger as External Clock
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ITRSource: Trigger source.
N*                    This parameter can be one of the following values:
N*                       - TIM_TS_ITR0: Internal Trigger 0
N*                       - TIM_TS_ITR1: Internal Trigger 1
N*                       - TIM_TS_ITR2: Internal Trigger 2
N*                       - TIM_TS_ITR3: Internal Trigger 3
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
X  ((void)0);
N
N  /* Select the Internal Trigger */
N  TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
N
N  /* Select the External clock mode1 */
N  TIMx->SMCR |= TIM_SlaveMode_External1;
X  TIMx->SMCR |= ((u16)0x0007);
N}
N/*******************************************************************************
N* Function Name  : TIM_TIxExternalClockConfig
N* Description    : Configures the TIMx Trigger as External Clock
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_TIxExternalCLKSource: Trigger source.
N*                    This parameter can be one of the following values:
N*                       - TIM_TIxExternalCLK1Source_TI1ED: TI1 Edge Detector
N*                       - TIM_TIxExternalCLK1Source_TI1: Filtered Timer Input 1
N*                       - TIM_TIxExternalCLK1Source_TI2: Filtered Timer Input 2
N*                  - TIM_ICPolarity: specifies the TIx Polarity.
N*                    This parameter can be:
N*                       - TIM_ICPolarity_Rising
N*                       - TIM_ICPolarity_Falling
N*                   - ICFilter : specifies the filter value.
N*                     This parameter must be a value between 0x0 and 0xF.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
N                                u16 TIM_ICPolarity, u16 ICFilter)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
X  ((void)0);
N  assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
X  ((void)0);
N  assert_param(IS_TIM_IC_FILTER(ICFilter));
X  ((void)0);
N
N  /* Configure the Timer Input Clock Source */
N  if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
X  if (TIM_TIxExternalCLKSource == ((u16)0x0060))
N  {
N    TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
X    TI2_Config(TIMx, TIM_ICPolarity, ((u16)0x0001), ICFilter);
N  }
N  else
N  {
N    TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
X    TI1_Config(TIMx, TIM_ICPolarity, ((u16)0x0001), ICFilter);
N  }
N
N  /* Select the Trigger source */
N  TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
N
N  /* Select the External clock mode1 */
N  TIMx->SMCR |= TIM_SlaveMode_External1;
X  TIMx->SMCR |= ((u16)0x0007);
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ETRClockMode1Config
N* Description    : Configures the External clock Mode1
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
N*                    It can be one of the following values:
N*                       - TIM_ExtTRGPSC_OFF
N*                       - TIM_ExtTRGPSC_DIV2
N*                       - TIM_ExtTRGPSC_DIV4
N*                       - TIM_ExtTRGPSC_DIV8.
N*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
N*                    It can be one of the following values:
N*                       - TIM_ExtTRGPolarity_Inverted
N*                       - TIM_ExtTRGPolarity_NonInverted
N*                  - ExtTRGFilter: External Trigger Filter.
N*                    This parameter must be a value between 0x00 and 0x0F
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
N                             u16 ExtTRGFilter)
N{
N  u16 tmpsmcr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
X  ((void)0);
N  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
X  ((void)0);
N  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
X  ((void)0);
N
N  /* Configure the ETR Clock source */
N  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
N  
N  /* Get the TIMx SMCR register value */
N  tmpsmcr = TIMx->SMCR;
N
N  /* Reset the SMS Bits */
N  tmpsmcr &= SMCR_SMS_Mask;
X  tmpsmcr &= ((u16)0xFFF8);
N  /* Select the External clock mode1 */
N  tmpsmcr |= TIM_SlaveMode_External1;
X  tmpsmcr |= ((u16)0x0007);
N
N  /* Select the Trigger selection : ETRF */
N  tmpsmcr &= SMCR_TS_Mask;
X  tmpsmcr &= ((u16)0xFF8F);
N  tmpsmcr |= TIM_TS_ETRF;
X  tmpsmcr |= ((u16)0x0070);
N
N  /* Write to TIMx SMCR */
N  TIMx->SMCR = tmpsmcr;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ETRClockMode2Config
N* Description    : Configures the External clock Mode2
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
N*                    It can be one of the following values:
N*                       - TIM_ExtTRGPSC_OFF
N*                       - TIM_ExtTRGPSC_DIV2
N*                       - TIM_ExtTRGPSC_DIV4
N*                       - TIM_ExtTRGPSC_DIV8
N*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
N*                    It can be one of the following values:
N*                       - TIM_ExtTRGPolarity_Inverted
N*                       - TIM_ExtTRGPolarity_NonInverted
N*                  - ExtTRGFilter: External Trigger Filter.
N*                    This parameter must be a value between 0x00 and 0x0F
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
N                             u16 TIM_ExtTRGPolarity, u16 ExtTRGFilter)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
X  ((void)0);
N  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
X  ((void)0);
N  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
X  ((void)0);
N
N  /* Configure the ETR Clock source */
N  TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
N
N  /* Enable the External clock mode2 */
N  TIMx->SMCR |= SMCR_ECE_Set;
X  TIMx->SMCR |= ((u16)0x4000);
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ETRConfig
N* Description    : Configures the TIMx External Trigger (ETR).
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
N*                    This parameter can be one of the following values:
N*                       - TIM_ExtTRGPSC_OFF
N*                       - TIM_ExtTRGPSC_DIV2
N*                       - TIM_ExtTRGPSC_DIV4
N*                       - TIM_ExtTRGPSC_DIV8
N*                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM_ExtTRGPolarity_Inverted
N*                       - TIM_ExtTRGPolarity_NonInverted
N*                  - ExtTRGFilter: External Trigger Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
N                   u16 ExtTRGFilter)
N{
N  u16 tmpsmcr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
X  ((void)0);
N  assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
X  ((void)0);
N  assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
X  ((void)0);
N
N  tmpsmcr = TIMx->SMCR;
N
N  /* Reset the ETR Bits */
N  tmpsmcr &= SMCR_ETR_Mask;
X  tmpsmcr &= ((u16)0x00FF);
N
N  /* Set the Prescaler, the Filter value and the Polarity */
N  tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)(ExtTRGFilter << 8);
N
N  /* Write to TIMx SMCR */
N  TIMx->SMCR = tmpsmcr;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_PrescalerConfig
N* Description    : Configures the TIMx Prescaler.
N* Input          : - TIMx: where x can be  1 to 8 to select the TIM peripheral.
N*                  - Prescaler: specifies the Prescaler Register value
N*                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
N*                    This parameter can be one of the following values:
N*                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
N*                         the update event.
N*                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
N*                         immediatly.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
X  ((void)0);
N
N  /* Set the Prescaler value */
N  TIMx->PSC = Prescaler;
N
N  /* Set or reset the UG Bit */
N  TIMx->EGR = TIM_PSCReloadMode;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_CounterModeConfig
N* Description    : Specifies the TIMx Counter Mode to be used.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_CounterMode: specifies the Counter Mode to be used
N*                    This parameter can be one of the following values:
N*                       - TIM_CounterMode_Up: TIM Up Counting Mode
N*                       - TIM_CounterMode_Down: TIM Down Counting Mode
N*                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
N*                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
N*                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
N{
N  u16 tmpcr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
X  ((void)0);
N
N  tmpcr1 = TIMx->CR1;
N
N  /* Reset the CMS and DIR Bits */
N  tmpcr1 &= CR1_CounterMode_Mask;
X  tmpcr1 &= ((u16)0x038F);
N
N  /* Set the Counter Mode */
N  tmpcr1 |= TIM_CounterMode;
N
N  /* Write to TIMx CR1 register */
N  TIMx->CR1 = tmpcr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectInputTrigger
N* Description    : Selects the Input Trigger source
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_InputTriggerSource: The Input Trigger source.
N*                    This parameter can be one of the following values:
N*                       - TIM_TS_ITR0: Internal Trigger 0
N*                       - TIM_TS_ITR1: Internal Trigger 1
N*                       - TIM_TS_ITR2: Internal Trigger 2
N*                       - TIM_TS_ITR3: Internal Trigger 3
N*                       - TIM_TS_TI1F_ED: TI1 Edge Detector
N*                       - TIM_TS_TI1FP1: Filtered Timer Input 1
N*                       - TIM_TS_TI2FP2: Filtered Timer Input 2
N*                       - TIM_TS_ETRF: External Trigger input
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
N{
N  u16 tmpsmcr = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
X  ((void)0);
N
N  /* Get the TIMx SMCR register value */
N  tmpsmcr = TIMx->SMCR;
N
N  /* Reset the TS Bits */
N  tmpsmcr &= SMCR_TS_Mask;
X  tmpsmcr &= ((u16)0xFF8F);
N
N  /* Set the Input Trigger source */
N  tmpsmcr |= TIM_InputTriggerSource;
N
N  /* Write to TIMx SMCR */
N  TIMx->SMCR = tmpsmcr;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_EncoderInterfaceConfig
N* Description    : Configures the TIMx Encoder Interface.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
N*                    This parameter can be one of the following values:
N*                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
N*                         depending on TI2FP2 level.
N*                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
N*                         depending on TI1FP1 level.
N*                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
N*                         TI2FP2 edges depending on the level of the other input.
N*                  - TIM_IC1Polarity: specifies the IC1 Polarity
N*                    This parmeter can be one of the following values:
N*                        - TIM_ICPolarity_Falling: IC Falling edge.
N*                        - TIM_ICPolarity_Rising: IC Rising edge.
N*                  - TIM_IC2Polarity: specifies the IC2 Polarity
N*                    This parmeter can be one of the following values:
N*                        - TIM_ICPolarity_Falling: IC Falling edge.
N*                        - TIM_ICPolarity_Rising: IC Rising edge.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
N                                u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
N{
N  u16 tmpsmcr = 0;
N  u16 tmpccmr1 = 0;
N  u16 tmpccer = 0;
N    
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
X  ((void)0);
N  assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
X  ((void)0);
N  assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
X  ((void)0);
N
N  /* Get the TIMx SMCR register value */
N  tmpsmcr = TIMx->SMCR;
N
N  /* Get the TIMx CCMR1 register value */
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Get the TIMx CCER register value */
N  tmpccer = TIMx->CCER;
N
N  /* Set the encoder Mode */
N  tmpsmcr &= SMCR_SMS_Mask;
X  tmpsmcr &= ((u16)0xFFF8);
N  tmpsmcr |= TIM_EncoderMode;
N
N  /* Select the Capture Compare 1 and the Capture Compare 2 as input */
N  tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
X  tmpccmr1 &= ((u16)0xFFFC) & ((u16)0xFCFF);
N  tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
X  tmpccmr1 |= ((u16)0x0001) | ((u16)0x0100);
N
N  /* Set the TI1 and the TI2 Polarities */
N  tmpccer &= CCER_CC1P_Reset & CCER_CC2P_Reset;
X  tmpccer &= ((u16)0xFFFD) & ((u16)0xFFDF);
N  tmpccer |= (TIM_IC1Polarity | (u16)(TIM_IC2Polarity << 4));
N
N  /* Write to TIMx SMCR */
N  TIMx->SMCR = tmpsmcr;
N
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmr1;
N
N  /* Write to TIMx CCER */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ForcedOC1Config
N* Description    : Forces the TIMx output 1 waveform to active or inactive level.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ForcedAction: specifies the forced Action to be set to
N*                    the output waveform.
N*                    This parameter can be one of the following values:
N*                       - TIM_ForcedAction_Active: Force active level on OC1REF
N*                       - TIM_ForcedAction_InActive: Force inactive level on
N*                         OC1REF.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
N{
N  u16 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
X  ((void)0);
N
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Reset the OC1M Bits */
N  tmpccmr1 &= CCMR_OC13M_Mask;
X  tmpccmr1 &= ((u16)0xFF8F);
N
N  /* Configure The Forced output Mode */
N  tmpccmr1 |= TIM_ForcedAction;
N
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ForcedOC2Config
N* Description    : Forces the TIMx output 2 waveform to active or inactive level.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ForcedAction: specifies the forced Action to be set to
N*                    the output waveform.
N*                    This parameter can be one of the following values:
N*                       - TIM_ForcedAction_Active: Force active level on OC2REF
N*                       - TIM_ForcedAction_InActive: Force inactive level on
N*                         OC2REF.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
N{
N  u16 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
X  ((void)0);
N
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Reset the OC2M Bits */
N  tmpccmr1 &= CCMR_OC24M_Mask;
X  tmpccmr1 &= ((u16)0x8FFF);
N
N  /* Configure The Forced output Mode */
N  tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
N
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ForcedOC3Config
N* Description    : Forces the TIMx output 3 waveform to active or inactive level.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ForcedAction: specifies the forced Action to be set to
N*                    the output waveform.
N*                    This parameter can be one of the following values:
N*                       - TIM_ForcedAction_Active: Force active level on OC3REF
N*                       - TIM_ForcedAction_InActive: Force inactive level on
N*                         OC3REF.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
N{
N  u16 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
X  ((void)0);
N
N  tmpccmr2 = TIMx->CCMR2;
N
N  /* Reset the OC1M Bits */
N  tmpccmr2 &= CCMR_OC13M_Mask;
X  tmpccmr2 &= ((u16)0xFF8F);
N
N  /* Configure The Forced output Mode */
N  tmpccmr2 |= TIM_ForcedAction;
N
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ForcedOC4Config
N* Description    : Forces the TIMx output 4 waveform to active or inactive level.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ForcedAction: specifies the forced Action to be set to
N*                    the output waveform.
N*                    This parameter can be one of the following values:
N*                       - TIM_ForcedAction_Active: Force active level on OC4REF
N*                       - TIM_ForcedAction_InActive: Force inactive level on
N*                         OC4REF.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
N{
N  u16 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
X  ((void)0);
N  tmpccmr2 = TIMx->CCMR2;
N
N  /* Reset the OC2M Bits */
N  tmpccmr2 &= CCMR_OC24M_Mask;
X  tmpccmr2 &= ((u16)0x8FFF);
N
N  /* Configure The Forced output Mode */
N  tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
N
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ARRPreloadConfig
N* Description    : Enables or disables TIMx peripheral Preload register on ARR.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - NewState: new state of the TIMx peripheral Preload register
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Set the ARR Preload Bit */
N    TIMx->CR1 |= CR1_ARPE_Set;
X    TIMx->CR1 |= ((u16)0x0080);
N  }
N  else
N  {
N    /* Reset the ARR Preload Bit */
N    TIMx->CR1 &= CR1_ARPE_Reset;
X    TIMx->CR1 &= ((u16)0x037F);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectCOM
N* Description    : Selects the TIM peripheral Commutation event.
N* Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
N*                 - NewState: new state of the Commutation event.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_18_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Set the COM Bit */
N    TIMx->CR2 |= CR2_CCUS_Set;
X    TIMx->CR2 |= ((u16)0x0004);
N  }
N  else
N  {
N    /* Reset the COM Bit */
N    TIMx->CR2 &= CR2_CCUS_Reset;
X    TIMx->CR2 &= ((u16)0xFFFB);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectCCDMA
N* Description    : Selects the TIMx peripheral Capture Compare DMA source.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - NewState: new state of the Capture Compare DMA source
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Set the CCDS Bit */
N    TIMx->CR2 |= CR2_CCDS_Set;
X    TIMx->CR2 |= ((u16)0x0008);
N  }
N  else
N  {
N    /* Reset the CCDS Bit */
N    TIMx->CR2 &= CR2_CCDS_Reset;
X    TIMx->CR2 &= ((u16)0xFFF7);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_CCPreloadControl
N* Description    : Sets or Resets the TIM peripheral Capture Compare Preload 
N*                  Control bit.
N* Input          :- TIMx: where x can be  1 or 8 to select the TIMx peripheral
N*                 - NewState: new state of the Capture Compare Preload Control bit
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
N{ 
N  /* Check the parameters */
N  assert_param(IS_TIM_18_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Set the CCPC Bit */
N    TIMx->CR2 |= CR2_CCPC_Set;
X    TIMx->CR2 |= ((u16)0x0001);
N  }
N  else
N  {
N    /* Reset the CCPC Bit */
N    TIMx->CR2 &= CR2_CCPC_Reset;
X    TIMx->CR2 &= ((u16)0xFFFE);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC1PreloadConfig
N* Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
N*                    register
N*                    This parameter can be one of the following values:
N*                       - TIM_OCPreload_Enable
N*                       - TIM_OCPreload_Disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
N{
N  u16 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
X  ((void)0);
N
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Reset the OC1PE Bit */
N  tmpccmr1 &= CCMR_OC13PE_Reset;
X  tmpccmr1 &= ((u16)0xFFF7);
N
N  /* Enable or Disable the Output Compare Preload feature */
N  tmpccmr1 |= TIM_OCPreload;
N
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC2PreloadConfig
N* Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
N*                    register
N*                    This parameter can be one of the following values:
N*                       - TIM_OCPreload_Enable
N*                       - TIM_OCPreload_Disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
N{
N  u16 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
X  ((void)0);
N
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Reset the OC2PE Bit */
N  tmpccmr1 &= CCMR_OC24PE_Reset;
X  tmpccmr1 &= ((u16)0xF7FF);
N
N  /* Enable or Disable the Output Compare Preload feature */
N  tmpccmr1 |= (u16)(TIM_OCPreload << 8);
N
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC3PreloadConfig
N* Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
N*                    register
N*                    This parameter can be one of the following values:
N*                       - TIM_OCPreload_Enable
N*                       - TIM_OCPreload_Disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
N{
N  u16 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
X  ((void)0);
N
N  tmpccmr2 = TIMx->CCMR2;
N
N  /* Reset the OC3PE Bit */
N  tmpccmr2 &= CCMR_OC13PE_Reset;
X  tmpccmr2 &= ((u16)0xFFF7);
N
N  /* Enable or Disable the Output Compare Preload feature */
N  tmpccmr2 |= TIM_OCPreload;
N
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC4PreloadConfig
N* Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCPreload: new state of the TIMx peripheral Preload
N*                    register
N*                    This parameter can be one of the following values:
N*                       - TIM_OCPreload_Enable
N*                       - TIM_OCPreload_Disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
N{
N  u16 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
X  ((void)0);
N
N  tmpccmr2 = TIMx->CCMR2;
N
N  /* Reset the OC4PE Bit */
N  tmpccmr2 &= CCMR_OC24PE_Reset;
X  tmpccmr2 &= ((u16)0xF7FF);
N
N  /* Enable or Disable the Output Compare Preload feature */
N  tmpccmr2 |= (u16)(TIM_OCPreload << 8);
N
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC1FastConfig
N* Description    : Configures the TIMx Output Compare 1 Fast feature.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM_OCFast_Enable: TIM output compare fast enable
N*                       - TIM_OCFast_Disable: TIM output compare fast disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
N{
N  u16 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
X  ((void)0);
N
N  /* Get the TIMx CCMR1 register value */
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Reset the OC1FE Bit */
N  tmpccmr1 &= CCMR_OC13FE_Reset;
X  tmpccmr1 &= ((u16)0xFFFB);
N
N  /* Enable or Disable the Output Compare Fast Bit */
N  tmpccmr1 |= TIM_OCFast;
N
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC2FastConfig
N* Description    : Configures the TIMx Output Compare 2 Fast feature.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM_OCFast_Enable: TIM output compare fast enable
N*                       - TIM_OCFast_Disable: TIM output compare fast disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
N{
N  u16 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
X  ((void)0);
N
N  /* Get the TIMx CCMR1 register value */
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Reset the OC2FE Bit */
N  tmpccmr1 &= CCMR_OC24FE_Reset;
X  tmpccmr1 &= ((u16)0xFBFF);
N
N  /* Enable or Disable the Output Compare Fast Bit */
N  tmpccmr1 |= (u16)(TIM_OCFast << 8);
N
N  /* Write to TIMx CCMR1 */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC3FastConfig
N* Description    : Configures the TIMx Output Compare 3 Fast feature.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM_OCFast_Enable: TIM output compare fast enable
N*                       - TIM_OCFast_Disable: TIM output compare fast disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
N{
N  u16 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
X  ((void)0);
N
N  /* Get the TIMx CCMR2 register value */
N  tmpccmr2 = TIMx->CCMR2;
N
N  /* Reset the OC3FE Bit */
N  tmpccmr2 &= CCMR_OC13FE_Reset;
X  tmpccmr2 &= ((u16)0xFFFB);
N
N  /* Enable or Disable the Output Compare Fast Bit */
N  tmpccmr2 |= TIM_OCFast;
N
N  /* Write to TIMx CCMR2 */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC4FastConfig
N* Description    : Configures the TIMx Output Compare 4 Fast feature.
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM_OCFast_Enable: TIM output compare fast enable
N*                       - TIM_OCFast_Disable: TIM output compare fast disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
N{
N  u16 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
X  ((void)0);
N
N  /* Get the TIMx CCMR2 register value */
N  tmpccmr2 = TIMx->CCMR2;
N
N  /* Reset the OC4FE Bit */
N  tmpccmr2 &= CCMR_OC24FE_Reset;
X  tmpccmr2 &= ((u16)0xFBFF);
N
N  /* Enable or Disable the Output Compare Fast Bit */
N  tmpccmr2 |= (u16)(TIM_OCFast << 8);
N
N  /* Write to TIMx CCMR2 */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ClearOC1Ref
N* Description    : Clears or safeguards the OCREF1 signal on an external event
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM_OCClear_Enable: TIM Output clear enable
N*                       - TIM_OCClear_Disable: TIM Output clear disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
N{
N  u16 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
X  ((void)0);
N
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Reset the OC1CE Bit */
N  tmpccmr1 &= CCMR_OC13CE_Reset;
X  tmpccmr1 &= ((u16)0xFF7F);
N
N  /* Enable or Disable the Output Compare Clear Bit */
N  tmpccmr1 |= TIM_OCClear;
N
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ClearOC2Ref
N* Description    : Clears or safeguards the OCREF2 signal on an external event
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM_OCClear_Enable: TIM Output clear enable
N*                       - TIM_OCClear_Disable: TIM Output clear disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
N{
N  u16 tmpccmr1 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
X  ((void)0);
N
N  tmpccmr1 = TIMx->CCMR1;
N
N  /* Reset the OC2CE Bit */
N  tmpccmr1 &= CCMR_OC24CE_Reset;
X  tmpccmr1 &= ((u16)0x7FFF);
N
N  /* Enable or Disable the Output Compare Clear Bit */
N  tmpccmr1 |= (u16)(TIM_OCClear << 8);
N
N  /* Write to TIMx CCMR1 register */
N  TIMx->CCMR1 = tmpccmr1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ClearOC3Ref
N* Description    : Clears or safeguards the OCREF3 signal on an external event
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM_OCClear_Enable: TIM Output clear enable
N*                       - TIM_OCClear_Disable: TIM Output clear disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
N{
N  u16 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
X  ((void)0);
N
N  tmpccmr2 = TIMx->CCMR2;
N
N  /* Reset the OC3CE Bit */
N  tmpccmr2 &= CCMR_OC13CE_Reset;
X  tmpccmr2 &= ((u16)0xFF7F);
N
N  /* Enable or Disable the Output Compare Clear Bit */
N  tmpccmr2 |= TIM_OCClear;
N
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ClearOC4Ref
N* Description    : Clears or safeguards the OCREF4 signal on an external event
N* Input          : - TIMx: where x can be  1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
N*                    This parameter can be one of the following values:
N*                       - TIM_OCClear_Enable: TIM Output clear enable
N*                       - TIM_OCClear_Disable: TIM Output clear disable
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
N{
N  u16 tmpccmr2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
X  ((void)0);
N
N  tmpccmr2 = TIMx->CCMR2;
N
N  /* Reset the OC4CE Bit */
N  tmpccmr2 &= CCMR_OC24CE_Reset;
X  tmpccmr2 &= ((u16)0x7FFF);
N
N  /* Enable or Disable the Output Compare Clear Bit */
N  tmpccmr2 |= (u16)(TIM_OCClear << 8);
N
N  /* Write to TIMx CCMR2 register */
N  TIMx->CCMR2 = tmpccmr2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC1PolarityConfig
N* Description    : Configures the TIMx channel 1 polarity.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCPolarity: specifies the OC1 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM_OCPolarity_High: Output Compare active high
N*                       - TIM_OCPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
N{
N  u16 tmpccer = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
X  ((void)0);
N
N  tmpccer = TIMx->CCER;
N
N  /* Set or Reset the CC1P Bit */
N  tmpccer &= CCER_CC1P_Reset;
X  tmpccer &= ((u16)0xFFFD);
N  tmpccer |= TIM_OCPolarity;
N
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC1NPolarityConfig
N* Description    : Configures the TIMx Channel 1N polarity.
N* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
N*                  - TIM_OCNPolarity: specifies the OC1N Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM_OCNPolarity_High: Output Compare active high
N*                       - TIM_OCNPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
N{
N  u16 tmpccer = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_18_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
X  ((void)0);
N   
N  tmpccer = TIMx->CCER;
N
N  /* Set or Reset the CC1NP Bit */
N  tmpccer &= CCER_CC1NP_Reset;
X  tmpccer &= ((u16)0xFFF7);
N  tmpccer |= TIM_OCNPolarity;
N
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC2PolarityConfig
N* Description    : Configures the TIMx channel 2 polarity.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCPolarity: specifies the OC2 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM_OCPolarity_High: Output Compare active high
N*                       - TIM_OCPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
N{
N  u16 tmpccer = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
X  ((void)0);
N
N  tmpccer = TIMx->CCER;
N
N  /* Set or Reset the CC2P Bit */
N  tmpccer &= CCER_CC2P_Reset;
X  tmpccer &= ((u16)0xFFDF);
N  tmpccer |= (u16)(TIM_OCPolarity << 4);
N
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC2NPolarityConfig
N* Description    : Configures the TIMx Channel 2N polarity.
N* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
N*                  - TIM_OCNPolarity: specifies the OC2N Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM_OCNPolarity_High: Output Compare active high
N*                       - TIM_OCNPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
N{
N  u16 tmpccer = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_18_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
X  ((void)0);
N  
N  tmpccer = TIMx->CCER;
N
N  /* Set or Reset the CC2NP Bit */
N  tmpccer &= CCER_CC2NP_Reset;
X  tmpccer &= ((u16)0xFF7F);
N  tmpccer |= (u16)(TIM_OCNPolarity << 4);
N
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC3PolarityConfig
N* Description    : Configures the TIMx channel 3 polarity.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCPolarity: specifies the OC3 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM_OCPolarity_High: Output Compare active high
N*                       - TIM_OCPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
N{
N  u16 tmpccer = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
X  ((void)0);
N
N  tmpccer = TIMx->CCER;
N
N  /* Set or Reset the CC3P Bit */
N  tmpccer &= CCER_CC3P_Reset;
X  tmpccer &= ((u16)0xFDFF);
N  tmpccer |= (u16)(TIM_OCPolarity << 8);
N
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC3NPolarityConfig
N* Description    : Configures the TIMx Channel 3N polarity.
N* Input          : - TIMx: where x can be 1 or 8 to select the TIM peripheral.
N*                  - TIM_OCNPolarity: specifies the OC3N Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM_OCNPolarity_High: Output Compare active high
N*                       - TIM_OCNPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCNPolarity)
N{
N  u16 tmpccer = 0;
N 
N  /* Check the parameters */
N  assert_param(IS_TIM_18_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
X  ((void)0);
N    
N  tmpccer = TIMx->CCER;
N
N  /* Set or Reset the CC3NP Bit */
N  tmpccer &= CCER_CC3NP_Reset;
X  tmpccer &= ((u16)0xF7FF);
N  tmpccer |= (u16)(TIM_OCNPolarity << 8);
N
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_OC4PolarityConfig
N* Description    : Configures the TIMx channel 4 polarity.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_OCPolarity: specifies the OC4 Polarity
N*                    This parmeter can be one of the following values:
N*                       - TIM_OCPolarity_High: Output Compare active high
N*                       - TIM_OCPolarity_Low: Output Compare active low
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
N{
N  u16 tmpccer = 0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
X  ((void)0);
N
N  tmpccer = TIMx->CCER;
N
N  /* Set or Reset the CC4P Bit */
N  tmpccer &= CCER_CC4P_Reset;
X  tmpccer &= ((u16)0xDFFF);
N  tmpccer |= (u16)(TIM_OCPolarity << 12);
N
N  /* Write to TIMx CCER register */
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_CCxCmd
N* Description    : Enables or disables the TIM Capture Compare Channel x.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
N*                    peripheral.
N*                  - TIM_Channel: specifies the TIM Channel
N*                    This parmeter can be one of the following values:
N*                       - TIM_Channel_1: TIM Channel 1
N*                       - TIM_Channel_2: TIM Channel 2
N*                       - TIM_Channel_3: TIM Channel 3
N*                       - TIM_Channel_4: TIM Channel 4
N*                 - TIM_CCx: specifies the TIM Channel CCxE bit new state.
N*                   This parameter can be: TIM_CCx_Enable or TIM_CCx_Disable. 
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_CCxCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_CHANNEL(TIM_Channel));
X  ((void)0);
N  assert_param(IS_TIM_CCX(TIM_CCx));
X  ((void)0);
N
N  /* Reset the CCxE Bit */
N  TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
X  TIMx->CCER &= (u16)(~((u16)(((u16)0x0001) << TIM_Channel)));
N
N  /* Set or reset the CCxE Bit */ 
N  TIMx->CCER |=  (u16)(TIM_CCx << TIM_Channel);
N}
N
N/*******************************************************************************
N* Function Name  : TIM_CCxNCmd
N* Description    : Enables or disables the TIM Capture Compare Channel xN.
N* Input          :- TIMx: where x can be 1 or 8 to select the TIM peripheral.
N*                 - TIM_Channel: specifies the TIM Channel
N*                    This parmeter can be one of the following values:
N*                       - TIM_Channel_1: TIM Channel 1
N*                       - TIM_Channel_2: TIM Channel 2
N*                       - TIM_Channel_3: TIM Channel 3
N*                 - TIM_CCx: specifies the TIM Channel CCxNE bit new state.
N*                   This parameter can be: TIM_CCxN_Enable or TIM_CCxN_Disable. 
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_CCxNCmd(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_CCxN)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_18_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
X  ((void)0);
N  assert_param(IS_TIM_CCXN(TIM_CCxN));
X  ((void)0);
N
N  /* Reset the CCxNE Bit */
N  TIMx->CCER &= (u16)(~((u16)(CCER_CCNE_Set << TIM_Channel)));
X  TIMx->CCER &= (u16)(~((u16)(((u16)0x0004) << TIM_Channel)));
N
N  /* Set or reset the CCxNE Bit */ 
N  TIMx->CCER |=  (u16)(TIM_CCxN << TIM_Channel);
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectOCxM
N* Description    : Selects the TIM Ouput Compare Mode.
N*                  This function disables the selected channel before changing 
N*                  the Ouput Compare Mode. User has to enable this channel using
N*                  TIM_CCxCmd and TIM_CCxNCmd functions.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM
N*                    peripheral.
N*                  - TIM_Channel: specifies the TIM Channel
N*                    This parmeter can be one of the following values:
N*                       - TIM_Channel_1: TIM Channel 1
N*                       - TIM_Channel_2: TIM Channel 2
N*                       - TIM_Channel_3: TIM Channel 3
N*                       - TIM_Channel_4: TIM Channel 4
N*                  - TIM_OCMode: specifies the TIM Output Compare Mode.
N*                    This paramter can be one of the following values:
N*                       - TIM_OCMode_Timing
N*                       - TIM_OCMode_Active
N*                       - TIM_OCMode_Toggle
N*                       - TIM_OCMode_PWM1
N*                       - TIM_OCMode_PWM2
N*                       - TIM_ForcedAction_Active
N*                       - TIM_ForcedAction_InActive
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectOCxM(TIM_TypeDef* TIMx, u16 TIM_Channel, u16 TIM_OCMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_CHANNEL(TIM_Channel));
X  ((void)0);
N  assert_param(IS_TIM_OCM(TIM_OCMode));
X  ((void)0);
N  
N  /* Disable the Channel: Reset the CCxE Bit */
N  TIMx->CCER &= (u16)(~((u16)(CCER_CCE_Set << TIM_Channel)));
X  TIMx->CCER &= (u16)(~((u16)(((u16)0x0001) << TIM_Channel)));
N
N  if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
X  if((TIM_Channel == ((u16)0x0000)) ||(TIM_Channel == ((u16)0x0008)))
N  {
N    /* Reset the OCxM bits in the CCMRx register */
N    *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) &= CCMR_OC13M_Mask;
X    *((vu32 *)((*(u32*)&TIMx) + ((u16)0x0018) + (TIM_Channel>>1))) &= ((u16)0xFF8F);
N   
N    /* Configure the OCxM bits in the CCMRx register */
N    *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + (TIM_Channel>>1))) = TIM_OCMode;
X    *((vu32 *)((*(u32*)&TIMx) + ((u16)0x0018) + (TIM_Channel>>1))) = TIM_OCMode;
N
N  }
N  else
N  {
N    /* Reset the OCxM bits in the CCMRx register */
N    *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) &= CCMR_OC24M_Mask;
X    *((vu32 *)((*(u32*)&TIMx) + ((u16)0x0018) + ((u16)(TIM_Channel - 4)>> 1))) &= ((u16)0x8FFF);
N    
N    /* Configure the OCxM bits in the CCMRx register */
N    *((vu32 *)((*(u32*)&TIMx) + CCMR_Offset + ((u16)(TIM_Channel - 4)>> 1))) = (u16)(TIM_OCMode << 8);
X    *((vu32 *)((*(u32*)&TIMx) + ((u16)0x0018) + ((u16)(TIM_Channel - 4)>> 1))) = (u16)(TIM_OCMode << 8);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_UpdateDisableConfig
N* Description    : Enables or Disables the TIMx Update event.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - NewState: new state of the TIMx UDIS bit
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Set the Update Disable Bit */
N    TIMx->CR1 |= CR1_UDIS_Set;
X    TIMx->CR1 |= ((u16)0x0002);
N  }
N  else
N  {
N    /* Reset the Update Disable Bit */
N    TIMx->CR1 &= CR1_UDIS_Reset;
X    TIMx->CR1 &= ((u16)0x03FD);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_UpdateRequestConfig
N* Description    : Configures the TIMx Update Request Interrupt source.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - TIM_UpdateSource: specifies the Update source.
N*                    This parameter can be one of the following values:
N*                       - TIM_UpdateSource_Regular
N*                       - TIM_UpdateSource_Global
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
X  ((void)0);
N
N  if (TIM_UpdateSource != TIM_UpdateSource_Global)
X  if (TIM_UpdateSource != ((u16)0x0000))
N  {
N    /* Set the URS Bit */
N    TIMx->CR1 |= CR1_URS_Set;
X    TIMx->CR1 |= ((u16)0x0004);
N  }
N  else
N  {
N    /* Reset the URS Bit */
N    TIMx->CR1 &= CR1_URS_Reset;
X    TIMx->CR1 &= ((u16)0x03FB);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectHallSensor
N* Description    : Enables or disables the TIMxs Hall sensor interface.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM peripheral.
N*                  - NewState: new state of the TIMx Hall sensor interface.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Set the TI1S Bit */
N    TIMx->CR2 |= CR2_TI1S_Set;
X    TIMx->CR2 |= ((u16)0x0080);
N  }
N  else
N  {
N    /* Reset the TI1S Bit */
N    TIMx->CR2 &= CR2_TI1S_Reset;
X    TIMx->CR2 &= ((u16)0xFF7F);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectOnePulseMode
N* Description    : Selects the TIMxs One Pulse Mode.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - TIM_OPMode: specifies the OPM Mode to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM_OPMode_Single
N*                       - TIM_OPMode_Repetitive
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
X  ((void)0);
N
N  /* Reset the OPM Bit */
N  TIMx->CR1 &= CR1_OPM_Reset;
X  TIMx->CR1 &= ((u16)0x03F7);
N
N  /* Configure the OPM Mode */
N  TIMx->CR1 |= TIM_OPMode;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectOutputTrigger
N* Description    : Selects the TIMx Trigger Output Mode.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - TIM_TRGOSource: specifies the Trigger Output source.
N*                    This paramter can be as follow:
N*                      1/ For TIM1 to TIM8:
N*                       - TIM_TRGOSource_Reset 
N*                       - TIM_TRGOSource_Enable
N*                       - TIM_TRGOSource_Update
N*                      2/ These parameters are available for all TIMx except 
N*                         TIM6 and TIM7:
N*                       - TIM_TRGOSource_OC1
N*                       - TIM_TRGOSource_OC1Ref
N*                       - TIM_TRGOSource_OC2Ref
N*                       - TIM_TRGOSource_OC3Ref
N*                       - TIM_TRGOSource_OC4Ref
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
X  ((void)0);
N  assert_param(IS_TIM_PERIPH_TRGO(TIMx, TIM_TRGOSource));
X  ((void)0);
N
N  /* Reset the MMS Bits */
N  TIMx->CR2 &= CR2_MMS_Mask;
X  TIMx->CR2 &= ((u16)0xFF8F);
N
N  /* Select the TRGO source */
N  TIMx->CR2 |=  TIM_TRGOSource;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectSlaveMode
N* Description    : Selects the TIMx Slave Mode.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_SlaveMode: specifies the Timer Slave Mode.
N*                    This paramter can be one of the following values:
N*                       - TIM_SlaveMode_Reset
N*                       - TIM_SlaveMode_Gated
N*                       - TIM_SlaveMode_Trigger
N*                       - TIM_SlaveMode_External1
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
X  ((void)0);
N
N  /* Reset the SMS Bits */
N  TIMx->SMCR &= SMCR_SMS_Mask;
X  TIMx->SMCR &= ((u16)0xFFF8);
N
N  /* Select the Slave Mode */
N  TIMx->SMCR |= TIM_SlaveMode;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SelectMasterSlaveMode
N* Description    : Sets or Resets the TIMx Master/Slave Mode.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
N*                    This paramter can be one of the following values:
N*                       - TIM_MasterSlaveMode_Enable: synchronization between the
N*                         current timer and its slaves (through TRGO).
N*                       - TIM_MasterSlaveMode_Disable: No action
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
X  ((void)0);
N
N  /* Reset the MSM Bit */
N  TIMx->SMCR &= SMCR_MSM_Reset;
X  TIMx->SMCR &= ((u16)0xFF7F);
N  
N  /* Set or Reset the MSM Bit */
N  TIMx->SMCR |= TIM_MasterSlaveMode;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetCounter
N* Description    : Sets the TIMx Counter Register value
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - Counter: specifies the Counter register new value.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N
N  /* Set the Counter Register value */
N  TIMx->CNT = Counter;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetAutoreload
N* Description    : Sets the TIMx Autoreload Register value
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - Autoreload: specifies the Autoreload register new value.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N
N  /* Set the Autoreload Register value */
N  TIMx->ARR = Autoreload;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetCompare1
N* Description    : Sets the TIMx Capture Compare1 Register value
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - Compare1: specifies the Capture Compare1 register new value.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Set the Capture Compare1 Register value */
N  TIMx->CCR1 = Compare1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetCompare2
N* Description    : Sets the TIMx Capture Compare2 Register value
N* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                   peripheral.
N*                  - Compare2: specifies the Capture Compare2 register new value.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Set the Capture Compare2 Register value */
N  TIMx->CCR2 = Compare2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetCompare3
N* Description    : Sets the TIMx Capture Compare3 Register value
N* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                   peripheral.
N*                  - Compare3: specifies the Capture Compare3 register new value.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Set the Capture Compare3 Register value */
N  TIMx->CCR3 = Compare3;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetCompare4
N* Description    : Sets the TIMx Capture Compare4 Register value
N* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                   peripheral.
N*                  - Compare4: specifies the Capture Compare4 register new value.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Set the Capture Compare4 Register value */
N  TIMx->CCR4 = Compare4;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetIC1Prescaler
N* Description    : Sets the TIMx Input Capture 1 prescaler.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICPSC: specifies the Input Capture1 prescaler
N*                    new value.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICPSC_DIV1: no prescaler
N*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
N*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
N*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
X  ((void)0);
N
N  /* Reset the IC1PSC Bits */
N  TIMx->CCMR1 &= CCMR_IC13PSC_Mask;
X  TIMx->CCMR1 &= ((u16)0xFFF3);
N
N  /* Set the IC1PSC value */
N  TIMx->CCMR1 |= TIM_ICPSC;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetIC2Prescaler
N* Description    : Sets the TIMx Input Capture 2 prescaler.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICPSC: specifies the Input Capture2 prescaler
N*                    new value.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICPSC_DIV1: no prescaler
N*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
N*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
N*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
X  ((void)0);
N
N  /* Reset the IC2PSC Bits */
N  TIMx->CCMR1 &= CCMR_IC24PSC_Mask;
X  TIMx->CCMR1 &= ((u16)0xF3FF);
N
N  /* Set the IC2PSC value */
N  TIMx->CCMR1 |= (u16)(TIM_ICPSC << 8);
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetIC3Prescaler
N* Description    : Sets the TIMx Input Capture 3 prescaler.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICPSC: specifies the Input Capture3 prescaler
N*                    new value.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICPSC_DIV1: no prescaler
N*                       - TIM_ICPSC_DIV2: capture is done once every 2 events
N*                       - TIM_ICPSC_DIV4: capture is done once every 4 events
N*                       - TIM_ICPSC_DIV8: capture is done once every 8 events
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
X  ((void)0);
N
N  /* Reset the IC3PSC Bits */
N  TIMx->CCMR2 &= CCMR_IC13PSC_Mask;
X  TIMx->CCMR2 &= ((u16)0xFFF3);
N
N  /* Set the IC3PSC value */
N  TIMx->CCMR2 |= TIM_ICPSC;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetIC4Prescaler
N* Description    : Sets the TIMx Input Capture 4 prescaler.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICPSC: specifies the Input Capture4 prescaler
N*                    new value.
N*                    This parameter can be one of the following values:
N*                      - TIM_ICPSC_DIV1: no prescaler
N*                      - TIM_ICPSC_DIV2: capture is done once every 2 events
N*                      - TIM_ICPSC_DIV4: capture is done once every 4 events
N*                      - TIM_ICPSC_DIV8: capture is done once every 8 events
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_ICPSC)
N{  
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
X  ((void)0);
N
N  /* Reset the IC4PSC Bits */
N  TIMx->CCMR2 &= CCMR_IC24PSC_Mask;
X  TIMx->CCMR2 &= ((u16)0xF3FF);
N
N  /* Set the IC4PSC value */
N  TIMx->CCMR2 |= (u16)(TIM_ICPSC << 8);
N}
N
N/*******************************************************************************
N* Function Name  : TIM_SetClockDivision
N* Description    : Sets the TIMx Clock Division value.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_CKD: specifies the clock division value.
N*                    This parameter can be one of the following value:
N*                       - TIM_CKD_DIV1: TDTS = Tck_tim
N*                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
N*                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_CKD_DIV(TIM_CKD));
X  ((void)0);
N
N  /* Reset the CKD Bits */
N  TIMx->CR1 &= CR1_CKD_Mask;
X  TIMx->CR1 &= ((u16)0x00FF);
N
N  /* Set the CKD value */
N  TIMx->CR1 |= TIM_CKD;
N}
N/*******************************************************************************
N* Function Name  : TIM_GetCapture1
N* Description    : Gets the TIMx Input Capture 1 value.
N* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                   peripheral.
N* Output         : None
N* Return         : Capture Compare 1 Register value.
N*******************************************************************************/
Nu16 TIM_GetCapture1(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Get the Capture 1 Register value */
N  return TIMx->CCR1;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_GetCapture2
N* Description    : Gets the TIMx Input Capture 2 value.
N* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                   peripheral.
N* Output         : None
N* Return         : Capture Compare 2 Register value.
N*******************************************************************************/
Nu16 TIM_GetCapture2(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Get the Capture 2 Register value */
N  return TIMx->CCR2;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_GetCapture3
N* Description    : Gets the TIMx Input Capture 3 value.
N* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                   peripheral.
N* Output         : None
N* Return         : Capture Compare 3 Register value.
N*******************************************************************************/
Nu16 TIM_GetCapture3(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx)); 
X  ((void)0); 
N
N  /* Get the Capture 3 Register value */
N  return TIMx->CCR3;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_GetCapture4
N* Description    : Gets the TIMx Input Capture 4 value.
N* Input          :  TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                   peripheral.
N* Output         : None
N* Return         : Capture Compare 4 Register value.
N*******************************************************************************/
Nu16 TIM_GetCapture4(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_123458_PERIPH(TIMx));
X  ((void)0);
N
N  /* Get the Capture 4 Register value */
N  return TIMx->CCR4;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_GetCounter
N* Description    : Gets the TIMx Counter value.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N* Output         : None
N* Return         : Counter Register value.
N*******************************************************************************/
Nu16 TIM_GetCounter(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N
N  /* Get the Counter Register value */
N  return TIMx->CNT;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_GetPrescaler
N* Description    : Gets the TIMx Prescaler value.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N* Output         : None
N* Return         : Prescaler Register value.
N*******************************************************************************/
Nu16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N
N  /* Get the Prescaler Register value */
N  return TIMx->PSC;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_GetFlagStatus
N* Description    : Checks whether the specified TIM flag is set or not.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - TIM_FLAG: specifies the flag to check.
N*                    This parameter can be one of the following values:
N*                       - TIM_FLAG_Update: TIM update Flag
N*                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
N*                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
N*                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
N*                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
N*                       - TIM_FLAG_COM: TIM Commutation Flag
N*                       - TIM_FLAG_Trigger: TIM Trigger Flag
N*                       - TIM_FLAG_Break: TIM Break Flag
N*                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
N*                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
N*                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
N*                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
N* Output         : None
N* Return         : The new state of TIM_FLAG (SET or RESET).
N*******************************************************************************/
NFlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
N{ 
N  ITStatus bitstatus = RESET;  
N
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
X  ((void)0);
N  assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
X  ((void)0);
N  
N  if ((TIMx->SR & TIM_FLAG) != (u16)RESET)
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  return bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ClearFlag
N* Description    : Clears the TIMx's pending flags.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - TIM_FLAG: specifies the flag bit to clear.
N*                    This parameter can be any combination of the following values:
N*                       - TIM_FLAG_Update: TIM update Flag
N*                       - TIM_FLAG_CC1: TIM Capture Compare 1 Flag
N*                       - TIM_FLAG_CC2: TIM Capture Compare 2 Flag
N*                       - TIM_FLAG_CC3: TIM Capture Compare 3 Flag
N*                       - TIM_FLAG_CC4: TIM Capture Compare 4 Flag
N*                       - TIM_FLAG_COM: TIM Commutation Flag
N*                       - TIM_FLAG_Trigger: TIM Trigger Flag
N*                       - TIM_FLAG_Break: TIM Break Flag
N*                       - TIM_FLAG_CC1OF: TIM Capture Compare 1 overcapture Flag
N*                       - TIM_FLAG_CC2OF: TIM Capture Compare 2 overcapture Flag
N*                       - TIM_FLAG_CC3OF: TIM Capture Compare 3 overcapture Flag
N*                       - TIM_FLAG_CC4OF: TIM Capture Compare 4 overcapture Flag
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
N{  
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_CLEAR_FLAG(TIMx, TIM_FLAG));
X  ((void)0);
N  assert_param(IS_TIM_PERIPH_FLAG(TIMx, TIM_FLAG));
X  ((void)0);
N   
N  /* Clear the flags */
N  TIMx->SR = (u16)~TIM_FLAG;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_GetITStatus
N* Description    : Checks whether the TIM interrupt has occurred or not.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - TIM_IT: specifies the TIM interrupt source to check.
N*                    This parameter can be one of the following values:
N*                       - TIM_IT_Update: TIM update Interrupt source
N*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
N*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
N*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
N*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
N*                       - TIM_IT_COM: TIM Commutation Interrupt
N*                         source
N*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
N*                       - TIM_IT_Break: TIM Break Interrupt source
N* Output         : None
N* Return         : The new state of the TIM_IT(SET or RESET).
N*******************************************************************************/
NITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
N{
N  ITStatus bitstatus = RESET;  
N  u16 itstatus = 0x0, itenable = 0x0;
N
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_GET_IT(TIM_IT));
X  ((void)0);
N  assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
X  ((void)0);
N   
N  itstatus = TIMx->SR & TIM_IT;
N  
N  itenable = TIMx->DIER & TIM_IT;
N
N  if ((itstatus != (u16)RESET) && (itenable != (u16)RESET))
N  {
N    bitstatus = SET;
N  }
N  else
N  {
N    bitstatus = RESET;
N  }
N  return bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : TIM_ClearITPendingBit
N* Description    : Clears the TIMx's interrupt pending bits.
N* Input          : - TIMx: where x can be 1 to 8 to select the TIM peripheral.
N*                  - TIM_IT: specifies the pending bit to clear.
N*                    This parameter can be any combination of the following values:
N*                       - TIM_IT_Update: TIM1 update Interrupt source
N*                       - TIM_IT_CC1: TIM Capture Compare 1 Interrupt source
N*                       - TIM_IT_CC2: TIM Capture Compare 2 Interrupt source
N*                       - TIM_IT_CC3: TIM Capture Compare 3 Interrupt source
N*                       - TIM_IT_CC4: TIM Capture Compare 4 Interrupt source
N*                       - TIM_IT_COM: TIM Commutation Interrupt
N*                         source
N*                       - TIM_IT_Trigger: TIM Trigger Interrupt source
N*                       - TIM_IT_Break: TIM Break Interrupt source
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
N{
N  /* Check the parameters */
N  assert_param(IS_TIM_ALL_PERIPH(TIMx));
X  ((void)0);
N  assert_param(IS_TIM_PERIPH_IT(TIMx, TIM_IT));
X  ((void)0);
N
N  /* Clear the IT pending Bit */
N  TIMx->SR = (u16)~TIM_IT;
N}
N
N/*******************************************************************************
N* Function Name  : TI1_Config
N* Description    : Configure the TI1 as Input.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICPolarity : The Input Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICPolarity_Rising
N*                       - TIM_ICPolarity_Falling
N*                  - TIM_ICSelection: specifies the input to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
N*                         be connected to IC1.
N*                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
N*                         be connected to IC2.
N*                       - TIM_ICSelection_TRC: TIM Input 1 is selected to be
N*                         connected to TRC.
N*                  - TIM_ICFilter: Specifies the Input Capture Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nstatic void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
N                       u16 TIM_ICFilter)
N{
N  u16 tmpccmr1 = 0, tmpccer = 0;
N
N  /* Disable the Channel 1: Reset the CC1E Bit */
N  TIMx->CCER &= CCER_CC1E_Reset;
X  TIMx->CCER &= ((u16)0xFFFE);
N
N  tmpccmr1 = TIMx->CCMR1;
N  tmpccer = TIMx->CCER;
N
N  /* Select the Input and set the filter */
N  tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
X  tmpccmr1 &= ((u16)0xFFFC) & ((u16)0xFF0F);
N  tmpccmr1 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
N
N  /* Select the Polarity and set the CC1E Bit */
N  tmpccer &= CCER_CC1P_Reset;
X  tmpccer &= ((u16)0xFFFD);
N  tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
X  tmpccer |= TIM_ICPolarity | ((u16)0x0001);
N
N  /* Write to TIMx CCMR1 and CCER registers */
N  TIMx->CCMR1 = tmpccmr1;
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TI2_Config
N* Description    : Configure the TI2 as Input.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICPolarity : The Input Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICPolarity_Rising
N*                       - TIM_ICPolarity_Falling
N*                  - TIM_ICSelection: specifies the input to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
N*                         be connected to IC2.
N*                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
N*                         be connected to IC1.
N*                       - TIM_ICSelection_TRC: TIM Input 2 is selected to be
N*                         connected to TRC.
N*                  - TIM_ICFilter: Specifies the Input Capture Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nstatic void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
N                       u16 TIM_ICFilter)
N{
N  u16 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
N
N  /* Disable the Channel 2: Reset the CC2E Bit */
N  TIMx->CCER &= CCER_CC2E_Reset;
X  TIMx->CCER &= ((u16)0xFFEF);
N
N  tmpccmr1 = TIMx->CCMR1;
N  tmpccer = TIMx->CCER;
N  tmp = (u16)(TIM_ICPolarity << 4);
N
N  /* Select the Input and set the filter */
N  tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
X  tmpccmr1 &= ((u16)0xFCFF) & ((u16)0x0FFF);
N  tmpccmr1 |= (u16)(TIM_ICFilter << 12);
N  tmpccmr1 |= (u16)(TIM_ICSelection << 8);
N
N  /* Select the Polarity and set the CC2E Bit */
N  tmpccer &= CCER_CC2P_Reset;
X  tmpccer &= ((u16)0xFFDF);
N  tmpccer |=  tmp | CCER_CC2E_Set;
X  tmpccer |=  tmp | ((u16)0x0010);
N
N  /* Write to TIMx CCMR1 and CCER registers */
N  TIMx->CCMR1 = tmpccmr1 ;
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TI3_Config
N* Description    : Configure the TI3 as Input.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICPolarity : The Input Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICPolarity_Rising
N*                       - TIM_ICPolarity_Falling
N*                  - TIM_ICSelection: specifies the input to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
N*                         be connected to IC3.
N*                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
N*                         be connected to IC4.
N*                       - TIM_ICSelection_TRC: TIM Input 3 is selected to be
N*                         connected to TRC.
N*                  - TIM_ICFilter: Specifies the Input Capture Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nstatic void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
N                       u16 TIM_ICFilter)
N{
N  u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
N
N  /* Disable the Channel 3: Reset the CC3E Bit */
N  TIMx->CCER &= CCER_CC3E_Reset;
X  TIMx->CCER &= ((u16)0xFEFF);
N
N  tmpccmr2 = TIMx->CCMR2;
N  tmpccer = TIMx->CCER;
N  tmp = (u16)(TIM_ICPolarity << 8);
N
N  /* Select the Input and set the filter */
N  tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
X  tmpccmr2 &= ((u16)0xFFFC) & ((u16)0xFF0F);
N  tmpccmr2 |= TIM_ICSelection | (u16)(TIM_ICFilter << 4);
N
N  /* Select the Polarity and set the CC3E Bit */
N  tmpccer &= CCER_CC3P_Reset;
X  tmpccer &= ((u16)0xFDFF);
N  tmpccer |= tmp | CCER_CC3E_Set;
X  tmpccer |= tmp | ((u16)0x0100);
N
N  /* Write to TIMx CCMR2 and CCER registers */
N  TIMx->CCMR2 = tmpccmr2;
N  TIMx->CCER = tmpccer;
N}
N
N/*******************************************************************************
N* Function Name  : TI4_Config
N* Description    : Configure the TI1 as Input.
N* Input          : - TIMx: where x can be 1, 2, 3, 4, 5 or 8 to select the TIM 
N*                    peripheral.
N*                  - TIM_ICPolarity : The Input Polarity.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICPolarity_Rising
N*                       - TIM_ICPolarity_Falling
N*                  - TIM_ICSelection: specifies the input to be used.
N*                    This parameter can be one of the following values:
N*                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
N*                         be connected to IC4.
N*                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
N*                         be connected to IC3.
N*                       - TIM_ICSelection_TRC: TIM Input 4 is selected to be
N*                         connected to TRC.
N*                  - TIM_ICFilter: Specifies the Input Capture Filter.
N*                    This parameter must be a value between 0x00 and 0x0F.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nstatic void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
N                       u16 TIM_ICFilter)
N{
N  u16 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
N
N  /* Disable the Channel 4: Reset the CC4E Bit */
N  TIMx->CCER &= CCER_CC4E_Reset;
X  TIMx->CCER &= ((u16)0xEFFF);
N
N  tmpccmr2 = TIMx->CCMR2;
N  tmpccer = TIMx->CCER;
N  tmp = (u16)(TIM_ICPolarity << 12);
N
N  /* Select the Input and set the filter */
N  tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
X  tmpccmr2 &= ((u16)0xFCFF) & ((u16)0x0FFF);
N  tmpccmr2 |= (u16)(TIM_ICSelection << 8) | (u16)(TIM_ICFilter << 12);
N
N  /* Select the Polarity and set the CC4E Bit */
N  tmpccer &= CCER_CC4P_Reset;
X  tmpccer &= ((u16)0xDFFF);
N  tmpccer |= tmp | CCER_CC4E_Set;
X  tmpccer |= tmp | ((u16)0x1000);
N
N  /* Write to TIMx CCMR2 and CCER registers */
N  TIMx->CCMR2 = tmpccmr2;
N  TIMx->CCER = tmpccer ;
N}
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
