L 1 "..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_adc.c"
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_adc.c
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file provides all the ADC firmware functions.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_adc.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_adc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_adc.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      ADC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_ADC_H
N#define __STM32F10x_ADC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_map.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_map.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the peripheral register's definitions
N*                      and memory mapping.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_MAP_H
N#define __STM32F10x_MAP_H
N
N#ifndef EXT
N  #define EXT extern
N#endif /* EXT */
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_conf.h"
L 1 ".\stm32f10x_conf.h" 1
N/******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
N* File Name          : stm32f10x_conf.h
N* Author             : MCD Application Team
N* Date First Issued  : 05/21/2007
N* Description        : Library configuration file.
N********************************************************************************
N* History:
N* 05/21/2007: V0.1
N********************************************************************************
N* THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_CONF_H
N#define __STM32F10x_CONF_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_type.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_type.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the common data types used for the
N*                      STM32F10x firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_TYPE_H
N#define __STM32F10x_TYPE_H
N
N/* Includes ------------------------------------------------------------------*/
N/* Exported types ------------------------------------------------------------*/
Ntypedef signed long  s32;
Ntypedef signed short s16;
Ntypedef signed char  s8;
N
Ntypedef signed long  const sc32;  /* Read Only */
Ntypedef signed short const sc16;  /* Read Only */
Ntypedef signed char  const sc8;   /* Read Only */
N
Ntypedef volatile signed long  vs32;
Ntypedef volatile signed short vs16;
Ntypedef volatile signed char  vs8;
N
Ntypedef volatile signed long  const vsc32;  /* Read Only */
Ntypedef volatile signed short const vsc16;  /* Read Only */
Ntypedef volatile signed char  const vsc8;   /* Read Only */
N
Ntypedef unsigned long  u32;
Ntypedef unsigned short u16;
Ntypedef unsigned char  u8;
N
Ntypedef unsigned long  const uc32;  /* Read Only */
Ntypedef unsigned short const uc16;  /* Read Only */
Ntypedef unsigned char  const uc8;   /* Read Only */
N
Ntypedef volatile unsigned long  vu32;
Ntypedef volatile unsigned short vu16;
Ntypedef volatile unsigned char  vu8;
N
Ntypedef volatile unsigned long  const vuc32;  /* Read Only */
Ntypedef volatile unsigned short const vuc16;  /* Read Only */
Ntypedef volatile unsigned char  const vuc8;   /* Read Only */
N
Ntypedef enum {FALSE = 0, TRUE = !FALSE} bool;
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
N
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))
N
Ntypedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;
N
N#define U8_MAX     ((u8)255)
N#define S8_MAX     ((s8)127)
N#define S8_MIN     ((s8)-128)
N#define U16_MAX    ((u16)65535u)
N#define S16_MAX    ((s16)32767)
N#define S16_MIN    ((s16)-32768)
N#define U32_MAX    ((u32)4294967295uL)
N#define S32_MAX    ((s32)2147483647)
N#define S32_MIN    ((s32)-2147483648)
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_TYPE_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 24 ".\stm32f10x_conf.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Uncomment the line below to compile the library in DEBUG mode, this will expanse
N   the "assert" macro in the firmware library code (see "Exported macro" section below) */
N//#define DEBUG
N
N/* Comment the line below to disable the specific peripheral inclusion */
N/************************************* ADC ************************************/
N#define _ADC
N#define _ADC1
N#define _ADC2
N
N/************************************* BKP ************************************/
N#define _BKP
N
N/************************************* CAN ************************************/
N//#define _CAN
N
N/************************************* DMA ************************************/
N//#define _DMA
N//#define _DMA_Channel1
N//#define _DMA_Channel2
N//#define _DMA_Channel3
N//#define _DMA_Channel4
N//#define _DMA_Channel5
N//#define _DMA_Channel6
N//#define _DMA_Channel7
N
N/************************************* EXTI ***********************************/
N#define _EXTI
N
N/************************************* FLASH and Option Bytes *****************/
N#define _FLASH
N/* Uncomment the line below to enable FLASH program/erase/protections functions,
N   otherwise only FLASH configuration (latency, prefetch, half cycle) functions
N   are enabled */
N//#define _FLASH_PROG
N
N/************************************* GPIO ***********************************/
N#define _GPIO
N#define _GPIOA
N#define _GPIOB
N#define _GPIOC
N#define _GPIOD
N#define _GPIOE
N#define _AFIO
N
N/************************************* I2C ************************************/
N#define _I2C
N#define _I2C1
N//#define _I2C2
N
N/************************************* IWDG ***********************************/
N//#define _IWDG
N
N/************************************* NVIC ***********************************/
N#define _NVIC
N
N/************************************* PWR ************************************/
N#define _PWR
N
N/************************************* RCC ************************************/
N#define _RCC
N
N/************************************* RTC ************************************/
N#define _RTC
N
N/************************************* SPI ************************************/
N#define _SPI
N#define _SPI1
N#define _SPI2
N
N/************************************* SysTick ********************************/
N#define _SysTick
N
N/************************************* TIM1 ***********************************/
N#define _TIM1
N
N/************************************* TIM ************************************/
N#define _TIM
N#define _TIM2
N//#define _TIM3
N#define _TIM4
N
N/************************************* USART **********************************/
N#define _USART
N#define _USART1
N#define _USART2
N#define _USART3
N
N/************************************* WWDG ***********************************/
N//#define _WWDG
N
N/* In the following line adjust the value of External High Speed oscillator (HSE)
N   used in your application */
N#define HSE_Value    ((u32)8000000) /* Value of the External oscillator in Hz*/
N
N/* Exported macro ------------------------------------------------------------*/
N#undef assert
N#ifdef  DEBUG
S/*******************************************************************************
S* Macro Name     : assert
S* Description    : The assert macro is used for function's parameters check.
S*                  It is used only if the library is compiled in DEBUG mode.
S* Input          : - expr: If expr is false, it calls assert_failed function
S*                    which reports the name of the source file and the source
S*                    line number of the call that failed.
S*                    If expr is true, it returns no value.
S* Return         : None
S*******************************************************************************/
S  #define assert_param(expr) ((expr) ? (void)0 : assert_failed((u8 *)__FILE__, __LINE__))
S/* Exported functions ------------------------------------------------------- */
S  void assert_failed(u8* file, u32 line);
N#else
N  #define assert_param(expr) ((void)0)
N#endif /* DEBUG */
N
N#endif /* __STM32F10x_CONF_H */
N
N/******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
L 29 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_map.h" 2
N#include "stm32f10x_type.h"
N#include "cortexm3_macro.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\cortexm3_macro.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : cortexm3_macro.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : Header file for cortexm3_macro.s.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __CORTEXM3_MACRO_H
N#define __CORTEXM3_MACRO_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_type.h"
N
N/* Exported types ------------------------------------------------------------*/
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid __WFI(void);
Nvoid __WFE(void);
Nvoid __SEV(void);
Nvoid __ISB(void);
Nvoid __DSB(void);
Nvoid __DMB(void);
Nvoid __SVC(void);
Nu32 __MRS_CONTROL(void);
Nvoid __MSR_CONTROL(u32 Control);
Nu32 __MRS_PSP(void);
Nvoid __MSR_PSP(u32 TopOfProcessStack);
Nu32 __MRS_MSP(void);
Nvoid __MSR_MSP(u32 TopOfMainStack);
Nvoid __RESETPRIMASK(void);
Nvoid __SETPRIMASK(void);
Nu32 __READ_PRIMASK(void);
Nvoid __RESETFAULTMASK(void);
Nvoid __SETFAULTMASK(void);
Nu32 __READ_FAULTMASK(void);
Nvoid __BASEPRICONFIG(u32 NewPriority);
Nu32 __GetBASEPRI(void);
Nu16 __REV_HalfWord(u16 Data);
Nu32 __REV_Word(u32 Data);
N
N#endif /* __CORTEXM3_MACRO_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 31 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_map.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/******************************************************************************/
N/*                         Peripheral registers structures                    */
N/******************************************************************************/
N
N/*------------------------ Analog to Digital Converter -----------------------*/
Ntypedef struct
N{
N  vu32 SR;
N  vu32 CR1;
N  vu32 CR2;
N  vu32 SMPR1;
N  vu32 SMPR2;
N  vu32 JOFR1;
N  vu32 JOFR2;
N  vu32 JOFR3;
N  vu32 JOFR4;
N  vu32 HTR;
N  vu32 LTR;
N  vu32 SQR1;
N  vu32 SQR2;
N  vu32 SQR3;
N  vu32 JSQR;
N  vu32 JDR1;
N  vu32 JDR2;
N  vu32 JDR3;
N  vu32 JDR4;
N  vu32 DR;
N} ADC_TypeDef;
N
N/*------------------------ Backup Registers ----------------------------------*/
Ntypedef struct
N{
N  u32  RESERVED0;
N  vu16 DR1;
N  u16  RESERVED1;
N  vu16 DR2;
N  u16  RESERVED2;
N  vu16 DR3;
N  u16  RESERVED3;
N  vu16 DR4;
N  u16  RESERVED4;
N  vu16 DR5;
N  u16  RESERVED5;
N  vu16 DR6;
N  u16  RESERVED6;
N  vu16 DR7;
N  u16  RESERVED7;
N  vu16 DR8;
N  u16  RESERVED8;
N  vu16 DR9;
N  u16  RESERVED9;
N  vu16 DR10;
N  u16  RESERVED10; 
N  vu16 RTCCR;
N  u16  RESERVED11;
N  vu16 CR;
N  u16  RESERVED12;
N  vu16 CSR;
N  u16  RESERVED13[5];
N  vu16 DR11;
N  u16  RESERVED14;
N  vu16 DR12;
N  u16  RESERVED15;
N  vu16 DR13;
N  u16  RESERVED16;
N  vu16 DR14;
N  u16  RESERVED17;
N  vu16 DR15;
N  u16  RESERVED18;
N  vu16 DR16;
N  u16  RESERVED19;
N  vu16 DR17;
N  u16  RESERVED20;
N  vu16 DR18;
N  u16  RESERVED21;
N  vu16 DR19;
N  u16  RESERVED22;
N  vu16 DR20;
N  u16  RESERVED23;
N  vu16 DR21;
N  u16  RESERVED24;
N  vu16 DR22;
N  u16  RESERVED25;
N  vu16 DR23;
N  u16  RESERVED26;
N  vu16 DR24;
N  u16  RESERVED27;
N  vu16 DR25;
N  u16  RESERVED28;
N  vu16 DR26;
N  u16  RESERVED29;
N  vu16 DR27;
N  u16  RESERVED30;
N  vu16 DR28;
N  u16  RESERVED31;
N  vu16 DR29;
N  u16  RESERVED32;
N  vu16 DR30;
N  u16  RESERVED33; 
N  vu16 DR31;
N  u16  RESERVED34;
N  vu16 DR32;
N  u16  RESERVED35;
N  vu16 DR33;
N  u16  RESERVED36;
N  vu16 DR34;
N  u16  RESERVED37;
N  vu16 DR35;
N  u16  RESERVED38;
N  vu16 DR36;
N  u16  RESERVED39;
N  vu16 DR37;
N  u16  RESERVED40;
N  vu16 DR38;
N  u16  RESERVED41;
N  vu16 DR39;
N  u16  RESERVED42;
N  vu16 DR40;
N  u16  RESERVED43;
N  vu16 DR41;
N  u16  RESERVED44;
N  vu16 DR42;
N  u16  RESERVED45;    
N} BKP_TypeDef;
N
N/*------------------------ Controller Area Network ---------------------------*/
Ntypedef struct
N{
N  vu32 TIR;
N  vu32 TDTR;
N  vu32 TDLR;
N  vu32 TDHR;
N} CAN_TxMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 RIR;
N  vu32 RDTR;
N  vu32 RDLR;
N  vu32 RDHR;
N} CAN_FIFOMailBox_TypeDef;
N
Ntypedef struct
N{
N  vu32 FR1;
N  vu32 FR2;
N} CAN_FilterRegister_TypeDef;
N
Ntypedef struct
N{
N  vu32 MCR;
N  vu32 MSR;
N  vu32 TSR;
N  vu32 RF0R;
N  vu32 RF1R;
N  vu32 IER;
N  vu32 ESR;
N  vu32 BTR;
N  u32  RESERVED0[88];
N  CAN_TxMailBox_TypeDef sTxMailBox[3];
N  CAN_FIFOMailBox_TypeDef sFIFOMailBox[2];
N  u32  RESERVED1[12];
N  vu32 FMR;
N  vu32 FM1R;
N  u32  RESERVED2;
N  vu32 FS1R;
N  u32  RESERVED3;
N  vu32 FFA1R;
N  u32  RESERVED4;
N  vu32 FA1R;
N  u32  RESERVED5[8];
N  CAN_FilterRegister_TypeDef sFilterRegister[14];
N} CAN_TypeDef;
N
N/*------------------------ CRC calculation unit ------------------------------*/
Ntypedef struct
N{
N  vu32 DR;
N  vu8  IDR;
N  u8   RESERVED0;
N  u16  RESERVED1;
N  vu32 CR;
N} CRC_TypeDef;
N
N
N/*------------------------ Digital to Analog Converter -----------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 SWTRIGR;
N  vu32 DHR12R1;
N  vu32 DHR12L1;
N  vu32 DHR8R1;
N  vu32 DHR12R2;
N  vu32 DHR12L2;
N  vu32 DHR8R2;
N  vu32 DHR12RD;
N  vu32 DHR12LD;
N  vu32 DHR8RD;
N  vu32 DOR1;
N  vu32 DOR2;
N} DAC_TypeDef;
N
N/*------------------------ Debug MCU -----------------------------------------*/
Ntypedef struct
N{
N  vu32 IDCODE;
N  vu32 CR;	
N}DBGMCU_TypeDef;
N
N/*------------------------ DMA Controller ------------------------------------*/
Ntypedef struct
N{
N  vu32 CCR;
N  vu32 CNDTR;
N  vu32 CPAR;
N  vu32 CMAR;
N} DMA_Channel_TypeDef;
N
Ntypedef struct
N{
N  vu32 ISR;
N  vu32 IFCR;
N} DMA_TypeDef;
N
N/*------------------------ External Interrupt/Event Controller ---------------*/
Ntypedef struct
N{
N  vu32 IMR;
N  vu32 EMR;
N  vu32 RTSR;
N  vu32 FTSR;
N  vu32 SWIER;
N  vu32 PR;
N} EXTI_TypeDef;
N
N/*------------------------ FLASH and Option Bytes Registers ------------------*/
Ntypedef struct
N{
N  vu32 ACR;
N  vu32 KEYR;
N  vu32 OPTKEYR;
N  vu32 SR;
N  vu32 CR;
N  vu32 AR;
N  vu32 RESERVED;
N  vu32 OBR;
N  vu32 WRPR;
N} FLASH_TypeDef;
N
Ntypedef struct
N{
N  vu16 RDP;
N  vu16 USER;
N  vu16 Data0;
N  vu16 Data1;
N  vu16 WRP0;
N  vu16 WRP1;
N  vu16 WRP2;
N  vu16 WRP3;
N} OB_TypeDef;
N
N/*------------------------ Flexible Static Memory Controller -----------------*/
Ntypedef struct
N{
N  vu32 BTCR[8];   
N} FSMC_Bank1_TypeDef; 
N
Ntypedef struct
N{
N  vu32 BWTR[7];
N} FSMC_Bank1E_TypeDef;
N
Ntypedef struct
N{
N  vu32 PCR2;
N  vu32 SR2;
N  vu32 PMEM2;
N  vu32 PATT2;
N  u32  RESERVED0;   
N  vu32 ECCR2; 
N} FSMC_Bank2_TypeDef;  
N
Ntypedef struct
N{
N  vu32 PCR3;
N  vu32 SR3;
N  vu32 PMEM3;
N  vu32 PATT3;
N  u32  RESERVED0;   
N  vu32 ECCR3; 
N} FSMC_Bank3_TypeDef; 
N
Ntypedef struct
N{
N  vu32 PCR4;
N  vu32 SR4;
N  vu32 PMEM4;
N  vu32 PATT4;
N  vu32 PIO4; 
N} FSMC_Bank4_TypeDef; 
N
N/*------------------------ General Purpose and Alternate Function IO ---------*/
Ntypedef struct
N{
N  vu32 CRL;
N  vu32 CRH;
N  vu32 IDR;
N  vu32 ODR;
N  vu32 BSRR;
N  vu32 BRR;
N  vu32 LCKR;
N} GPIO_TypeDef;
N
Ntypedef struct
N{
N  vu32 EVCR;
N  vu32 MAPR;
N  vu32 EXTICR[4];
N} AFIO_TypeDef;
N
N/*------------------------ Inter-integrated Circuit Interface ----------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 OAR1;
N  u16  RESERVED2;
N  vu16 OAR2;
N  u16  RESERVED3;
N  vu16 DR;
N  u16  RESERVED4;
N  vu16 SR1;
N  u16  RESERVED5;
N  vu16 SR2;
N  u16  RESERVED6;
N  vu16 CCR;
N  u16  RESERVED7;
N  vu16 TRISE;
N  u16  RESERVED8;
N} I2C_TypeDef;
N
N/*------------------------ Independent WATCHDOG ------------------------------*/
Ntypedef struct
N{
N  vu32 KR;
N  vu32 PR;
N  vu32 RLR;
N  vu32 SR;
N} IWDG_TypeDef;
N
N/*------------------------ Nested Vectored Interrupt Controller --------------*/
Ntypedef struct
N{
N  vu32 ISER[2];
N  u32  RESERVED0[30];
N  vu32 ICER[2];
N  u32  RSERVED1[30];
N  vu32 ISPR[2];
N  u32  RESERVED2[30];
N  vu32 ICPR[2];
N  u32  RESERVED3[30];
N  vu32 IABR[2];
N  u32  RESERVED4[62];
N  vu32 IPR[15];
N} NVIC_TypeDef;
N
Ntypedef struct
N{
N  vuc32 CPUID;
N  vu32 ICSR;
N  vu32 VTOR;
N  vu32 AIRCR;
N  vu32 SCR;
N  vu32 CCR;
N  vu32 SHPR[3];
N  vu32 SHCSR;
N  vu32 CFSR;
N  vu32 HFSR;
N  vu32 DFSR;
N  vu32 MMFAR;
N  vu32 BFAR;
N  vu32 AFSR;
N} SCB_TypeDef;
N
N/*------------------------ Power Control -------------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CSR;
N} PWR_TypeDef;
N
N/*------------------------ Reset and Clock Control ---------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFGR;
N  vu32 CIR;
N  vu32 APB2RSTR;
N  vu32 APB1RSTR;
N  vu32 AHBENR;
N  vu32 APB2ENR;
N  vu32 APB1ENR;
N  vu32 BDCR;
N  vu32 CSR;
N} RCC_TypeDef;
N
N/*------------------------ Real-Time Clock -----------------------------------*/
Ntypedef struct
N{
N  vu16 CRH;
N  u16  RESERVED0;
N  vu16 CRL;
N  u16  RESERVED1;
N  vu16 PRLH;
N  u16  RESERVED2;
N  vu16 PRLL;
N  u16  RESERVED3;
N  vu16 DIVH;
N  u16  RESERVED4;
N  vu16 DIVL;
N  u16  RESERVED5;
N  vu16 CNTH;
N  u16  RESERVED6;
N  vu16 CNTL;
N  u16  RESERVED7;
N  vu16 ALRH;
N  u16  RESERVED8;
N  vu16 ALRL;
N  u16  RESERVED9;
N} RTC_TypeDef;
N
N/*------------------------ SD host Interface ---------------------------------*/
Ntypedef struct
N{
N  vu32 POWER;
N  vu32 CLKCR;
N  vu32 ARG;
N  vu32 CMD;
N  vuc32 RESPCMD;
N  vuc32 RESP1;
N  vuc32 RESP2;
N  vuc32 RESP3;
N  vuc32 RESP4;
N  vu32 DTIMER;
N  vu32 DLEN;
N  vu32 DCTRL;
N  vuc32 DCOUNT;
N  vuc32 STA;
N  vu32 ICR;
N  vu32 MASK;
N  u32  RESERVED0[2];
N  vuc32 FIFOCNT;
N  u32  RESERVED1[13];
N  vu32 FIFO;
N} SDIO_TypeDef;
N
N/*------------------------ Serial Peripheral Interface -----------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SR;
N  u16  RESERVED2;
N  vu16 DR;
N  u16  RESERVED3;
N  vu16 CRCPR;
N  u16  RESERVED4;
N  vu16 RXCRCR;
N  u16  RESERVED5;
N  vu16 TXCRCR;
N  u16  RESERVED6;
N  vu16 I2SCFGR;
N  u16  RESERVED7;
N  vu16 I2SPR;
N  u16  RESERVED8;  
N} SPI_TypeDef;
N
N/*------------------------ SystemTick ----------------------------------------*/
Ntypedef struct
N{
N  vu32 CTRL;
N  vu32 LOAD;
N  vu32 VAL;
N  vuc32 CALIB;
N} SysTick_TypeDef;
N
N/*------------------------ TIM -----------------------------------------------*/
Ntypedef struct
N{
N  vu16 CR1;
N  u16  RESERVED0;
N  vu16 CR2;
N  u16  RESERVED1;
N  vu16 SMCR;
N  u16  RESERVED2;
N  vu16 DIER;
N  u16  RESERVED3;
N  vu16 SR;
N  u16  RESERVED4;
N  vu16 EGR;
N  u16  RESERVED5;
N  vu16 CCMR1;
N  u16  RESERVED6;
N  vu16 CCMR2;
N  u16  RESERVED7;
N  vu16 CCER;
N  u16  RESERVED8;
N  vu16 CNT;
N  u16  RESERVED9;
N  vu16 PSC;
N  u16  RESERVED10;
N  vu16 ARR;
N  u16  RESERVED11;
N  vu16 RCR;
N  u16  RESERVED12;
N  vu16 CCR1;
N  u16  RESERVED13;
N  vu16 CCR2;
N  u16  RESERVED14;
N  vu16 CCR3;
N  u16  RESERVED15;
N  vu16 CCR4;
N  u16  RESERVED16;
N  vu16 BDTR;
N  u16  RESERVED17;
N  vu16 DCR;
N  u16  RESERVED18;
N  vu16 DMAR;
N  u16  RESERVED19;
N} TIM_TypeDef;
N
N/*----------------- Universal Synchronous Asynchronous Receiver Transmitter --*/
Ntypedef struct
N{
N  vu16 SR;
N  u16  RESERVED0;
N  vu16 DR;
N  u16  RESERVED1;
N  vu16 BRR;
N  u16  RESERVED2;
N  vu16 CR1;
N  u16  RESERVED3;
N  vu16 CR2;
N  u16  RESERVED4;
N  vu16 CR3;
N  u16  RESERVED5;
N  vu16 GTPR;
N  u16  RESERVED6;
N} USART_TypeDef;
N
N/*------------------------ Window WATCHDOG -----------------------------------*/
Ntypedef struct
N{
N  vu32 CR;
N  vu32 CFR;
N  vu32 SR;
N} WWDG_TypeDef;
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Peripheral and SRAM base address in the alias region */
N#define PERIPH_BB_BASE        ((u32)0x42000000)
N#define SRAM_BB_BASE          ((u32)0x22000000)
N
N/* Peripheral and SRAM base address in the bit-band region */
N#define SRAM_BASE             ((u32)0x20000000)
N#define PERIPH_BASE           ((u32)0x40000000)
N
N/* FSMC registers base address */
N#define FSMC_R_BASE           ((u32)0xA0000000)
N
N/* Peripheral memory map */
N#define APB1PERIPH_BASE       PERIPH_BASE
N#define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
N#define AHBPERIPH_BASE        (PERIPH_BASE + 0x20000)
N
N#define TIM2_BASE             (APB1PERIPH_BASE + 0x0000)
N#define TIM3_BASE             (APB1PERIPH_BASE + 0x0400)
N#define TIM4_BASE             (APB1PERIPH_BASE + 0x0800)
N#define TIM5_BASE             (APB1PERIPH_BASE + 0x0C00)
N#define TIM6_BASE             (APB1PERIPH_BASE + 0x1000)
N#define TIM7_BASE             (APB1PERIPH_BASE + 0x1400)
N#define RTC_BASE              (APB1PERIPH_BASE + 0x2800)
N#define WWDG_BASE             (APB1PERIPH_BASE + 0x2C00)
N#define IWDG_BASE             (APB1PERIPH_BASE + 0x3000)
N#define SPI2_BASE             (APB1PERIPH_BASE + 0x3800)
N#define SPI3_BASE             (APB1PERIPH_BASE + 0x3C00)
N#define USART2_BASE           (APB1PERIPH_BASE + 0x4400)
N#define USART3_BASE           (APB1PERIPH_BASE + 0x4800)
N#define UART4_BASE            (APB1PERIPH_BASE + 0x4C00)
N#define UART5_BASE            (APB1PERIPH_BASE + 0x5000)
N#define I2C1_BASE             (APB1PERIPH_BASE + 0x5400)
N#define I2C2_BASE             (APB1PERIPH_BASE + 0x5800)
N#define CAN_BASE              (APB1PERIPH_BASE + 0x6400)
N#define BKP_BASE              (APB1PERIPH_BASE + 0x6C00)
N#define PWR_BASE              (APB1PERIPH_BASE + 0x7000)
N#define DAC_BASE              (APB1PERIPH_BASE + 0x7400)
N
N#define AFIO_BASE             (APB2PERIPH_BASE + 0x0000)
N#define EXTI_BASE             (APB2PERIPH_BASE + 0x0400)
N#define GPIOA_BASE            (APB2PERIPH_BASE + 0x0800)
N#define GPIOB_BASE            (APB2PERIPH_BASE + 0x0C00)
N#define GPIOC_BASE            (APB2PERIPH_BASE + 0x1000)
N#define GPIOD_BASE            (APB2PERIPH_BASE + 0x1400)
N#define GPIOE_BASE            (APB2PERIPH_BASE + 0x1800)
N#define GPIOF_BASE            (APB2PERIPH_BASE + 0x1C00)
N#define GPIOG_BASE            (APB2PERIPH_BASE + 0x2000)
N#define ADC1_BASE             (APB2PERIPH_BASE + 0x2400)
N#define ADC2_BASE             (APB2PERIPH_BASE + 0x2800)
N#define TIM1_BASE             (APB2PERIPH_BASE + 0x2C00)
N#define SPI1_BASE             (APB2PERIPH_BASE + 0x3000)
N#define TIM8_BASE             (APB2PERIPH_BASE + 0x3400)
N#define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
N#define ADC3_BASE             (APB2PERIPH_BASE + 0x3C00)
N
N#define SDIO_BASE             (PERIPH_BASE + 0x18000)
N
N#define DMA1_BASE             (AHBPERIPH_BASE + 0x0000)
N#define DMA1_Channel1_BASE    (AHBPERIPH_BASE + 0x0008)
N#define DMA1_Channel2_BASE    (AHBPERIPH_BASE + 0x001C)
N#define DMA1_Channel3_BASE    (AHBPERIPH_BASE + 0x0030)
N#define DMA1_Channel4_BASE    (AHBPERIPH_BASE + 0x0044)
N#define DMA1_Channel5_BASE    (AHBPERIPH_BASE + 0x0058)
N#define DMA1_Channel6_BASE    (AHBPERIPH_BASE + 0x006C)
N#define DMA1_Channel7_BASE    (AHBPERIPH_BASE + 0x0080)
N#define DMA2_BASE             (AHBPERIPH_BASE + 0x0400)
N#define DMA2_Channel1_BASE    (AHBPERIPH_BASE + 0x0408)
N#define DMA2_Channel2_BASE    (AHBPERIPH_BASE + 0x041C)
N#define DMA2_Channel3_BASE    (AHBPERIPH_BASE + 0x0430)
N#define DMA2_Channel4_BASE    (AHBPERIPH_BASE + 0x0444)
N#define DMA2_Channel5_BASE    (AHBPERIPH_BASE + 0x0458)
N#define RCC_BASE              (AHBPERIPH_BASE + 0x1000)
N#define CRC_BASE              (AHBPERIPH_BASE + 0x3000)
N
N/* Flash registers base address */
N#define FLASH_R_BASE          (AHBPERIPH_BASE + 0x2000)
N/* Flash Option Bytes base address */
N#define OB_BASE               ((u32)0x1FFFF800)
N
N/* FSMC Bankx registers base address */
N#define FSMC_Bank1_R_BASE     (FSMC_R_BASE + 0x0000)
N#define FSMC_Bank1E_R_BASE    (FSMC_R_BASE + 0x0104)
N#define FSMC_Bank2_R_BASE     (FSMC_R_BASE + 0x0060)
N#define FSMC_Bank3_R_BASE     (FSMC_R_BASE + 0x0080)
N#define FSMC_Bank4_R_BASE     (FSMC_R_BASE + 0x00A0)
N
N/* Debug MCU registers base address */
N#define DBGMCU_BASE          ((u32)0xE0042000)
N
N/* System Control Space memory map */
N#define SCS_BASE              ((u32)0xE000E000)
N
N#define SysTick_BASE          (SCS_BASE + 0x0010)
N#define NVIC_BASE             (SCS_BASE + 0x0100)
N#define SCB_BASE              (SCS_BASE + 0x0D00)
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N
N/*------------------------ Non Debug Mode ------------------------------------*/
N#ifndef DEBUG
N#ifdef _TIM2
N  #define TIM2                ((TIM_TypeDef *) TIM2_BASE)
N#endif /*_TIM2 */
N
N#ifdef _TIM3
S  #define TIM3                ((TIM_TypeDef *) TIM3_BASE)
N#endif /*_TIM3 */
N
N#ifdef _TIM4
N  #define TIM4                ((TIM_TypeDef *) TIM4_BASE)
N#endif /*_TIM4 */
N
N#ifdef _TIM5
S  #define TIM5                ((TIM_TypeDef *) TIM5_BASE)
N#endif /*_TIM5 */
N
N#ifdef _TIM6
S  #define TIM6                ((TIM_TypeDef *) TIM6_BASE)
N#endif /*_TIM6 */
N
N#ifdef _TIM7
S  #define TIM7                ((TIM_TypeDef *) TIM7_BASE)
N#endif /*_TIM7 */
N
N#ifdef _RTC
N  #define RTC                 ((RTC_TypeDef *) RTC_BASE)
N#endif /*_RTC */
N
N#ifdef _WWDG
S  #define WWDG                ((WWDG_TypeDef *) WWDG_BASE)
N#endif /*_WWDG */
N
N#ifdef _IWDG
S  #define IWDG                ((IWDG_TypeDef *) IWDG_BASE)
N#endif /*_IWDG */
N
N#ifdef _SPI2
N  #define SPI2                ((SPI_TypeDef *) SPI2_BASE)
N#endif /*_SPI2 */
N
N#ifdef _SPI3
S  #define SPI3                ((SPI_TypeDef *) SPI3_BASE)
N#endif /*_SPI3 */
N
N#ifdef _USART2
N  #define USART2              ((USART_TypeDef *) USART2_BASE)
N#endif /*_USART2 */
N
N#ifdef _USART3
N  #define USART3              ((USART_TypeDef *) USART3_BASE)
N#endif /*_USART3 */
N
N#ifdef _UART4
S  #define UART4              ((USART_TypeDef *) UART4_BASE)
N#endif /*_UART4 */
N
N#ifdef _UART5
S  #define UART5              ((USART_TypeDef *) UART5_BASE)
N#endif /*_USART5 */
N
N#ifdef _I2C1
N  #define I2C1                ((I2C_TypeDef *) I2C1_BASE)
N#endif /*_I2C1 */
N
N#ifdef _I2C2
S  #define I2C2                ((I2C_TypeDef *) I2C2_BASE)
N#endif /*_I2C2 */
N
N#ifdef _CAN
S  #define CAN                 ((CAN_TypeDef *) CAN_BASE)
N#endif /*_CAN */
N
N#ifdef _BKP
N  #define BKP                 ((BKP_TypeDef *) BKP_BASE)
N#endif /*_BKP */
N
N#ifdef _PWR
N  #define PWR                 ((PWR_TypeDef *) PWR_BASE)
N#endif /*_PWR */
N
N#ifdef _DAC
S  #define DAC                 ((DAC_TypeDef *) DAC_BASE)
N#endif /*_DAC */
N
N#ifdef _AFIO
N  #define AFIO                ((AFIO_TypeDef *) AFIO_BASE)
N#endif /*_AFIO */
N
N#ifdef _EXTI
N  #define EXTI                ((EXTI_TypeDef *) EXTI_BASE)
N#endif /*_EXTI */
N
N#ifdef _GPIOA
N  #define GPIOA               ((GPIO_TypeDef *) GPIOA_BASE)
N#endif /*_GPIOA */
N
N#ifdef _GPIOB
N  #define GPIOB               ((GPIO_TypeDef *) GPIOB_BASE)
N#endif /*_GPIOB */
N
N#ifdef _GPIOC
N  #define GPIOC               ((GPIO_TypeDef *) GPIOC_BASE)
N#endif /*_GPIOC */
N
N#ifdef _GPIOD
N  #define GPIOD               ((GPIO_TypeDef *) GPIOD_BASE)
N#endif /*_GPIOD */
N
N#ifdef _GPIOE
N  #define GPIOE               ((GPIO_TypeDef *) GPIOE_BASE)
N#endif /*_GPIOE */
N
N#ifdef _GPIOF
S  #define GPIOF               ((GPIO_TypeDef *) GPIOF_BASE)
N#endif /*_GPIOF */
N
N#ifdef _GPIOG
S  #define GPIOG               ((GPIO_TypeDef *) GPIOG_BASE)
N#endif /*_GPIOG */
N
N#ifdef _ADC1
N  #define ADC1                ((ADC_TypeDef *) ADC1_BASE)
N#endif /*_ADC1 */
N
N#ifdef _ADC2
N  #define ADC2                ((ADC_TypeDef *) ADC2_BASE)
N#endif /*_ADC2 */
N
N#ifdef _TIM1
N  #define TIM1                ((TIM_TypeDef *) TIM1_BASE)
N#endif /*_TIM1 */
N
N#ifdef _SPI1
N  #define SPI1                ((SPI_TypeDef *) SPI1_BASE)
N#endif /*_SPI1 */
N
N#ifdef _TIM8
S  #define TIM8                ((TIM_TypeDef *) TIM8_BASE)
N#endif /*_TIM8 */
N
N#ifdef _USART1
N  #define USART1              ((USART_TypeDef *) USART1_BASE)
N#endif /*_USART1 */
N
N#ifdef _ADC3
S  #define ADC3                ((ADC_TypeDef *) ADC3_BASE)
N#endif /*_ADC3 */
N
N#ifdef _SDIO
S  #define SDIO                ((SDIO_TypeDef *) SDIO_BASE)
N#endif /*_SDIO */
N
N#ifdef _DMA
S  #define DMA1                ((DMA_TypeDef *) DMA1_BASE)
S  #define DMA2                ((DMA_TypeDef *) DMA2_BASE)
N#endif /*_DMA */
N
N#ifdef _DMA1_Channel1
S  #define DMA1_Channel1       ((DMA_Channel_TypeDef *) DMA1_Channel1_BASE)
N#endif /*_DMA1_Channel1 */
N
N#ifdef _DMA1_Channel2
S  #define DMA1_Channel2       ((DMA_Channel_TypeDef *) DMA1_Channel2_BASE)
N#endif /*_DMA1_Channel2 */
N
N#ifdef _DMA1_Channel3
S  #define DMA1_Channel3       ((DMA_Channel_TypeDef *) DMA1_Channel3_BASE)
N#endif /*_DMA1_Channel3 */
N
N#ifdef _DMA1_Channel4
S  #define DMA1_Channel4       ((DMA_Channel_TypeDef *) DMA1_Channel4_BASE)
N#endif /*_DMA1_Channel4 */
N
N#ifdef _DMA1_Channel5
S  #define DMA1_Channel5       ((DMA_Channel_TypeDef *) DMA1_Channel5_BASE)
N#endif /*_DMA1_Channel5 */
N
N#ifdef _DMA1_Channel6
S  #define DMA1_Channel6       ((DMA_Channel_TypeDef *) DMA1_Channel6_BASE)
N#endif /*_DMA1_Channel6 */
N
N#ifdef _DMA1_Channel7
S  #define DMA1_Channel7       ((DMA_Channel_TypeDef *) DMA1_Channel7_BASE)
N#endif /*_DMA1_Channel7 */
N
N#ifdef _DMA2_Channel1
S  #define DMA2_Channel1       ((DMA_Channel_TypeDef *) DMA2_Channel1_BASE)
N#endif /*_DMA2_Channel1 */
N
N#ifdef _DMA2_Channel2
S  #define DMA2_Channel2       ((DMA_Channel_TypeDef *) DMA2_Channel2_BASE)
N#endif /*_DMA2_Channel2 */
N
N#ifdef _DMA2_Channel3
S  #define DMA2_Channel3       ((DMA_Channel_TypeDef *) DMA2_Channel3_BASE)
N#endif /*_DMA2_Channel3 */
N
N#ifdef _DMA2_Channel4
S  #define DMA2_Channel4       ((DMA_Channel_TypeDef *) DMA2_Channel4_BASE)
N#endif /*_DMA2_Channel4 */
N
N#ifdef _DMA2_Channel5
S  #define DMA2_Channel5       ((DMA_Channel_TypeDef *) DMA2_Channel5_BASE)
N#endif /*_DMA2_Channel5 */
N
N#ifdef _RCC
N  #define RCC                 ((RCC_TypeDef *) RCC_BASE)
N#endif /*_RCC */
N
N#ifdef _CRC
S  #define CRC                 ((CRC_TypeDef *) CRC_BASE)
N#endif /*_CRC */
N
N#ifdef _FLASH
N  #define FLASH               ((FLASH_TypeDef *) FLASH_R_BASE)
N  #define OB                  ((OB_TypeDef *) OB_BASE) 
N#endif /*_FLASH */
N
N#ifdef _FSMC
S  #define FSMC_Bank1          ((FSMC_Bank1_TypeDef *) FSMC_Bank1_R_BASE)
S  #define FSMC_Bank1E         ((FSMC_Bank1E_TypeDef *) FSMC_Bank1E_R_BASE)
S  #define FSMC_Bank2          ((FSMC_Bank2_TypeDef *) FSMC_Bank2_R_BASE)
S  #define FSMC_Bank3          ((FSMC_Bank3_TypeDef *) FSMC_Bank3_R_BASE)
S  #define FSMC_Bank4          ((FSMC_Bank4_TypeDef *) FSMC_Bank4_R_BASE)
N#endif /*_FSMC */
N
N#ifdef _DBGMCU
S  #define DBGMCU              ((DBGMCU_TypeDef *) DBGMCU_BASE)
N#endif /*_DBGMCU */
N
N#ifdef _SysTick
N  #define SysTick             ((SysTick_TypeDef *) SysTick_BASE)
N#endif /*_SysTick */
N
N#ifdef _NVIC
N  #define NVIC                ((NVIC_TypeDef *) NVIC_BASE)
N  #define SCB                 ((SCB_TypeDef *) SCB_BASE)  
N#endif /*_NVIC */
N
N/*------------------------ Debug Mode ----------------------------------------*/
N#else   /* DEBUG */
S#ifdef _TIM2
S  EXT TIM_TypeDef             *TIM2;
S#endif /*_TIM2 */
S
S#ifdef _TIM3
S  EXT TIM_TypeDef             *TIM3;
S#endif /*_TIM3 */
S
S#ifdef _TIM4
S  EXT TIM_TypeDef             *TIM4;
S#endif /*_TIM4 */
S
S#ifdef _TIM5
S  EXT TIM_TypeDef             *TIM5;
S#endif /*_TIM5 */
S
S#ifdef _TIM6
S  EXT TIM_TypeDef             *TIM6;
S#endif /*_TIM6 */
S
S#ifdef _TIM7
S  EXT TIM_TypeDef             *TIM7;
S#endif /*_TIM7 */
S
S#ifdef _RTC
S  EXT RTC_TypeDef             *RTC;
S#endif /*_RTC */
S
S#ifdef _WWDG
S  EXT WWDG_TypeDef            *WWDG;
S#endif /*_WWDG */
S
S#ifdef _IWDG
S  EXT IWDG_TypeDef            *IWDG;
S#endif /*_IWDG */
S
S#ifdef _SPI2
S  EXT SPI_TypeDef             *SPI2;
S#endif /*_SPI2 */
S
S#ifdef _SPI3
S  EXT SPI_TypeDef             *SPI3;
S#endif /*_SPI3 */
S
S#ifdef _USART2
S  EXT USART_TypeDef           *USART2;
S#endif /*_USART2 */
S
S#ifdef _USART3
S  EXT USART_TypeDef           *USART3;
S#endif /*_USART3 */
S
S#ifdef _UART4
S  EXT USART_TypeDef           *UART4;
S#endif /*_UART4 */
S
S#ifdef _UART5
S  EXT USART_TypeDef           *UART5;
S#endif /*_UART5 */
S
S#ifdef _I2C1
S  EXT I2C_TypeDef             *I2C1;
S#endif /*_I2C1 */
S
S#ifdef _I2C2
S  EXT I2C_TypeDef             *I2C2;
S#endif /*_I2C2 */
S
S#ifdef _CAN
S  EXT CAN_TypeDef             *CAN;
S#endif /*_CAN */
S
S#ifdef _BKP
S  EXT BKP_TypeDef             *BKP;
S#endif /*_BKP */
S
S#ifdef _PWR
S  EXT PWR_TypeDef             *PWR;
S#endif /*_PWR */
S
S#ifdef _DAC
S  EXT DAC_TypeDef             *DAC;
S#endif /*_DAC */
S
S#ifdef _AFIO
S  EXT AFIO_TypeDef            *AFIO;
S#endif /*_AFIO */
S
S#ifdef _EXTI
S  EXT EXTI_TypeDef            *EXTI;
S#endif /*_EXTI */
S
S#ifdef _GPIOA
S  EXT GPIO_TypeDef            *GPIOA;
S#endif /*_GPIOA */
S
S#ifdef _GPIOB
S  EXT GPIO_TypeDef            *GPIOB;
S#endif /*_GPIOB */
S
S#ifdef _GPIOC
S  EXT GPIO_TypeDef            *GPIOC;
S#endif /*_GPIOC */
S
S#ifdef _GPIOD
S  EXT GPIO_TypeDef            *GPIOD;
S#endif /*_GPIOD */
S
S#ifdef _GPIOE
S  EXT GPIO_TypeDef            *GPIOE;
S#endif /*_GPIOE */
S
S#ifdef _GPIOF
S  EXT GPIO_TypeDef            *GPIOF;
S#endif /*_GPIOF */
S
S#ifdef _GPIOG
S  EXT GPIO_TypeDef            *GPIOG;
S#endif /*_GPIOG */
S
S#ifdef _ADC1
S  EXT ADC_TypeDef             *ADC1;
S#endif /*_ADC1 */
S
S#ifdef _ADC2
S  EXT ADC_TypeDef             *ADC2;
S#endif /*_ADC2 */
S
S#ifdef _TIM1
S  EXT TIM_TypeDef             *TIM1;
S#endif /*_TIM1 */
S
S#ifdef _SPI1
S  EXT SPI_TypeDef             *SPI1;
S#endif /*_SPI1 */
S
S#ifdef _TIM8
S  EXT TIM_TypeDef             *TIM8;
S#endif /*_TIM8 */
S
S#ifdef _USART1
S  EXT USART_TypeDef           *USART1;
S#endif /*_USART1 */
S
S#ifdef _ADC3
S  EXT ADC_TypeDef             *ADC3;
S#endif /*_ADC3 */
S
S#ifdef _SDIO
S  EXT SDIO_TypeDef            *SDIO;
S#endif /*_SDIO */
S
S#ifdef _DMA
S  EXT DMA_TypeDef             *DMA1;
S  EXT DMA_TypeDef             *DMA2;
S#endif /*_DMA */
S
S#ifdef _DMA1_Channel1
S  EXT DMA_Channel_TypeDef     *DMA1_Channel1;
S#endif /*_DMA1_Channel1 */
S
S#ifdef _DMA1_Channel2
S  EXT DMA_Channel_TypeDef     *DMA1_Channel2;
S#endif /*_DMA1_Channel2 */
S
S#ifdef _DMA1_Channel3
S  EXT DMA_Channel_TypeDef     *DMA1_Channel3;
S#endif /*_DMA1_Channel3 */
S
S#ifdef _DMA1_Channel4
S  EXT DMA_Channel_TypeDef     *DMA1_Channel4;
S#endif /*_DMA1_Channel4 */
S
S#ifdef _DMA1_Channel5
S  EXT DMA_Channel_TypeDef     *DMA1_Channel5;
S#endif /*_DMA1_Channel5 */
S
S#ifdef _DMA1_Channel6
S  EXT DMA_Channel_TypeDef     *DMA1_Channel6;
S#endif /*_DMA1_Channel6 */
S
S#ifdef _DMA1_Channel7
S  EXT DMA_Channel_TypeDef     *DMA1_Channel7;
S#endif /*_DMA1_Channel7 */
S
S#ifdef _DMA2_Channel1
S  EXT DMA_Channel_TypeDef     *DMA2_Channel1;
S#endif /*_DMA2_Channel1 */
S
S#ifdef _DMA2_Channel2
S  EXT DMA_Channel_TypeDef     *DMA2_Channel2;
S#endif /*_DMA2_Channel2 */
S
S#ifdef _DMA2_Channel3
S  EXT DMA_Channel_TypeDef     *DMA2_Channel3;
S#endif /*_DMA2_Channel3 */
S
S#ifdef _DMA2_Channel4
S  EXT DMA_Channel_TypeDef     *DMA2_Channel4;
S#endif /*_DMA2_Channel4 */
S
S#ifdef _DMA2_Channel5
S  EXT DMA_Channel_TypeDef     *DMA2_Channel5;
S#endif /*_DMA2_Channel5 */
S
S#ifdef _RCC
S  EXT RCC_TypeDef             *RCC;
S#endif /*_RCC */
S
S#ifdef _CRC
S  EXT CRC_TypeDef             *CRC;
S#endif /*_CRC */
S
S#ifdef _FLASH
S  EXT FLASH_TypeDef            *FLASH;
S  EXT OB_TypeDef               *OB;  
S#endif /*_FLASH */
S
S#ifdef _FSMC
S  EXT FSMC_Bank1_TypeDef      *FSMC_Bank1;
S  EXT FSMC_Bank1E_TypeDef     *FSMC_Bank1E;
S  EXT FSMC_Bank2_TypeDef      *FSMC_Bank2;
S  EXT FSMC_Bank3_TypeDef      *FSMC_Bank3;
S  EXT FSMC_Bank4_TypeDef      *FSMC_Bank4;
S#endif /*_FSMC */
S
S#ifdef _DBGMCU
S  EXT DBGMCU_TypeDef          *DBGMCU;
S#endif /*_DBGMCU */
S
S#ifdef _SysTick
S  EXT SysTick_TypeDef         *SysTick;
S#endif /*_SysTick */
S
S#ifdef _NVIC
S  EXT NVIC_TypeDef            *NVIC;
S  EXT SCB_TypeDef             *SCB;
S#endif /*_NVIC */
S
N#endif  /* DEBUG */
N
N/* Exported constants --------------------------------------------------------*/
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
N
N#endif /* __STM32F10x_MAP_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 25 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_adc.h" 2
N
N/* Exported types ------------------------------------------------------------*/
N/* ADC Init structure definition */
Ntypedef struct
N{
N  u32 ADC_Mode;
N  FunctionalState ADC_ScanConvMode; 
N  FunctionalState ADC_ContinuousConvMode;
N  u32 ADC_ExternalTrigConv;
N  u32 ADC_DataAlign;
N  u8 ADC_NbrOfChannel;
N}ADC_InitTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N#define IS_ADC_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC2_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC3_BASE))
X#define IS_ADC_ALL_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC2_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC3_BASE))
N                                 
N#define IS_ADC_DMA_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) || \
N                                   ((*(u32*)&(PERIPH)) == ADC3_BASE))
X#define IS_ADC_DMA_PERIPH(PERIPH) (((*(u32*)&(PERIPH)) == ADC1_BASE) ||                                    ((*(u32*)&(PERIPH)) == ADC3_BASE))
N
N/* ADC dual mode -------------------------------------------------------------*/
N#define ADC_Mode_Independent                       ((u32)0x00000000)
N#define ADC_Mode_RegInjecSimult                    ((u32)0x00010000)
N#define ADC_Mode_RegSimult_AlterTrig               ((u32)0x00020000)
N#define ADC_Mode_InjecSimult_FastInterl            ((u32)0x00030000)
N#define ADC_Mode_InjecSimult_SlowInterl            ((u32)0x00040000)
N#define ADC_Mode_InjecSimult                       ((u32)0x00050000)
N#define ADC_Mode_RegSimult                         ((u32)0x00060000)
N#define ADC_Mode_FastInterl                        ((u32)0x00070000)
N#define ADC_Mode_SlowInterl                        ((u32)0x00080000)
N#define ADC_Mode_AlterTrig                         ((u32)0x00090000)
N
N#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) || \
N                           ((MODE) == ADC_Mode_RegInjecSimult) || \
N                           ((MODE) == ADC_Mode_RegSimult_AlterTrig) || \
N                           ((MODE) == ADC_Mode_InjecSimult_FastInterl) || \
N                           ((MODE) == ADC_Mode_InjecSimult_SlowInterl) || \
N                           ((MODE) == ADC_Mode_InjecSimult) || \
N                           ((MODE) == ADC_Mode_RegSimult) || \
N                           ((MODE) == ADC_Mode_FastInterl) || \
N                           ((MODE) == ADC_Mode_SlowInterl) || \
N                           ((MODE) == ADC_Mode_AlterTrig))
X#define IS_ADC_MODE(MODE) (((MODE) == ADC_Mode_Independent) ||                            ((MODE) == ADC_Mode_RegInjecSimult) ||                            ((MODE) == ADC_Mode_RegSimult_AlterTrig) ||                            ((MODE) == ADC_Mode_InjecSimult_FastInterl) ||                            ((MODE) == ADC_Mode_InjecSimult_SlowInterl) ||                            ((MODE) == ADC_Mode_InjecSimult) ||                            ((MODE) == ADC_Mode_RegSimult) ||                            ((MODE) == ADC_Mode_FastInterl) ||                            ((MODE) == ADC_Mode_SlowInterl) ||                            ((MODE) == ADC_Mode_AlterTrig))
N
N/* ADC extrenal trigger sources for regular channels conversion --------------*/
N/* for ADC1 and ADC2 */
N#define ADC_ExternalTrigConv_T1_CC1                ((u32)0x00000000)
N#define ADC_ExternalTrigConv_T1_CC2                ((u32)0x00020000)
N#define ADC_ExternalTrigConv_T2_CC2                ((u32)0x00060000)
N#define ADC_ExternalTrigConv_T3_TRGO               ((u32)0x00080000)
N#define ADC_ExternalTrigConv_T4_CC4                ((u32)0x000A0000)
N#define ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO    ((u32)0x000C0000)
N/* for ADC1, ADC2 and ADC3 */
N#define ADC_ExternalTrigConv_T1_CC3                ((u32)0x00040000)
N#define ADC_ExternalTrigConv_None                  ((u32)0x000E0000)
N/* for ADC3 */
N#define ADC_ExternalTrigConv_T3_CC1                ((u32)0x00000000)
N#define ADC_ExternalTrigConv_T2_CC3                ((u32)0x00020000)
N#define ADC_ExternalTrigConv_T8_CC1                ((u32)0x00060000)
N#define ADC_ExternalTrigConv_T8_TRGO               ((u32)0x00080000)
N#define ADC_ExternalTrigConv_T5_CC1                ((u32)0x000A0000)
N#define ADC_ExternalTrigConv_T5_CC3                ((u32)0x000C0000)
N
N#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_None) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) || \
N                                  ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
X#define IS_ADC_EXT_TRIG(REGTRIG) (((REGTRIG) == ADC_ExternalTrigConv_T1_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T1_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC2) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T4_CC4) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_Ext_IT11_TIM8_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_None) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T3_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T2_CC3) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T8_TRGO) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC1) ||                                   ((REGTRIG) == ADC_ExternalTrigConv_T5_CC3))
N
N/* ADC data align ------------------------------------------------------------*/
N#define ADC_DataAlign_Right                        ((u32)0x00000000)
N#define ADC_DataAlign_Left                         ((u32)0x00000800)
N
N#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) || \
N                                  ((ALIGN) == ADC_DataAlign_Left))
X#define IS_ADC_DATA_ALIGN(ALIGN) (((ALIGN) == ADC_DataAlign_Right) ||                                   ((ALIGN) == ADC_DataAlign_Left))
N
N/* ADC channels --------------------------------------------------------------*/
N#define ADC_Channel_0                               ((u8)0x00)
N#define ADC_Channel_1                               ((u8)0x01)
N#define ADC_Channel_2                               ((u8)0x02)
N#define ADC_Channel_3                               ((u8)0x03)
N#define ADC_Channel_4                               ((u8)0x04)
N#define ADC_Channel_5                               ((u8)0x05)
N#define ADC_Channel_6                               ((u8)0x06)
N#define ADC_Channel_7                               ((u8)0x07)
N#define ADC_Channel_8                               ((u8)0x08)
N#define ADC_Channel_9                               ((u8)0x09)
N#define ADC_Channel_10                              ((u8)0x0A)
N#define ADC_Channel_11                              ((u8)0x0B)
N#define ADC_Channel_12                              ((u8)0x0C)
N#define ADC_Channel_13                              ((u8)0x0D)
N#define ADC_Channel_14                              ((u8)0x0E)
N#define ADC_Channel_15                              ((u8)0x0F)
N#define ADC_Channel_16                              ((u8)0x10)
N#define ADC_Channel_17                              ((u8)0x11)
N
N#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) || \
N                                 ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) || \
N                                 ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) || \
N                                 ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) || \
N                                 ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) || \
N                                 ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) || \
N                                 ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) || \
N                                 ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) || \
N                                 ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
X#define IS_ADC_CHANNEL(CHANNEL) (((CHANNEL) == ADC_Channel_0) || ((CHANNEL) == ADC_Channel_1) ||                                  ((CHANNEL) == ADC_Channel_2) || ((CHANNEL) == ADC_Channel_3) ||                                  ((CHANNEL) == ADC_Channel_4) || ((CHANNEL) == ADC_Channel_5) ||                                  ((CHANNEL) == ADC_Channel_6) || ((CHANNEL) == ADC_Channel_7) ||                                  ((CHANNEL) == ADC_Channel_8) || ((CHANNEL) == ADC_Channel_9) ||                                  ((CHANNEL) == ADC_Channel_10) || ((CHANNEL) == ADC_Channel_11) ||                                  ((CHANNEL) == ADC_Channel_12) || ((CHANNEL) == ADC_Channel_13) ||                                  ((CHANNEL) == ADC_Channel_14) || ((CHANNEL) == ADC_Channel_15) ||                                  ((CHANNEL) == ADC_Channel_16) || ((CHANNEL) == ADC_Channel_17))
N
N/* ADC sampling times --------------------------------------------------------*/
N#define ADC_SampleTime_1Cycles5                    ((u8)0x00)
N#define ADC_SampleTime_7Cycles5                    ((u8)0x01)
N#define ADC_SampleTime_13Cycles5                   ((u8)0x02)
N#define ADC_SampleTime_28Cycles5                   ((u8)0x03)
N#define ADC_SampleTime_41Cycles5                   ((u8)0x04)
N#define ADC_SampleTime_55Cycles5                   ((u8)0x05)
N#define ADC_SampleTime_71Cycles5                   ((u8)0x06)
N#define ADC_SampleTime_239Cycles5                  ((u8)0x07)
N
N#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_7Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_13Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_28Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_41Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_55Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_71Cycles5) || \
N                                  ((TIME) == ADC_SampleTime_239Cycles5))
X#define IS_ADC_SAMPLE_TIME(TIME) (((TIME) == ADC_SampleTime_1Cycles5) ||                                   ((TIME) == ADC_SampleTime_7Cycles5) ||                                   ((TIME) == ADC_SampleTime_13Cycles5) ||                                   ((TIME) == ADC_SampleTime_28Cycles5) ||                                   ((TIME) == ADC_SampleTime_41Cycles5) ||                                   ((TIME) == ADC_SampleTime_55Cycles5) ||                                   ((TIME) == ADC_SampleTime_71Cycles5) ||                                   ((TIME) == ADC_SampleTime_239Cycles5))
N
N/* ADC extrenal trigger sources for injected channels conversion -------------*/
N/* For ADC1 and ADC2 */
N#define ADC_ExternalTrigInjecConv_T2_TRGO           ((u32)0x00002000)
N#define ADC_ExternalTrigInjecConv_T2_CC1            ((u32)0x00003000)
N#define ADC_ExternalTrigInjecConv_T3_CC4            ((u32)0x00004000)
N#define ADC_ExternalTrigInjecConv_T4_TRGO           ((u32)0x00005000)
N#define ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4 ((u32)0x00006000)
N/* For ADC1, ADC2 and ADC3 */
N#define ADC_ExternalTrigInjecConv_T1_TRGO           ((u32)0x00000000)
N#define ADC_ExternalTrigInjecConv_T1_CC4            ((u32)0x00001000)
N#define ADC_ExternalTrigInjecConv_None              ((u32)0x00007000)
N/* For ADC3 */
N#define ADC_ExternalTrigInjecConv_T4_CC3            ((u32)0x00002000)
N#define ADC_ExternalTrigInjecConv_T8_CC2            ((u32)0x00003000)
N#define ADC_ExternalTrigInjecConv_T8_CC4            ((u32)0x00004000)
N#define ADC_ExternalTrigInjecConv_T5_TRGO           ((u32)0x00005000)
N#define ADC_ExternalTrigInjecConv_T5_CC4            ((u32)0x00006000)
N
N#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_None) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) || \
N                                        ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
X#define IS_ADC_EXT_INJEC_TRIG(INJTRIG) (((INJTRIG) == ADC_ExternalTrigInjecConv_T1_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T1_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T2_CC1) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T3_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_None) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T4_CC3) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC2) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T8_CC4) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_TRGO) ||                                         ((INJTRIG) == ADC_ExternalTrigInjecConv_T5_CC4))
N
N/* ADC injected channel selection --------------------------------------------*/
N#define ADC_InjectedChannel_1                       ((u8)0x14)
N#define ADC_InjectedChannel_2                       ((u8)0x18)
N#define ADC_InjectedChannel_3                       ((u8)0x1C)
N#define ADC_InjectedChannel_4                       ((u8)0x20)
N
N#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_2) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_3) || \
N                                          ((CHANNEL) == ADC_InjectedChannel_4))
X#define IS_ADC_INJECTED_CHANNEL(CHANNEL) (((CHANNEL) == ADC_InjectedChannel_1) ||                                           ((CHANNEL) == ADC_InjectedChannel_2) ||                                           ((CHANNEL) == ADC_InjectedChannel_3) ||                                           ((CHANNEL) == ADC_InjectedChannel_4))
N
N/* ADC analog watchdog selection ---------------------------------------------*/
N#define ADC_AnalogWatchdog_SingleRegEnable         ((u32)0x00800200)
N#define ADC_AnalogWatchdog_SingleInjecEnable       ((u32)0x00400200)
N#define ADC_AnalogWatchdog_SingleRegOrInjecEnable  ((u32)0x00C00200)
N#define ADC_AnalogWatchdog_AllRegEnable            ((u32)0x00800000)
N#define ADC_AnalogWatchdog_AllInjecEnable          ((u32)0x00400000)
N#define ADC_AnalogWatchdog_AllRegAllInjecEnable    ((u32)0x00C00000)
N#define ADC_AnalogWatchdog_None                    ((u32)0x00000000)
N
N#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) || \
N                                          ((WATCHDOG) == ADC_AnalogWatchdog_None))
X#define IS_ADC_ANALOG_WATCHDOG(WATCHDOG) (((WATCHDOG) == ADC_AnalogWatchdog_SingleRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_SingleRegOrInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_AllRegAllInjecEnable) ||                                           ((WATCHDOG) == ADC_AnalogWatchdog_None))
N
N/* ADC interrupts definition -------------------------------------------------*/
N#define ADC_IT_EOC                                 ((u16)0x0220)
N#define ADC_IT_AWD                                 ((u16)0x0140)
N#define ADC_IT_JEOC                                ((u16)0x0480)
N
N#define IS_ADC_IT(IT) ((((IT) & (u16)0xF81F) == 0x00) && ((IT) != 0x00))
N#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) || \
N                           ((IT) == ADC_IT_JEOC))
X#define IS_ADC_GET_IT(IT) (((IT) == ADC_IT_EOC) || ((IT) == ADC_IT_AWD) ||                            ((IT) == ADC_IT_JEOC))
N
N/* ADC flags definition ------------------------------------------------------*/
N#define ADC_FLAG_AWD                               ((u8)0x01)
N#define ADC_FLAG_EOC                               ((u8)0x02)
N#define ADC_FLAG_JEOC                              ((u8)0x04)
N#define ADC_FLAG_JSTRT                             ((u8)0x08)
N#define ADC_FLAG_STRT                              ((u8)0x10)
N
N#define IS_ADC_CLEAR_FLAG(FLAG) ((((FLAG) & (u8)0xE0) == 0x00) && ((FLAG) != 0x00))
N#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) || \
N                               ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) || \
N                               ((FLAG) == ADC_FLAG_STRT))
X#define IS_ADC_GET_FLAG(FLAG) (((FLAG) == ADC_FLAG_AWD) || ((FLAG) == ADC_FLAG_EOC) ||                                ((FLAG) == ADC_FLAG_JEOC) || ((FLAG)== ADC_FLAG_JSTRT) ||                                ((FLAG) == ADC_FLAG_STRT))
N
N/* ADC thresholds ------------------------------------------------------------*/
N#define IS_ADC_THRESHOLD(THRESHOLD) ((THRESHOLD) <= 0xFFF)
N
N/* ADC injected offset -------------------------------------------------------*/
N#define IS_ADC_OFFSET(OFFSET) ((OFFSET) <= 0xFFF)
N
N/* ADC injected length -------------------------------------------------------*/
N#define IS_ADC_INJECTED_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))
N
N/* ADC injected rank ---------------------------------------------------------*/
N#define IS_ADC_INJECTED_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x4))
N
N/* ADC regular length --------------------------------------------------------*/
N#define IS_ADC_REGULAR_LENGTH(LENGTH) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))
N
N/* ADC regular rank ----------------------------------------------------------*/
N#define IS_ADC_REGULAR_RANK(RANK) (((RANK) >= 0x1) && ((RANK) <= 0x10))
N
N/* ADC regular discontinuous mode number -------------------------------------*/
N#define IS_ADC_REGULAR_DISC_NUMBER(NUMBER) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid ADC_DeInit(ADC_TypeDef* ADCx);
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct);
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState);
Nvoid ADC_ResetCalibration(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx);
Nvoid ADC_StartCalibration(ADC_TypeDef* ADCx);
NFlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx);
Nvoid ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
NFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx);
Nvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number);
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime);
Nvoid ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nu16 ADC_GetConversionValue(ADC_TypeDef* ADCx);
Nu32 ADC_GetDualModeConversionValue(void);
Nvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv);
Nvoid ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
Nvoid ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState);
NFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx);
Nvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime);
Nvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length);
Nvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset);
Nu16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel);
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog);
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold, u16 LowThreshold);
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel);
Nvoid ADC_TempSensorVrefintCmd(FunctionalState NewState);
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG);
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG);
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT);
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT);
N
N#endif /*__STM32F10x_ADC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 20 "..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_adc.c" 2
N#include "stm32f10x_rcc.h"
L 1 "..\..\..\..\..\CPU\ST\STM32\inc\stm32f10x_rcc.h" 1
N/******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
N* File Name          : stm32f10x_rcc.h
N* Author             : MCD Application Team
N* Version            : V2.0
N* Date               : 05/23/2008
N* Description        : This file contains all the functions prototypes for the
N*                      RCC firmware library.
N********************************************************************************
N* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
N* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
N* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
N* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
N* CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
N* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
N* FOR MORE INFORMATION PLEASE CAREFULLY READ THE LICENSE AGREEMENT FILE LOCATED 
N* IN THE ROOT DIRECTORY OF THIS FIRMWARE PACKAGE.
N*******************************************************************************/
N
N/* Define to prevent recursive inclusion -------------------------------------*/
N#ifndef __STM32F10x_RCC_H
N#define __STM32F10x_RCC_H
N
N/* Includes ------------------------------------------------------------------*/
N#include "stm32f10x_map.h"
N
N/* Exported types ------------------------------------------------------------*/
Ntypedef struct
N{
N  u32 SYSCLK_Frequency;
N  u32 HCLK_Frequency;
N  u32 PCLK1_Frequency;
N  u32 PCLK2_Frequency;
N  u32 ADCCLK_Frequency;
N}RCC_ClocksTypeDef;
N
N/* Exported constants --------------------------------------------------------*/
N/* HSE configuration */
N#define RCC_HSE_OFF                      ((u32)0x00000000)
N#define RCC_HSE_ON                       ((u32)0x00010000)
N#define RCC_HSE_Bypass                   ((u32)0x00040000)
N
N#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) || \
N                         ((HSE) == RCC_HSE_Bypass))
X#define IS_RCC_HSE(HSE) (((HSE) == RCC_HSE_OFF) || ((HSE) == RCC_HSE_ON) ||                          ((HSE) == RCC_HSE_Bypass))
N
N/* PLL entry clock source */
N#define RCC_PLLSource_HSI_Div2           ((u32)0x00000000)
N#define RCC_PLLSource_HSE_Div1           ((u32)0x00010000)
N#define RCC_PLLSource_HSE_Div2           ((u32)0x00030000)
N
N#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div1) || \
N                                   ((SOURCE) == RCC_PLLSource_HSE_Div2))
X#define IS_RCC_PLL_SOURCE(SOURCE) (((SOURCE) == RCC_PLLSource_HSI_Div2) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div1) ||                                    ((SOURCE) == RCC_PLLSource_HSE_Div2))
N
N/* PLL multiplication factor */
N#define RCC_PLLMul_2                     ((u32)0x00000000)
N#define RCC_PLLMul_3                     ((u32)0x00040000)
N#define RCC_PLLMul_4                     ((u32)0x00080000)
N#define RCC_PLLMul_5                     ((u32)0x000C0000)
N#define RCC_PLLMul_6                     ((u32)0x00100000)
N#define RCC_PLLMul_7                     ((u32)0x00140000)
N#define RCC_PLLMul_8                     ((u32)0x00180000)
N#define RCC_PLLMul_9                     ((u32)0x001C0000)
N#define RCC_PLLMul_10                    ((u32)0x00200000)
N#define RCC_PLLMul_11                    ((u32)0x00240000)
N#define RCC_PLLMul_12                    ((u32)0x00280000)
N#define RCC_PLLMul_13                    ((u32)0x002C0000)
N#define RCC_PLLMul_14                    ((u32)0x00300000)
N#define RCC_PLLMul_15                    ((u32)0x00340000)
N#define RCC_PLLMul_16                    ((u32)0x00380000)
N
N#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   || \
N                             ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   || \
N                             ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   || \
N                             ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   || \
N                             ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) || \
N                             ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) || \
N                             ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) || \
N                             ((MUL) == RCC_PLLMul_16))
X#define IS_RCC_PLL_MUL(MUL) (((MUL) == RCC_PLLMul_2) || ((MUL) == RCC_PLLMul_3)   ||                              ((MUL) == RCC_PLLMul_4) || ((MUL) == RCC_PLLMul_5)   ||                              ((MUL) == RCC_PLLMul_6) || ((MUL) == RCC_PLLMul_7)   ||                              ((MUL) == RCC_PLLMul_8) || ((MUL) == RCC_PLLMul_9)   ||                              ((MUL) == RCC_PLLMul_10) || ((MUL) == RCC_PLLMul_11) ||                              ((MUL) == RCC_PLLMul_12) || ((MUL) == RCC_PLLMul_13) ||                              ((MUL) == RCC_PLLMul_14) || ((MUL) == RCC_PLLMul_15) ||                              ((MUL) == RCC_PLLMul_16))
N
N/* System clock source */
N#define RCC_SYSCLKSource_HSI             ((u32)0x00000000)
N#define RCC_SYSCLKSource_HSE             ((u32)0x00000001)
N#define RCC_SYSCLKSource_PLLCLK          ((u32)0x00000002)
N
N#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_HSE) || \
N                                      ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
X#define IS_RCC_SYSCLK_SOURCE(SOURCE) (((SOURCE) == RCC_SYSCLKSource_HSI) ||                                       ((SOURCE) == RCC_SYSCLKSource_HSE) ||                                       ((SOURCE) == RCC_SYSCLKSource_PLLCLK))
N
N/* AHB clock source */
N#define RCC_SYSCLK_Div1                  ((u32)0x00000000)
N#define RCC_SYSCLK_Div2                  ((u32)0x00000080)
N#define RCC_SYSCLK_Div4                  ((u32)0x00000090)
N#define RCC_SYSCLK_Div8                  ((u32)0x000000A0)
N#define RCC_SYSCLK_Div16                 ((u32)0x000000B0)
N#define RCC_SYSCLK_Div64                 ((u32)0x000000C0)
N#define RCC_SYSCLK_Div128                ((u32)0x000000D0)
N#define RCC_SYSCLK_Div256                ((u32)0x000000E0)
N#define RCC_SYSCLK_Div512                ((u32)0x000000F0)
N
N#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) || \
N                           ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) || \
N                           ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) || \
N                           ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) || \
N                           ((HCLK) == RCC_SYSCLK_Div512))
X#define IS_RCC_HCLK(HCLK) (((HCLK) == RCC_SYSCLK_Div1) || ((HCLK) == RCC_SYSCLK_Div2) ||                            ((HCLK) == RCC_SYSCLK_Div4) || ((HCLK) == RCC_SYSCLK_Div8) ||                            ((HCLK) == RCC_SYSCLK_Div16) || ((HCLK) == RCC_SYSCLK_Div64) ||                            ((HCLK) == RCC_SYSCLK_Div128) || ((HCLK) == RCC_SYSCLK_Div256) ||                            ((HCLK) == RCC_SYSCLK_Div512))
N
N/* APB1/APB2 clock source */
N#define RCC_HCLK_Div1                    ((u32)0x00000000)
N#define RCC_HCLK_Div2                    ((u32)0x00000400)
N#define RCC_HCLK_Div4                    ((u32)0x00000500)
N#define RCC_HCLK_Div8                    ((u32)0x00000600)
N#define RCC_HCLK_Div16                   ((u32)0x00000700)
N
N#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) || \
N                           ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) || \
N                           ((PCLK) == RCC_HCLK_Div16))
X#define IS_RCC_PCLK(PCLK) (((PCLK) == RCC_HCLK_Div1) || ((PCLK) == RCC_HCLK_Div2) ||                            ((PCLK) == RCC_HCLK_Div4) || ((PCLK) == RCC_HCLK_Div8) ||                            ((PCLK) == RCC_HCLK_Div16))
N
N/* RCC Interrupt source */
N#define RCC_IT_LSIRDY                    ((u8)0x01)
N#define RCC_IT_LSERDY                    ((u8)0x02)
N#define RCC_IT_HSIRDY                    ((u8)0x04)
N#define RCC_IT_HSERDY                    ((u8)0x08)
N#define RCC_IT_PLLRDY                    ((u8)0x10)
N#define RCC_IT_CSS                       ((u8)0x80)
N
N#define IS_RCC_IT(IT) ((((IT) & (u8)0xE0) == 0x00) && ((IT) != 0x00))
N#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) || \
N                           ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) || \
N                           ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
X#define IS_RCC_GET_IT(IT) (((IT) == RCC_IT_LSIRDY) || ((IT) == RCC_IT_LSERDY) ||                            ((IT) == RCC_IT_HSIRDY) || ((IT) == RCC_IT_HSERDY) ||                            ((IT) == RCC_IT_PLLRDY) || ((IT) == RCC_IT_CSS))
N#define IS_RCC_CLEAR_IT(IT) ((((IT) & (u8)0x60) == 0x00) && ((IT) != 0x00))
N
N/* USB clock source */
N#define RCC_USBCLKSource_PLLCLK_1Div5    ((u8)0x00)
N#define RCC_USBCLKSource_PLLCLK_Div1     ((u8)0x01)
N
N#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) || \
N                                      ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
X#define IS_RCC_USBCLK_SOURCE(SOURCE) (((SOURCE) == RCC_USBCLKSource_PLLCLK_1Div5) ||                                       ((SOURCE) == RCC_USBCLKSource_PLLCLK_Div1))
N
N/* ADC clock source */
N#define RCC_PCLK2_Div2                   ((u32)0x00000000)
N#define RCC_PCLK2_Div4                   ((u32)0x00004000)
N#define RCC_PCLK2_Div6                   ((u32)0x00008000)
N#define RCC_PCLK2_Div8                   ((u32)0x0000C000)
N
N#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) || \
N                               ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
X#define IS_RCC_ADCCLK(ADCCLK) (((ADCCLK) == RCC_PCLK2_Div2) || ((ADCCLK) == RCC_PCLK2_Div4) ||                                ((ADCCLK) == RCC_PCLK2_Div6) || ((ADCCLK) == RCC_PCLK2_Div8))
N
N/* LSE configuration */
N#define RCC_LSE_OFF                      ((u8)0x00)
N#define RCC_LSE_ON                       ((u8)0x01)
N#define RCC_LSE_Bypass                   ((u8)0x04)
N
N#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) || \
N                         ((LSE) == RCC_LSE_Bypass))
X#define IS_RCC_LSE(LSE) (((LSE) == RCC_LSE_OFF) || ((LSE) == RCC_LSE_ON) ||                          ((LSE) == RCC_LSE_Bypass))
N
N/* RTC clock source */
N#define RCC_RTCCLKSource_LSE             ((u32)0x00000100)
N#define RCC_RTCCLKSource_LSI             ((u32)0x00000200)
N#define RCC_RTCCLKSource_HSE_Div128      ((u32)0x00000300)
N
N#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_LSI) || \
N                                      ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
X#define IS_RCC_RTCCLK_SOURCE(SOURCE) (((SOURCE) == RCC_RTCCLKSource_LSE) ||                                       ((SOURCE) == RCC_RTCCLKSource_LSI) ||                                       ((SOURCE) == RCC_RTCCLKSource_HSE_Div128))
N
N/* AHB peripheral */
N#define RCC_AHBPeriph_DMA1               ((u32)0x00000001)
N#define RCC_AHBPeriph_DMA2               ((u32)0x00000002)
N#define RCC_AHBPeriph_SRAM               ((u32)0x00000004)
N#define RCC_AHBPeriph_FLITF              ((u32)0x00000010)
N#define RCC_AHBPeriph_CRC                ((u32)0x00000040)
N#define RCC_AHBPeriph_FSMC               ((u32)0x00000100)
N#define RCC_AHBPeriph_SDIO               ((u32)0x00000400)
N
N#define IS_RCC_AHB_PERIPH(PERIPH) ((((PERIPH) & 0xFFFFFAA8) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB2 peripheral */
N#define RCC_APB2Periph_AFIO              ((u32)0x00000001)
N#define RCC_APB2Periph_GPIOA             ((u32)0x00000004)
N#define RCC_APB2Periph_GPIOB             ((u32)0x00000008)
N#define RCC_APB2Periph_GPIOC             ((u32)0x00000010)
N#define RCC_APB2Periph_GPIOD             ((u32)0x00000020)
N#define RCC_APB2Periph_GPIOE             ((u32)0x00000040)
N#define RCC_APB2Periph_GPIOF             ((u32)0x00000080)
N#define RCC_APB2Periph_GPIOG             ((u32)0x00000100)
N#define RCC_APB2Periph_ADC1              ((u32)0x00000200)
N#define RCC_APB2Periph_ADC2              ((u32)0x00000400)
N#define RCC_APB2Periph_TIM1              ((u32)0x00000800)
N#define RCC_APB2Periph_SPI1              ((u32)0x00001000)
N#define RCC_APB2Periph_TIM8              ((u32)0x00002000)
N#define RCC_APB2Periph_USART1            ((u32)0x00004000)
N#define RCC_APB2Periph_ADC3              ((u32)0x00008000)
N#define RCC_APB2Periph_ALL               ((u32)0x0000FFFD)
N
N#define IS_RCC_APB2_PERIPH(PERIPH) ((((PERIPH) & 0xFFFF0002) == 0x00) && ((PERIPH) != 0x00))
N
N/* APB1 peripheral */
N#define RCC_APB1Periph_TIM2              ((u32)0x00000001)
N#define RCC_APB1Periph_TIM3              ((u32)0x00000002)
N#define RCC_APB1Periph_TIM4              ((u32)0x00000004)
N#define RCC_APB1Periph_TIM5              ((u32)0x00000008)
N#define RCC_APB1Periph_TIM6              ((u32)0x00000010)
N#define RCC_APB1Periph_TIM7              ((u32)0x00000020)
N#define RCC_APB1Periph_WWDG              ((u32)0x00000800)
N#define RCC_APB1Periph_SPI2              ((u32)0x00004000)
N#define RCC_APB1Periph_SPI3              ((u32)0x00008000)
N#define RCC_APB1Periph_USART2            ((u32)0x00020000)
N#define RCC_APB1Periph_USART3            ((u32)0x00040000)
N#define RCC_APB1Periph_UART4             ((u32)0x00080000)
N#define RCC_APB1Periph_UART5             ((u32)0x00100000)
N#define RCC_APB1Periph_I2C1              ((u32)0x00200000)
N#define RCC_APB1Periph_I2C2              ((u32)0x00400000)
N#define RCC_APB1Periph_USB               ((u32)0x00800000)
N#define RCC_APB1Periph_CAN               ((u32)0x02000000)
N#define RCC_APB1Periph_BKP               ((u32)0x08000000)
N#define RCC_APB1Periph_PWR               ((u32)0x10000000)
N#define RCC_APB1Periph_DAC               ((u32)0x20000000)
N#define RCC_APB1Periph_ALL               ((u32)0x3AFEC83F)
N
N#define IS_RCC_APB1_PERIPH(PERIPH) ((((PERIPH) & 0xC50137C0) == 0x00) && ((PERIPH) != 0x00))
N
N/* Clock source to output on MCO pin */
N#define RCC_MCO_NoClock                  ((u8)0x00)
N#define RCC_MCO_SYSCLK                   ((u8)0x04)
N#define RCC_MCO_HSI                      ((u8)0x05)
N#define RCC_MCO_HSE                      ((u8)0x06)
N#define RCC_MCO_PLLCLK_Div2              ((u8)0x07)
N
N#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) || \
N                         ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) || \
N                         ((MCO) == RCC_MCO_PLLCLK_Div2))
X#define IS_RCC_MCO(MCO) (((MCO) == RCC_MCO_NoClock) || ((MCO) == RCC_MCO_HSI) ||                          ((MCO) == RCC_MCO_SYSCLK)  || ((MCO) == RCC_MCO_HSE) ||                          ((MCO) == RCC_MCO_PLLCLK_Div2))
N
N/* RCC Flag */
N#define RCC_FLAG_HSIRDY                  ((u8)0x20)
N#define RCC_FLAG_HSERDY                  ((u8)0x31)
N#define RCC_FLAG_PLLRDY                  ((u8)0x39)
N#define RCC_FLAG_LSERDY                  ((u8)0x41)
N#define RCC_FLAG_LSIRDY                  ((u8)0x61)
N#define RCC_FLAG_PINRST                  ((u8)0x7A)
N#define RCC_FLAG_PORRST                  ((u8)0x7B)
N#define RCC_FLAG_SFTRST                  ((u8)0x7C)
N#define RCC_FLAG_IWDGRST                 ((u8)0x7D)
N#define RCC_FLAG_WWDGRST                 ((u8)0x7E)
N#define RCC_FLAG_LPWRRST                 ((u8)0x7F)
N
N#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) || \
N                           ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) || \
N                           ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) || \
N                           ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) || \
N                           ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)|| \
N                           ((FLAG) == RCC_FLAG_LPWRRST))
X#define IS_RCC_FLAG(FLAG) (((FLAG) == RCC_FLAG_HSIRDY) || ((FLAG) == RCC_FLAG_HSERDY) ||                            ((FLAG) == RCC_FLAG_PLLRDY) || ((FLAG) == RCC_FLAG_LSERDY) ||                            ((FLAG) == RCC_FLAG_LSIRDY) || ((FLAG) == RCC_FLAG_PINRST) ||                            ((FLAG) == RCC_FLAG_PORRST) || ((FLAG) == RCC_FLAG_SFTRST) ||                            ((FLAG) == RCC_FLAG_IWDGRST)|| ((FLAG) == RCC_FLAG_WWDGRST)||                            ((FLAG) == RCC_FLAG_LPWRRST))
N
N#define IS_RCC_CALIBRATION_VALUE(VALUE) ((VALUE) <= 0x1F)
N
N/* Exported macro ------------------------------------------------------------*/
N/* Exported functions ------------------------------------------------------- */
Nvoid RCC_DeInit(void);
Nvoid RCC_HSEConfig(u32 RCC_HSE);
NErrorStatus RCC_WaitForHSEStartUp(void);
Nvoid RCC_AdjustHSICalibrationValue(u8 HSICalibrationValue);
Nvoid RCC_HSICmd(FunctionalState NewState);
Nvoid RCC_PLLConfig(u32 RCC_PLLSource, u32 RCC_PLLMul);
Nvoid RCC_PLLCmd(FunctionalState NewState);
Nvoid RCC_SYSCLKConfig(u32 RCC_SYSCLKSource);
Nu8 RCC_GetSYSCLKSource(void);
Nvoid RCC_HCLKConfig(u32 RCC_SYSCLK);
Nvoid RCC_PCLK1Config(u32 RCC_HCLK);
Nvoid RCC_PCLK2Config(u32 RCC_HCLK);
Nvoid RCC_ITConfig(u8 RCC_IT, FunctionalState NewState);
Nvoid RCC_USBCLKConfig(u32 RCC_USBCLKSource);
Nvoid RCC_ADCCLKConfig(u32 RCC_PCLK2);
Nvoid RCC_LSEConfig(u8 RCC_LSE);
Nvoid RCC_LSICmd(FunctionalState NewState);
Nvoid RCC_RTCCLKConfig(u32 RCC_RTCCLKSource);
Nvoid RCC_RTCCLKCmd(FunctionalState NewState);
Nvoid RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks);
Nvoid RCC_AHBPeriphClockCmd(u32 RCC_AHBPeriph, FunctionalState NewState);
Nvoid RCC_APB2PeriphClockCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphClockCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_APB2PeriphResetCmd(u32 RCC_APB2Periph, FunctionalState NewState);
Nvoid RCC_APB1PeriphResetCmd(u32 RCC_APB1Periph, FunctionalState NewState);
Nvoid RCC_BackupResetCmd(FunctionalState NewState);
Nvoid RCC_ClockSecuritySystemCmd(FunctionalState NewState);
Nvoid RCC_MCOConfig(u8 RCC_MCO);
NFlagStatus RCC_GetFlagStatus(u8 RCC_FLAG);
Nvoid RCC_ClearFlag(void);
NITStatus RCC_GetITStatus(u8 RCC_IT);
Nvoid RCC_ClearITPendingBit(u8 RCC_IT);
N
N#endif /* __STM32F10x_RCC_H */
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
L 21 "..\..\..\..\..\CPU\ST\STM32\src\stm32f10x_adc.c" 2
N
N/* Private typedef -----------------------------------------------------------*/
N/* Private define ------------------------------------------------------------*/
N/* ADC DISCNUM mask */
N#define CR1_DISCNUM_Reset           ((u32)0xFFFF1FFF)
N
N/* ADC DISCEN mask */
N#define CR1_DISCEN_Set              ((u32)0x00000800)
N#define CR1_DISCEN_Reset            ((u32)0xFFFFF7FF)
N
N/* ADC JAUTO mask */
N#define CR1_JAUTO_Set               ((u32)0x00000400)
N#define CR1_JAUTO_Reset             ((u32)0xFFFFFBFF)
N
N/* ADC JDISCEN mask */
N#define CR1_JDISCEN_Set             ((u32)0x00001000)
N#define CR1_JDISCEN_Reset           ((u32)0xFFFFEFFF)
N
N/* ADC AWDCH mask */
N#define CR1_AWDCH_Reset             ((u32)0xFFFFFFE0)
N
N/* ADC Analog watchdog enable mode mask */
N#define CR1_AWDMode_Reset           ((u32)0xFF3FFDFF)
N
N/* CR1 register Mask */
N#define CR1_CLEAR_Mask              ((u32)0xFFF0FEFF)
N
N/* ADC ADON mask */
N#define CR2_ADON_Set                ((u32)0x00000001)
N#define CR2_ADON_Reset              ((u32)0xFFFFFFFE)
N
N/* ADC DMA mask */
N#define CR2_DMA_Set                 ((u32)0x00000100)
N#define CR2_DMA_Reset               ((u32)0xFFFFFEFF)
N
N/* ADC RSTCAL mask */
N#define CR2_RSTCAL_Set              ((u32)0x00000008)
N
N/* ADC CAL mask */
N#define CR2_CAL_Set                 ((u32)0x00000004)
N
N/* ADC SWSTART mask */
N#define CR2_SWSTART_Set             ((u32)0x00400000)
N
N/* ADC EXTTRIG mask */
N#define CR2_EXTTRIG_Set             ((u32)0x00100000)
N#define CR2_EXTTRIG_Reset           ((u32)0xFFEFFFFF)
N
N/* ADC Software start mask */
N#define CR2_EXTTRIG_SWSTART_Set     ((u32)0x00500000)
N#define CR2_EXTTRIG_SWSTART_Reset   ((u32)0xFFAFFFFF)
N
N/* ADC JEXTSEL mask */
N#define CR2_JEXTSEL_Reset           ((u32)0xFFFF8FFF)
N
N/* ADC JEXTTRIG mask */
N#define CR2_JEXTTRIG_Set            ((u32)0x00008000)
N#define CR2_JEXTTRIG_Reset          ((u32)0xFFFF7FFF)
N
N/* ADC JSWSTART mask */
N#define CR2_JSWSTART_Set            ((u32)0x00200000)
N
N/* ADC injected software start mask */
N#define CR2_JEXTTRIG_JSWSTART_Set   ((u32)0x00208000)
N#define CR2_JEXTTRIG_JSWSTART_Reset ((u32)0xFFDF7FFF)
N
N/* ADC TSPD mask */
N#define CR2_TSVREFE_Set             ((u32)0x00800000)
N#define CR2_TSVREFE_Reset           ((u32)0xFF7FFFFF)
N
N/* CR2 register Mask */
N#define CR2_CLEAR_Mask              ((u32)0xFFF1F7FD)
N
N/* ADC SQx mask */
N#define SQR3_SQ_Set                 ((u32)0x0000001F)
N#define SQR2_SQ_Set                 ((u32)0x0000001F)
N#define SQR1_SQ_Set                 ((u32)0x0000001F)
N
N/* SQR1 register Mask */
N#define SQR1_CLEAR_Mask             ((u32)0xFF0FFFFF)
N
N/* ADC JSQx mask */
N#define JSQR_JSQ_Set                ((u32)0x0000001F)
N
N/* ADC JL mask */
N#define JSQR_JL_Set                 ((u32)0x00300000)
N#define JSQR_JL_Reset               ((u32)0xFFCFFFFF)
N
N/* ADC SMPx mask */
N#define SMPR1_SMP_Set               ((u32)0x00000007)
N#define SMPR2_SMP_Set               ((u32)0x00000007)
N
N/* ADC JDRx registers offset */
N#define JDR_Offset                  ((u8)0x28)
N
N/* ADC1 DR register base address */
N#define DR_ADDRESS                  ((u32)0x4001244C)
N
N/* Private macro -------------------------------------------------------------*/
N/* Private variables ---------------------------------------------------------*/
N/* Private function prototypes -----------------------------------------------*/
N/* Private functions ---------------------------------------------------------*/
N
N/*******************************************************************************
N* Function Name  : ADC_DeInit
N* Description    : Deinitializes the ADCx peripheral registers to their default
N*                  reset values.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_DeInit(ADC_TypeDef* ADCx)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  switch (*(u32*)&ADCx)
N  {
N    case ADC1_BASE:
X    case ((((u32)0x40000000) + 0x10000) + 0x2400):
N      /* Enable ADC1 reset state */
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
X      RCC_APB2PeriphResetCmd(((u32)0x00000200), ENABLE);
N      /* Release ADC1 from reset state */
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
X      RCC_APB2PeriphResetCmd(((u32)0x00000200), DISABLE);
N      break;
N    
N    case ADC2_BASE:
X    case ((((u32)0x40000000) + 0x10000) + 0x2800):
N      /* Enable ADC2 reset state */
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
X      RCC_APB2PeriphResetCmd(((u32)0x00000400), ENABLE);
N      /* Release ADC2 from reset state */
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
X      RCC_APB2PeriphResetCmd(((u32)0x00000400), DISABLE);
N      break;
N      
N    case ADC3_BASE:
X    case ((((u32)0x40000000) + 0x10000) + 0x3C00):
N      /* Enable ADC3 reset state */
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
X      RCC_APB2PeriphResetCmd(((u32)0x00008000), ENABLE);
N      /* Release ADC3 from reset state */
N      RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
X      RCC_APB2PeriphResetCmd(((u32)0x00008000), DISABLE);
N      break; 
N
N    default:
N      break;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_Init
N* Description    : Initializes the ADCx peripheral according to the specified parameters
N*                  in the ADC_InitStruct.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_InitStruct: pointer to an ADC_InitTypeDef structure that
N*                    contains the configuration information for the specified
N*                    ADC peripheral.
N* Output         : None
N* Return         : None
N******************************************************************************/
Nvoid ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
N{
N  u32 tmpreg1 = 0;
N  u8 tmpreg2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));  		    
X  ((void)0);  		    
N  assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
X  ((void)0);   
N  assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
X  ((void)0); 
N  assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
X  ((void)0);
N
N  /*---------------------------- ADCx CR1 Configuration -----------------*/
N  /* Get the ADCx CR1 value */
N  tmpreg1 = ADCx->CR1;
N  /* Clear DUALMOD and SCAN bits */
N  tmpreg1 &= CR1_CLEAR_Mask;
X  tmpreg1 &= ((u32)0xFFF0FEFF);
N  /* Configure ADCx: Dual mode and scan conversion mode */
N  /* Set DUALMOD bits according to ADC_Mode value */
N  /* Set SCAN bit according to ADC_ScanConvMode value */
N  tmpreg1 |= (u32)(ADC_InitStruct->ADC_Mode | ((u32)ADC_InitStruct->ADC_ScanConvMode << 8));
N  /* Write to ADCx CR1 */
N  ADCx->CR1 = tmpreg1;
N
N  /*---------------------------- ADCx CR2 Configuration -----------------*/
N  /* Get the ADCx CR2 value */
N  tmpreg1 = ADCx->CR2;
N  /* Clear CONT, ALIGN and EXTSEL bits */
N  tmpreg1 &= CR2_CLEAR_Mask;
X  tmpreg1 &= ((u32)0xFFF1F7FD);
N  /* Configure ADCx: external trigger event and continuous conversion mode */
N  /* Set ALIGN bit according to ADC_DataAlign value */
N  /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
N  /* Set CONT bit according to ADC_ContinuousConvMode value */
N  tmpreg1 |= (u32)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
N            ((u32)ADC_InitStruct->ADC_ContinuousConvMode << 1));
N  /* Write to ADCx CR2 */
N  ADCx->CR2 = tmpreg1;
N
N  /*---------------------------- ADCx SQR1 Configuration -----------------*/
N  /* Get the ADCx SQR1 value */
N  tmpreg1 = ADCx->SQR1;
N  /* Clear L bits */
N  tmpreg1 &= SQR1_CLEAR_Mask;
X  tmpreg1 &= ((u32)0xFF0FFFFF);
N  /* Configure ADCx: regular channel sequence length */
N  /* Set L bits according to ADC_NbrOfChannel value */
N  tmpreg2 |= (ADC_InitStruct->ADC_NbrOfChannel - 1);
N  tmpreg1 |= ((u32)tmpreg2 << 20);
N  /* Write to ADCx SQR1 */
N  ADCx->SQR1 = tmpreg1;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_StructInit
N* Description    : Fills each ADC_InitStruct member with its default value.
N* Input          : ADC_InitStruct : pointer to an ADC_InitTypeDef structure
N*                  which will be initialized.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
N{
N  /* Reset ADC init structure parameters values */
N  /* Initialize the ADC_Mode member */
N  ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
X  ADC_InitStruct->ADC_Mode = ((u32)0x00000000);
N
N  /* initialize the ADC_ScanConvMode member */
N  ADC_InitStruct->ADC_ScanConvMode = DISABLE;
N
N  /* Initialize the ADC_ContinuousConvMode member */
N  ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
N
N  /* Initialize the ADC_ExternalTrigConv member */
N  ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
X  ADC_InitStruct->ADC_ExternalTrigConv = ((u32)0x00000000);
N
N  /* Initialize the ADC_DataAlign member */
N  ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
X  ADC_InitStruct->ADC_DataAlign = ((u32)0x00000000);
N
N  /* Initialize the ADC_NbrOfChannel member */
N  ADC_InitStruct->ADC_NbrOfChannel = 1;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_Cmd
N* Description    : Enables or disables the specified ADC peripheral.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - NewState: new state of the ADCx peripheral. This parameter
N*                    can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Set the ADON bit to wake up the ADC from power down mode */
N    ADCx->CR2 |= CR2_ADON_Set;
X    ADCx->CR2 |= ((u32)0x00000001);
N  }
N  else
N  {
N    /* Disable the selected ADC peripheral */
N    ADCx->CR2 &= CR2_ADON_Reset;
X    ADCx->CR2 &= ((u32)0xFFFFFFFE);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_DMACmd
N* Description    : Enables or disables the specified ADC DMA request.
N* Input          : - ADCx: where x can be 1 or 3 to select the ADC peripheral.
N*                    Note: ADC2 hasn't a DMA capability.
N*                  - NewState: new state of the selected ADC DMA transfer.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_DMA_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC DMA request */
N    ADCx->CR2 |= CR2_DMA_Set;
X    ADCx->CR2 |= ((u32)0x00000100);
N  }
N  else
N  {
N    /* Disable the selected ADC DMA request */
N    ADCx->CR2 &= CR2_DMA_Reset;
X    ADCx->CR2 &= ((u32)0xFFFFFEFF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_ITConfig
N* Description    : Enables or disables the specified ADC interrupts.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_IT: specifies the ADC interrupt sources to be enabled
N*                    or disabled. 
N*                    This parameter can be any combination of the following values:
N*                       - ADC_IT_EOC: End of conversion interrupt mask
N*                       - ADC_IT_AWD: Analog watchdog interrupt mask
N*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
N*                  - NewState: new state of the specified ADC interrupts.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_ITConfig(ADC_TypeDef* ADCx, u16 ADC_IT, FunctionalState NewState)
N{
N  u8 itmask = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N  assert_param(IS_ADC_IT(ADC_IT));
X  ((void)0);
N
N  /* Get the ADC IT index */
N  itmask = (u8)ADC_IT;
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC interrupts */
N    ADCx->CR1 |= itmask;
N  }
N  else
N  {
N    /* Disable the selected ADC interrupts */
N    ADCx->CR1 &= (~(u32)itmask);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_ResetCalibration
N* Description    : Resets the selected ADC calibration registers.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_ResetCalibration(ADC_TypeDef* ADCx)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Resets the selected ADC calibartion registers */  
N  ADCx->CR2 |= CR2_RSTCAL_Set;
X  ADCx->CR2 |= ((u32)0x00000008);
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetResetCalibrationStatus
N* Description    : Gets the selected ADC reset calibration registers status.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N* Output         : None
N* Return         : The new state of ADC reset calibration registers (SET or RESET).
N*******************************************************************************/
NFlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Check the status of RSTCAL bit */
N  if ((ADCx->CR2 & CR2_RSTCAL_Set) != (u32)RESET)
X  if ((ADCx->CR2 & ((u32)0x00000008)) != (u32)RESET)
N  {
N    /* RSTCAL bit is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* RSTCAL bit is reset */
N    bitstatus = RESET;
N  }
N
N  /* Return the RSTCAL bit status */
N  return  bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_StartCalibration
N* Description    : Starts the selected ADC calibration process.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_StartCalibration(ADC_TypeDef* ADCx)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Enable the selected ADC calibration process */  
N  ADCx->CR2 |= CR2_CAL_Set;
X  ADCx->CR2 |= ((u32)0x00000004);
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetCalibrationStatus
N* Description    : Gets the selected ADC calibration status.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N* Output         : None
N* Return         : The new state of ADC calibration (SET or RESET).
N*******************************************************************************/
NFlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Check the status of CAL bit */
N  if ((ADCx->CR2 & CR2_CAL_Set) != (u32)RESET)
X  if ((ADCx->CR2 & ((u32)0x00000004)) != (u32)RESET)
N  {
N    /* CAL bit is set: calibration on going */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* CAL bit is reset: end of calibration */
N    bitstatus = RESET;
N  }
N
N  /* Return the CAL bit status */
N  return  bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_SoftwareStartConvCmd
N* Description    : Enables or disables the selected ADC software start conversion .
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - NewState: new state of the selected ADC software start conversion.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC conversion on external event and start the selected
N       ADC conversion */
N    ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
X    ADCx->CR2 |= ((u32)0x00500000);
N  }
N  else
N  {
N    /* Disable the selected ADC conversion on external event and stop the selected
N       ADC conversion */
N    ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
X    ADCx->CR2 &= ((u32)0xFFAFFFFF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetSoftwareStartConvStatus
N* Description    : Gets the selected ADC Software start conversion Status.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N* Output         : None
N* Return         : The new state of ADC software start conversion (SET or RESET).
N*******************************************************************************/
NFlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Check the status of SWSTART bit */
N  if ((ADCx->CR2 & CR2_SWSTART_Set) != (u32)RESET)
X  if ((ADCx->CR2 & ((u32)0x00400000)) != (u32)RESET)
N  {
N    /* SWSTART bit is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* SWSTART bit is reset */
N    bitstatus = RESET;
N  }
N
N  /* Return the SWSTART bit status */
N  return  bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_DiscModeChannelCountConfig
N* Description    : Configures the discontinuous mode for the selected ADC regular
N*                  group channel.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - Number: specifies the discontinuous mode regular channel
N*                    count value. This number must be between 1 and 8.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, u8 Number)
N{
N  u32 tmpreg1 = 0;
N  u32 tmpreg2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg1 = ADCx->CR1;
N  /* Clear the old discontinuous mode channel count */
N  tmpreg1 &= CR1_DISCNUM_Reset;
X  tmpreg1 &= ((u32)0xFFFF1FFF);
N  /* Set the discontinuous mode channel count */
N  tmpreg2 = Number - 1;
N  tmpreg1 |= tmpreg2 << 13;
N  /* Store the new register value */
N  ADCx->CR1 = tmpreg1;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_DiscModeCmd
N* Description    : Enables or disables the discontinuous mode on regular group
N*                  channel for the specified ADC
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - NewState: new state of the selected ADC discontinuous mode
N*                    on regular group channel.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC regular discontinuous mode */
N    ADCx->CR1 |= CR1_DISCEN_Set;
X    ADCx->CR1 |= ((u32)0x00000800);
N  }
N  else
N  {
N    /* Disable the selected ADC regular discontinuous mode */
N    ADCx->CR1 &= CR1_DISCEN_Reset;
X    ADCx->CR1 &= ((u32)0xFFFFF7FF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_RegularChannelConfig
N* Description    : Configures for the selected ADC regular channel its corresponding
N*                  rank in the sequencer and its sample time.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_Channel: the ADC channel to configure. 
N*                    This parameter can be one of the following values:
N*                       - ADC_Channel_0: ADC Channel0 selected
N*                       - ADC_Channel_1: ADC Channel1 selected
N*                       - ADC_Channel_2: ADC Channel2 selected
N*                       - ADC_Channel_3: ADC Channel3 selected
N*                       - ADC_Channel_4: ADC Channel4 selected
N*                       - ADC_Channel_5: ADC Channel5 selected
N*                       - ADC_Channel_6: ADC Channel6 selected
N*                       - ADC_Channel_7: ADC Channel7 selected
N*                       - ADC_Channel_8: ADC Channel8 selected
N*                       - ADC_Channel_9: ADC Channel9 selected
N*                       - ADC_Channel_10: ADC Channel10 selected
N*                       - ADC_Channel_11: ADC Channel11 selected
N*                       - ADC_Channel_12: ADC Channel12 selected
N*                       - ADC_Channel_13: ADC Channel13 selected
N*                       - ADC_Channel_14: ADC Channel14 selected
N*                       - ADC_Channel_15: ADC Channel15 selected
N*                       - ADC_Channel_16: ADC Channel16 selected
N*                       - ADC_Channel_17: ADC Channel17 selected
N*                  - Rank: The rank in the regular group sequencer. This parameter
N*                    must be between 1 to 16.
N*                  - ADC_SampleTime: The sample time value to be set for the
N*                    selected channel. 
N*                    This parameter can be one of the following values:
N*                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
N*                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
N*                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
N*                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
N*                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
N*                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
N*                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
N*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_RegularChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
N{
N  u32 tmpreg1 = 0, tmpreg2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_CHANNEL(ADC_Channel));
X  ((void)0);
N  assert_param(IS_ADC_REGULAR_RANK(Rank));
X  ((void)0);
N  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
X  ((void)0);
N
N  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
N  if (ADC_Channel > ADC_Channel_9)
X  if (ADC_Channel > ((u8)0x09))
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR1;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
X    tmpreg2 = ((u32)0x00000007) << (3 * (ADC_Channel - 10));
N    /* Clear the old discontinuous mode channel count */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (u32)ADC_SampleTime << (3 * (ADC_Channel - 10));
N    /* Set the discontinuous mode channel count */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR1 = tmpreg1;
N  }
N  else /* ADC_Channel include in ADC_Channel_[0..9] */
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR2;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
X    tmpreg2 = ((u32)0x00000007) << (3 * ADC_Channel);
N    /* Clear the old discontinuous mode channel count */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
N    /* Set the discontinuous mode channel count */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR2 = tmpreg1;
N  }
N  /* For Rank 1 to 6 */
N  if (Rank < 7)
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SQR3;
N    /* Calculate the mask to clear */
N    tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
X    tmpreg2 = ((u32)0x0000001F) << (5 * (Rank - 1));
N    /* Clear the old SQx bits for the selected rank */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 1));
N    /* Set the SQx bits for the selected rank */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SQR3 = tmpreg1;
N  }
N  /* For Rank 7 to 12 */
N  else if (Rank < 13)
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SQR2;
N    /* Calculate the mask to clear */
N    tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
X    tmpreg2 = ((u32)0x0000001F) << (5 * (Rank - 7));
N    /* Clear the old SQx bits for the selected rank */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 7));
N    /* Set the SQx bits for the selected rank */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SQR2 = tmpreg1;
N  }
N  /* For Rank 13 to 16 */
N  else
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SQR1;
N    /* Calculate the mask to clear */
N    tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
X    tmpreg2 = ((u32)0x0000001F) << (5 * (Rank - 13));
N    /* Clear the old SQx bits for the selected rank */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (u32)ADC_Channel << (5 * (Rank - 13));
N    /* Set the SQx bits for the selected rank */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SQR1 = tmpreg1;
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_ExternalTrigConvCmd
N* Description    : Enables or disables the ADCx conversion through external trigger.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - NewState: new state of the selected ADC external trigger
N*                    start of conversion.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC conversion on external event */
N    ADCx->CR2 |= CR2_EXTTRIG_Set;
X    ADCx->CR2 |= ((u32)0x00100000);
N  }
N  else
N  {
N    /* Disable the selected ADC conversion on external event */
N    ADCx->CR2 &= CR2_EXTTRIG_Reset;
X    ADCx->CR2 &= ((u32)0xFFEFFFFF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetConversionValue
N* Description    : Returns the last ADCx conversion result data for regular channel.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N* Output         : None
N* Return         : The Data conversion value.
N*******************************************************************************/
Nu16 ADC_GetConversionValue(ADC_TypeDef* ADCx)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Return the selected ADC conversion value */
N  return (u16) ADCx->DR;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetDualModeConversionValue
N* Description    : Returns the last ADC1 and ADC2 conversion result data in dual mode.
N* Output         : None
N* Return         : The Data conversion value.
N*******************************************************************************/
Nu32 ADC_GetDualModeConversionValue(void)
N{
N  /* Return the dual mode conversion value */
N  return (*(vu32 *) DR_ADDRESS);
X  return (*(vu32 *) ((u32)0x4001244C));
N}
N
N/*******************************************************************************
N* Function Name  : ADC_AutoInjectedConvCmd
N* Description    : Enables or disables the selected ADC automatic injected group
N*                  conversion after regular one.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - NewState: new state of the selected ADC auto injected
N*                    conversion
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC automatic injected group conversion */
N    ADCx->CR1 |= CR1_JAUTO_Set;
X    ADCx->CR1 |= ((u32)0x00000400);
N  }
N  else
N  {
N    /* Disable the selected ADC automatic injected group conversion */
N    ADCx->CR1 &= CR1_JAUTO_Reset;
X    ADCx->CR1 &= ((u32)0xFFFFFBFF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_InjectedDiscModeCmd
N* Description    : Enables or disables the discontinuous mode for injected group
N*                  channel for the specified ADC
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - NewState: new state of the selected ADC discontinuous mode
N*                    on injected group channel.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC injected discontinuous mode */
N    ADCx->CR1 |= CR1_JDISCEN_Set;
X    ADCx->CR1 |= ((u32)0x00001000);
N  }
N  else
N  {
N    /* Disable the selected ADC injected discontinuous mode */
N    ADCx->CR1 &= CR1_JDISCEN_Reset;
X    ADCx->CR1 &= ((u32)0xFFFFEFFF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_ExternalTrigInjectedConvConfig
N* Description    : Configures the ADCx external trigger for injected channels conversion.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_ExternalTrigInjecConv: specifies the ADC trigger to
N*                    start injected conversion. 
N*                    This parameter can be one of the following values:
N*                       - ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event 
N*                         selected (for ADC1, ADC2 and ADC3)
N*                       - ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture
N*                         compare4 selected (for ADC1, ADC2 and ADC3)
N*                       - ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event
N*                         selected (for ADC1 and ADC2)
N*                       - ADC_External TrigInjecConv_T2_CC1: Timer2 capture
N*                         compare1 selected (for ADC1 and ADC2)
N*                       - ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture
N*                         compare4 selected (for ADC1 and ADC2)
N*                       - ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event
N*                         selected (for ADC1 and ADC2)
N*                       - ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External
N*                         interrupt line 15 or Timer8 capture compare4 event selected
N*                         (for ADC1 and ADC2)                       
N*                       - ADC_External TrigInjecConv_T4_CC3: Timer4 capture
N*                         compare3 selected (for ADC3 only)
N*                       - ADC_External TrigInjecConv_T8_CC2: Timer8 capture
N*                         compare2 selected (for ADC3 only)                         
N*                       - ADC_External TrigInjecConv_T8_CC4: Timer8 capture
N*                         compare4 selected (for ADC3 only)
N*                       - ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event
N*                         selected (for ADC3 only)                         
N*                       - ADC_External TrigInjecConv_T5_CC4: Timer5 capture
N*                         compare4 selected (for ADC3 only)                        
N*                       - ADC_ExternalTrigInjecConv_None: Injected conversion
N*                         started by software and not by external trigger (for 
N*                         ADC1, ADC2 and ADC3)
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, u32 ADC_ExternalTrigInjecConv)
N{
N  u32 tmpreg = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg = ADCx->CR2;
N  /* Clear the old external event selection for injected group */
N  tmpreg &= CR2_JEXTSEL_Reset;
X  tmpreg &= ((u32)0xFFFF8FFF);
N  /* Set the external event selection for injected group */
N  tmpreg |= ADC_ExternalTrigInjecConv;
N  /* Store the new register value */
N  ADCx->CR2 = tmpreg;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_ExternalTrigInjectedConvCmd
N* Description    : Enables or disables the ADCx injected channels conversion
N*                  through external trigger
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - NewState: new state of the selected ADC external trigger
N*                    start of injected conversion.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC external event selection for injected group */
N    ADCx->CR2 |= CR2_JEXTTRIG_Set;
X    ADCx->CR2 |= ((u32)0x00008000);
N  }
N  else
N  {
N    /* Disable the selected ADC external event selection for injected group */
N    ADCx->CR2 &= CR2_JEXTTRIG_Reset;
X    ADCx->CR2 &= ((u32)0xFFFF7FFF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_SoftwareStartInjectedConvCmd
N* Description    : Enables or disables the selected ADC start of the injected 
N*                  channels conversion.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - NewState: new state of the selected ADC software start
N*                    injected conversion.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the selected ADC conversion for injected group on external event and start the selected
N       ADC injected conversion */
N    ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
X    ADCx->CR2 |= ((u32)0x00208000);
N  }
N  else
N  {
N    /* Disable the selected ADC conversion on external event for injected group and stop the selected
N       ADC injected conversion */
N    ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
X    ADCx->CR2 &= ((u32)0xFFDF7FFF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetSoftwareStartInjectedConvCmdStatus
N* Description    : Gets the selected ADC Software start injected conversion Status.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N* Output         : None
N* Return         : The new state of ADC software start injected conversion (SET or RESET).
N*******************************************************************************/
NFlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N
N  /* Check the status of JSWSTART bit */
N  if ((ADCx->CR2 & CR2_JSWSTART_Set) != (u32)RESET)
X  if ((ADCx->CR2 & ((u32)0x00200000)) != (u32)RESET)
N  {
N    /* JSWSTART bit is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* JSWSTART bit is reset */
N    bitstatus = RESET;
N  }
N
N  /* Return the JSWSTART bit status */
N  return  bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_InjectedChannelConfig
N* Description    : Configures for the selected ADC injected channel its corresponding
N*                  rank in the sequencer and its sample time.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_Channel: the ADC channel to configure. 
N*                    This parameter can be one of the following values:
N*                       - ADC_Channel_0: ADC Channel0 selected
N*                       - ADC_Channel_1: ADC Channel1 selected
N*                       - ADC_Channel_2: ADC Channel2 selected
N*                       - ADC_Channel_3: ADC Channel3 selected
N*                       - ADC_Channel_4: ADC Channel4 selected
N*                       - ADC_Channel_5: ADC Channel5 selected
N*                       - ADC_Channel_6: ADC Channel6 selected
N*                       - ADC_Channel_7: ADC Channel7 selected
N*                       - ADC_Channel_8: ADC Channel8 selected
N*                       - ADC_Channel_9: ADC Channel9 selected
N*                       - ADC_Channel_10: ADC Channel10 selected
N*                       - ADC_Channel_11: ADC Channel11 selected
N*                       - ADC_Channel_12: ADC Channel12 selected
N*                       - ADC_Channel_13: ADC Channel13 selected
N*                       - ADC_Channel_14: ADC Channel14 selected
N*                       - ADC_Channel_15: ADC Channel15 selected
N*                       - ADC_Channel_16: ADC Channel16 selected
N*                       - ADC_Channel_17: ADC Channel17 selected
N*                  - Rank: The rank in the injected group sequencer. This parameter
N*                    must be between 1 to 4.
N*                  - ADC_SampleTime: The sample time value to be set for the
N*                    selected channel. 
N*                    This parameter can be one of the following values:
N*                       - ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
N*                       - ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
N*                       - ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
N*                       - ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
N*                       - ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
N*                       - ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
N*                       - ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
N*                       - ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel, u8 Rank, u8 ADC_SampleTime)
N{
N  u32 tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_CHANNEL(ADC_Channel));
X  ((void)0);
N  assert_param(IS_ADC_INJECTED_RANK(Rank));
X  ((void)0);
N  assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
X  ((void)0);
N
N  /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
N  if (ADC_Channel > ADC_Channel_9)
X  if (ADC_Channel > ((u8)0x09))
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR1;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
X    tmpreg2 = ((u32)0x00000007) << (3*(ADC_Channel - 10));
N    /* Clear the old discontinuous mode channel count */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (u32)ADC_SampleTime << (3*(ADC_Channel - 10));
N    /* Set the discontinuous mode channel count */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR1 = tmpreg1;
N  }
N  else /* ADC_Channel include in ADC_Channel_[0..9] */
N  {
N    /* Get the old register value */
N    tmpreg1 = ADCx->SMPR2;
N    /* Calculate the mask to clear */
N    tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
X    tmpreg2 = ((u32)0x00000007) << (3 * ADC_Channel);
N    /* Clear the old discontinuous mode channel count */
N    tmpreg1 &= ~tmpreg2;
N    /* Calculate the mask to set */
N    tmpreg2 = (u32)ADC_SampleTime << (3 * ADC_Channel);
N    /* Set the discontinuous mode channel count */
N    tmpreg1 |= tmpreg2;
N    /* Store the new register value */
N    ADCx->SMPR2 = tmpreg1;
N  }
N
N  /* Rank configuration */
N  /* Get the old register value */
N  tmpreg1 = ADCx->JSQR;
N  /* Get JL value: Number = JL+1 */
N  tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
X  tmpreg3 =  (tmpreg1 & ((u32)0x00300000))>> 20;
N  /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
N  tmpreg2 = JSQR_JSQ_Set << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
X  tmpreg2 = ((u32)0x0000001F) << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
N  /* Clear the old JSQx bits for the selected rank */
N  tmpreg1 &= ~tmpreg2;
N  /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
N  tmpreg2 = (u32)ADC_Channel << (5 * (u8)((Rank + 3) - (tmpreg3 + 1)));
N  /* Set the JSQx bits for the selected rank */
N  tmpreg1 |= tmpreg2;
N  /* Store the new register value */
N  ADCx->JSQR = tmpreg1;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_InjectedSequencerLengthConfig
N* Description    : Configures the sequencer length for injected channels
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - Length: The sequencer length. 
N*                    This parameter must be a number between 1 to 4.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, u8 Length)
N{
N  u32 tmpreg1 = 0;
N  u32 tmpreg2 = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_INJECTED_LENGTH(Length));
X  ((void)0);
N  
N  /* Get the old register value */
N  tmpreg1 = ADCx->JSQR;
N  /* Clear the old injected sequnence lenght JL bits */
N  tmpreg1 &= JSQR_JL_Reset;
X  tmpreg1 &= ((u32)0xFFCFFFFF);
N  /* Set the injected sequnence lenght JL bits */
N  tmpreg2 = Length - 1; 
N  tmpreg1 |= tmpreg2 << 20;
N  /* Store the new register value */
N  ADCx->JSQR = tmpreg1;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_SetInjectedOffset
N* Description    : Set the injected channels conversion value offset
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_InjectedChannel: the ADC injected channel to set its
N*                    offset. 
N*                    This parameter can be one of the following values:
N*                       - ADC_InjectedChannel_1: Injected Channel1 selected
N*                       - ADC_InjectedChannel_2: Injected Channel2 selected
N*                       - ADC_InjectedChannel_3: Injected Channel3 selected
N*                       - ADC_InjectedChannel_4: Injected Channel4 selected
N*                  - Offset: the offset value for the selected ADC injected channel
N*                    This parameter must be a 12bit value.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_SetInjectedOffset(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel, u16 Offset)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
X  ((void)0);
N  assert_param(IS_ADC_OFFSET(Offset));  
X  ((void)0);  
N
N  /* Set the selected injected channel data offset */
N  *((vu32 *)((*(u32*)&ADCx) + ADC_InjectedChannel)) = (u32)Offset;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetInjectedConversionValue
N* Description    : Returns the ADC injected channel conversion result
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_InjectedChannel: the converted ADC injected channel.
N*                    This parameter can be one of the following values:
N*                       - ADC_InjectedChannel_1: Injected Channel1 selected
N*                       - ADC_InjectedChannel_2: Injected Channel2 selected
N*                       - ADC_InjectedChannel_3: Injected Channel3 selected
N*                       - ADC_InjectedChannel_4: Injected Channel4 selected
N* Output         : None
N* Return         : The Data conversion value.
N*******************************************************************************/
Nu16 ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, u8 ADC_InjectedChannel)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
X  ((void)0);
N
N  /* Returns the selected injected channel conversion data value */
N  return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + JDR_Offset)));
X  return (u16) (*(vu32*) (((*(u32*)&ADCx) + ADC_InjectedChannel + ((u8)0x28))));
N}
N
N/*******************************************************************************
N* Function Name  : ADC_AnalogWatchdogCmd
N* Description    : Enables or disables the analog watchdog on single/all regular
N*                  or injected channels
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_AnalogWatchdog: the ADC analog watchdog configuration.
N*                    This parameter can be one of the following values:
N*                       - ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on
N*                         a single regular channel
N*                       - ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on
N*                         a single injected channel
N*                       - ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog 
N*                         watchdog on a single regular or injected channel
N*                       - ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on
N*                         all regular channel
N*                       - ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on
N*                         all injected channel
N*                       - ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog
N*                         on all regular and injected channels
N*                       - ADC_AnalogWatchdog_None: No channel guarded by the
N*                         analog watchdog
N* Output         : None
N* Return         : None	  
N*******************************************************************************/
Nvoid ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, u32 ADC_AnalogWatchdog)
N{
N  u32 tmpreg = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg = ADCx->CR1;
N  /* Clear AWDEN, AWDENJ and AWDSGL bits */
N  tmpreg &= CR1_AWDMode_Reset;
X  tmpreg &= ((u32)0xFF3FFDFF);
N  /* Set the analog watchdog enable mode */
N  tmpreg |= ADC_AnalogWatchdog;
N  /* Store the new register value */
N  ADCx->CR1 = tmpreg;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_AnalogWatchdogThresholdsConfig
N* Description    : Configures the high and low thresholds of the analog watchdog.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - HighThreshold: the ADC analog watchdog High threshold value.
N*                    This parameter must be a 12bit value.
N*                  - LowThreshold: the ADC analog watchdog Low threshold value.
N*                    This parameter must be a 12bit value.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, u16 HighThreshold,
N                                        u16 LowThreshold)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_THRESHOLD(HighThreshold));
X  ((void)0);
N  assert_param(IS_ADC_THRESHOLD(LowThreshold));
X  ((void)0);
N
N  /* Set the ADCx high threshold */
N  ADCx->HTR = HighThreshold;
N  /* Set the ADCx low threshold */
N  ADCx->LTR = LowThreshold;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_AnalogWatchdogSingleChannelConfig
N* Description    : Configures the analog watchdog guarded single channel
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_Channel: the ADC channel to configure for the analog
N*                    watchdog. 
N*                    This parameter can be one of the following values:
N*                       - ADC_Channel_0: ADC Channel0 selected
N*                       - ADC_Channel_1: ADC Channel1 selected
N*                       - ADC_Channel_2: ADC Channel2 selected
N*                       - ADC_Channel_3: ADC Channel3 selected
N*                       - ADC_Channel_4: ADC Channel4 selected
N*                       - ADC_Channel_5: ADC Channel5 selected
N*                       - ADC_Channel_6: ADC Channel6 selected
N*                       - ADC_Channel_7: ADC Channel7 selected
N*                       - ADC_Channel_8: ADC Channel8 selected
N*                       - ADC_Channel_9: ADC Channel9 selected
N*                       - ADC_Channel_10: ADC Channel10 selected
N*                       - ADC_Channel_11: ADC Channel11 selected
N*                       - ADC_Channel_12: ADC Channel12 selected
N*                       - ADC_Channel_13: ADC Channel13 selected
N*                       - ADC_Channel_14: ADC Channel14 selected
N*                       - ADC_Channel_15: ADC Channel15 selected
N*                       - ADC_Channel_16: ADC Channel16 selected
N*                       - ADC_Channel_17: ADC Channel17 selected
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, u8 ADC_Channel)
N{
N  u32 tmpreg = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_CHANNEL(ADC_Channel));
X  ((void)0);
N
N  /* Get the old register value */
N  tmpreg = ADCx->CR1;
N  /* Clear the Analog watchdog channel select bits */
N  tmpreg &= CR1_AWDCH_Reset;
X  tmpreg &= ((u32)0xFFFFFFE0);
N  /* Set the Analog watchdog channel */
N  tmpreg |= ADC_Channel;
N  /* Store the new register value */
N  ADCx->CR1 = tmpreg;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_TempSensorVrefintCmd
N* Description    : Enables or disables the temperature sensor and Vrefint channel.
N* Input          : - NewState: new state of the temperature sensor.
N*                    This parameter can be: ENABLE or DISABLE.
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_TempSensorVrefintCmd(FunctionalState NewState)
N{
N  /* Check the parameters */
N  assert_param(IS_FUNCTIONAL_STATE(NewState));
X  ((void)0);
N
N  if (NewState != DISABLE)
N  {
N    /* Enable the temperature sensor and Vrefint channel*/
N    ADC1->CR2 |= CR2_TSVREFE_Set;
X    ((ADC_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2400))->CR2 |= ((u32)0x00800000);
N  }
N  else
N  {
N    /* Disable the temperature sensor and Vrefint channel*/
N    ADC1->CR2 &= CR2_TSVREFE_Reset;
X    ((ADC_TypeDef *) ((((u32)0x40000000) + 0x10000) + 0x2400))->CR2 &= ((u32)0xFF7FFFFF);
N  }
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetFlagStatus
N* Description    : Checks whether the specified ADC flag is set or not.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_FLAG: specifies the flag to check. 
N*                    This parameter can be one of the following values:
N*                       - ADC_FLAG_AWD: Analog watchdog flag
N*                       - ADC_FLAG_EOC: End of conversion flag
N*                       - ADC_FLAG_JEOC: End of injected group conversion flag
N*                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
N*                       - ADC_FLAG_STRT: Start of regular group conversion flag
N* Output         : None
N* Return         : The new state of ADC_FLAG (SET or RESET).
N*******************************************************************************/
NFlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, u8 ADC_FLAG)
N{
N  FlagStatus bitstatus = RESET;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
X  ((void)0);
N
N  /* Check the status of the specified ADC flag */
N  if ((ADCx->SR & ADC_FLAG) != (u8)RESET)
N  {
N    /* ADC_FLAG is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* ADC_FLAG is reset */
N    bitstatus = RESET;
N  }
N
N  /* Return the ADC_FLAG status */
N  return  bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_ClearFlag
N* Description    : Clears the ADCx's pending flags.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_FLAG: specifies the flag to clear. 
N*                    This parameter can be any combination of the following values:
N*                       - ADC_FLAG_AWD: Analog watchdog flag
N*                       - ADC_FLAG_EOC: End of conversion flag
N*                       - ADC_FLAG_JEOC: End of injected group conversion flag
N*                       - ADC_FLAG_JSTRT: Start of injected group conversion flag
N*                       - ADC_FLAG_STRT: Start of regular group conversion flag
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_ClearFlag(ADC_TypeDef* ADCx, u8 ADC_FLAG)
N{
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
X  ((void)0);
N
N  /* Clear the selected ADC flags */
N  ADCx->SR = ~(u32)ADC_FLAG;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_GetITStatus
N* Description    : Checks whether the specified ADC interrupt has occurred or not.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_IT: specifies the ADC interrupt source to check. 
N*                    This parameter can be one of the following values:
N*                       - ADC_IT_EOC: End of conversion interrupt mask
N*                       - ADC_IT_AWD: Analog watchdog interrupt mask
N*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
N* Output         : None
N* Return         : The new state of ADC_IT (SET or RESET).
N*******************************************************************************/
NITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, u16 ADC_IT)
N{
N  ITStatus bitstatus = RESET;
N  u32 itmask = 0, enablestatus = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_GET_IT(ADC_IT));
X  ((void)0);
N
N  /* Get the ADC IT index */
N  itmask = ADC_IT >> 8;
N
N  /* Get the ADC_IT enable bit status */
N  enablestatus = (ADCx->CR1 & (u8)ADC_IT) ;
N
N  /* Check the status of the specified ADC interrupt */
N  if (((ADCx->SR & itmask) != (u32)RESET) && enablestatus)
N  {
N    /* ADC_IT is set */
N    bitstatus = SET;
N  }
N  else
N  {
N    /* ADC_IT is reset */
N    bitstatus = RESET;
N  }
N
N  /* Return the ADC_IT status */
N  return  bitstatus;
N}
N
N/*******************************************************************************
N* Function Name  : ADC_ClearITPendingBit
N* Description    : Clears the ADCxs interrupt pending bits.
N* Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
N*                  - ADC_IT: specifies the ADC interrupt pending bit to clear.
N*                    This parameter can be any combination of the following values:
N*                       - ADC_IT_EOC: End of conversion interrupt mask
N*                       - ADC_IT_AWD: Analog watchdog interrupt mask
N*                       - ADC_IT_JEOC: End of injected conversion interrupt mask
N* Output         : None
N* Return         : None
N*******************************************************************************/
Nvoid ADC_ClearITPendingBit(ADC_TypeDef* ADCx, u16 ADC_IT)
N{
N  u8 itmask = 0;
N
N  /* Check the parameters */
N  assert_param(IS_ADC_ALL_PERIPH(ADCx));
X  ((void)0);
N  assert_param(IS_ADC_IT(ADC_IT));
X  ((void)0);
N
N  /* Get the ADC IT index */
N  itmask = (u8)(ADC_IT >> 8);
N
N  /* Clear the selected ADC interrupt pending bits */
N  ADCx->SR = ~(u32)itmask;
N}
N
N/******************* (C) COPYRIGHT 2008 STMicroelectronics *****END OF FILE****/
